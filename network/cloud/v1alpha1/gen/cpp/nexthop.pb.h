// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nexthop.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_nexthop_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_nexthop_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networktypes.pb.h"
#include "google/api/resource.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nexthop_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_nexthop_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_nexthop_2eproto;
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
class IPNextHopSpec;
struct IPNextHopSpecDefaultTypeInternal;
extern IPNextHopSpecDefaultTypeInternal _IPNextHopSpec_default_instance_;
class NextHop;
struct NextHopDefaultTypeInternal;
extern NextHopDefaultTypeInternal _NextHop_default_instance_;
class NextHopGroup;
struct NextHopGroupDefaultTypeInternal;
extern NextHopGroupDefaultTypeInternal _NextHopGroup_default_instance_;
class NextHopGroupLookup;
struct NextHopGroupLookupDefaultTypeInternal;
extern NextHopGroupLookupDefaultTypeInternal _NextHopGroupLookup_default_instance_;
class NextHopGroupSpec;
struct NextHopGroupSpecDefaultTypeInternal;
extern NextHopGroupSpecDefaultTypeInternal _NextHopGroupSpec_default_instance_;
class NextHopGroupStatus;
struct NextHopGroupStatusDefaultTypeInternal;
extern NextHopGroupStatusDefaultTypeInternal _NextHopGroupStatus_default_instance_;
class NextHopLookup;
struct NextHopLookupDefaultTypeInternal;
extern NextHopLookupDefaultTypeInternal _NextHopLookup_default_instance_;
class NextHopSpec;
struct NextHopSpecDefaultTypeInternal;
extern NextHopSpecDefaultTypeInternal _NextHopSpec_default_instance_;
class NextHopStatus;
struct NextHopStatusDefaultTypeInternal;
extern NextHopStatusDefaultTypeInternal _NextHopStatus_default_instance_;
class OverlayNextHopSpec;
struct OverlayNextHopSpecDefaultTypeInternal;
extern OverlayNextHopSpecDefaultTypeInternal _OverlayNextHopSpec_default_instance_;
class OverlayNextHopStatus;
struct OverlayNextHopStatusDefaultTypeInternal;
extern OverlayNextHopStatusDefaultTypeInternal _OverlayNextHopStatus_default_instance_;
class UnderlayNextHopSpec;
struct UnderlayNextHopSpecDefaultTypeInternal;
extern UnderlayNextHopSpecDefaultTypeInternal _UnderlayNextHopSpec_default_instance_;
class UnderlayNextHopStatus;
struct UnderlayNextHopStatusDefaultTypeInternal;
extern UnderlayNextHopStatusDefaultTypeInternal _UnderlayNextHopStatus_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::IPNextHopSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHop* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHop>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopGroup* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopGroup>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopGroupLookup* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopGroupLookup>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopGroupSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopGroupStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopLookup* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopLookup>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::NextHopStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {

enum NextHopType : int {
  NEXT_HOP_TYPE_UNSPECIFIED = 0,
  NEXT_HOP_TYPE_IP = 1,
  NEXT_HOP_TYPE_UNDERLAY = 2,
  NEXT_HOP_TYPE_OVERLAY = 3,
  NextHopType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NextHopType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NextHopType_IsValid(int value);
constexpr NextHopType NextHopType_MIN = NEXT_HOP_TYPE_UNSPECIFIED;
constexpr NextHopType NextHopType_MAX = NEXT_HOP_TYPE_OVERLAY;
constexpr int NextHopType_ARRAYSIZE = NextHopType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NextHopType_descriptor();
template<typename T>
inline const std::string& NextHopType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NextHopType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NextHopType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NextHopType_descriptor(), enum_t_value);
}
inline bool NextHopType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NextHopType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NextHopType>(
    NextHopType_descriptor(), name, value);
}
enum NextHopGroupType : int {
  NEXT_HOP_GROUP_TYPE_UNSPECIFIED = 0,
  NEXT_HOP_GROUP_TYPE_OVERLAY_ECMP = 1,
  NEXT_HOP_GROUP_TYPE_UNDERLAY_ECMP = 2,
  NextHopGroupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NextHopGroupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NextHopGroupType_IsValid(int value);
constexpr NextHopGroupType NextHopGroupType_MIN = NEXT_HOP_GROUP_TYPE_UNSPECIFIED;
constexpr NextHopGroupType NextHopGroupType_MAX = NEXT_HOP_GROUP_TYPE_UNDERLAY_ECMP;
constexpr int NextHopGroupType_ARRAYSIZE = NextHopGroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NextHopGroupType_descriptor();
template<typename T>
inline const std::string& NextHopGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NextHopGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NextHopGroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NextHopGroupType_descriptor(), enum_t_value);
}
inline bool NextHopGroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NextHopGroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NextHopGroupType>(
    NextHopGroupType_descriptor(), name, value);
}
// ===================================================================

class NextHop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHop) */ {
 public:
  inline NextHop() : NextHop(nullptr) {}
  ~NextHop() override;
  explicit PROTOBUF_CONSTEXPR NextHop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHop(const NextHop& from);
  NextHop(NextHop&& from) noexcept
    : NextHop() {
    *this = ::std::move(from);
  }

  inline NextHop& operator=(const NextHop& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHop& operator=(NextHop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHop& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextHop* internal_default_instance() {
    return reinterpret_cast<const NextHop*>(
               &_NextHop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NextHop& a, NextHop& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHop& from) {
    NextHop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHop";
  }
  protected:
  explicit NextHop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.network.cloud.v1alpha1.NextHopSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::NextHopSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::NextHopSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::NextHopSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::NextHopSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::NextHopSpec* spec);
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.NextHopStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::NextHopStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::NextHopStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::NextHopStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::NextHopStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::NextHopStatus* status);
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::network::cloud::v1alpha1::NextHopSpec* spec_;
    ::opi_api::network::cloud::v1alpha1::NextHopStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopSpec) */ {
 public:
  inline NextHopSpec() : NextHopSpec(nullptr) {}
  ~NextHopSpec() override;
  explicit PROTOBUF_CONSTEXPR NextHopSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopSpec(const NextHopSpec& from);
  NextHopSpec(NextHopSpec&& from) noexcept
    : NextHopSpec() {
    *this = ::std::move(from);
  }

  inline NextHopSpec& operator=(const NextHopSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopSpec& operator=(NextHopSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopSpec& default_instance() {
    return *internal_default_instance();
  }
  enum NhinfoCase {
    kOverlayNhInfo = 1,
    kUnderlayNhInfo = 2,
    kIpNhInfo = 3,
    NHINFO_NOT_SET = 0,
  };

  static inline const NextHopSpec* internal_default_instance() {
    return reinterpret_cast<const NextHopSpec*>(
               &_NextHopSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NextHopSpec& a, NextHopSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopSpec& from) {
    NextHopSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopSpec";
  }
  protected:
  explicit NextHopSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayNhInfoFieldNumber = 1,
    kUnderlayNhInfoFieldNumber = 2,
    kIpNhInfoFieldNumber = 3,
  };
  // .opi_api.network.cloud.v1alpha1.OverlayNextHopSpec overlay_nh_info = 1;
  bool has_overlay_nh_info() const;
  private:
  bool _internal_has_overlay_nh_info() const;
  public:
  void clear_overlay_nh_info();
  const ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec& overlay_nh_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* release_overlay_nh_info();
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* mutable_overlay_nh_info();
  void set_allocated_overlay_nh_info(::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* overlay_nh_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec& _internal_overlay_nh_info() const;
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* _internal_mutable_overlay_nh_info();
  public:
  void unsafe_arena_set_allocated_overlay_nh_info(
      ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* overlay_nh_info);
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* unsafe_arena_release_overlay_nh_info();

  // .opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec underlay_nh_info = 2;
  bool has_underlay_nh_info() const;
  private:
  bool _internal_has_underlay_nh_info() const;
  public:
  void clear_underlay_nh_info();
  const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec& underlay_nh_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* release_underlay_nh_info();
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* mutable_underlay_nh_info();
  void set_allocated_underlay_nh_info(::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* underlay_nh_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec& _internal_underlay_nh_info() const;
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* _internal_mutable_underlay_nh_info();
  public:
  void unsafe_arena_set_allocated_underlay_nh_info(
      ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* underlay_nh_info);
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* unsafe_arena_release_underlay_nh_info();

  // .opi_api.network.cloud.v1alpha1.IPNextHopSpec ip_nh_info = 3;
  bool has_ip_nh_info() const;
  private:
  bool _internal_has_ip_nh_info() const;
  public:
  void clear_ip_nh_info();
  const ::opi_api::network::cloud::v1alpha1::IPNextHopSpec& ip_nh_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* release_ip_nh_info();
  ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* mutable_ip_nh_info();
  void set_allocated_ip_nh_info(::opi_api::network::cloud::v1alpha1::IPNextHopSpec* ip_nh_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::IPNextHopSpec& _internal_ip_nh_info() const;
  ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* _internal_mutable_ip_nh_info();
  public:
  void unsafe_arena_set_allocated_ip_nh_info(
      ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* ip_nh_info);
  ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* unsafe_arena_release_ip_nh_info();

  void clear_nhinfo();
  NhinfoCase nhinfo_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopSpec)
 private:
  class _Internal;
  void set_has_overlay_nh_info();
  void set_has_underlay_nh_info();
  void set_has_ip_nh_info();

  inline bool has_nhinfo() const;
  inline void clear_has_nhinfo();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union NhinfoUnion {
      constexpr NhinfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* overlay_nh_info_;
      ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* underlay_nh_info_;
      ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* ip_nh_info_;
    } nhinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class UnderlayNextHopSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec) */ {
 public:
  inline UnderlayNextHopSpec() : UnderlayNextHopSpec(nullptr) {}
  ~UnderlayNextHopSpec() override;
  explicit PROTOBUF_CONSTEXPR UnderlayNextHopSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnderlayNextHopSpec(const UnderlayNextHopSpec& from);
  UnderlayNextHopSpec(UnderlayNextHopSpec&& from) noexcept
    : UnderlayNextHopSpec() {
    *this = ::std::move(from);
  }

  inline UnderlayNextHopSpec& operator=(const UnderlayNextHopSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnderlayNextHopSpec& operator=(UnderlayNextHopSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnderlayNextHopSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnderlayNextHopSpec* internal_default_instance() {
    return reinterpret_cast<const UnderlayNextHopSpec*>(
               &_UnderlayNextHopSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnderlayNextHopSpec& a, UnderlayNextHopSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(UnderlayNextHopSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnderlayNextHopSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnderlayNextHopSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnderlayNextHopSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnderlayNextHopSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnderlayNextHopSpec& from) {
    UnderlayNextHopSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnderlayNextHopSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec";
  }
  protected:
  explicit UnderlayNextHopSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterfaceNameRefFieldNumber = 1,
    kUnderlayNhMacFieldNumber = 2,
  };
  // string interface_name_ref = 1;
  void clear_interface_name_ref();
  const std::string& interface_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interface_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interface_name_ref();
  PROTOBUF_NODISCARD std::string* release_interface_name_ref();
  void set_allocated_interface_name_ref(std::string* interface_name_ref);
  private:
  const std::string& _internal_interface_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interface_name_ref(const std::string& value);
  std::string* _internal_mutable_interface_name_ref();
  public:

  // bytes underlay_nh_mac = 2;
  void clear_underlay_nh_mac();
  const std::string& underlay_nh_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_underlay_nh_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_underlay_nh_mac();
  PROTOBUF_NODISCARD std::string* release_underlay_nh_mac();
  void set_allocated_underlay_nh_mac(std::string* underlay_nh_mac);
  private:
  const std::string& _internal_underlay_nh_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_underlay_nh_mac(const std::string& value);
  std::string* _internal_mutable_underlay_nh_mac();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interface_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr underlay_nh_mac_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class OverlayNextHopSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec) */ {
 public:
  inline OverlayNextHopSpec() : OverlayNextHopSpec(nullptr) {}
  ~OverlayNextHopSpec() override;
  explicit PROTOBUF_CONSTEXPR OverlayNextHopSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverlayNextHopSpec(const OverlayNextHopSpec& from);
  OverlayNextHopSpec(OverlayNextHopSpec&& from) noexcept
    : OverlayNextHopSpec() {
    *this = ::std::move(from);
  }

  inline OverlayNextHopSpec& operator=(const OverlayNextHopSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverlayNextHopSpec& operator=(OverlayNextHopSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverlayNextHopSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverlayNextHopSpec* internal_default_instance() {
    return reinterpret_cast<const OverlayNextHopSpec*>(
               &_OverlayNextHopSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OverlayNextHopSpec& a, OverlayNextHopSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(OverlayNextHopSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverlayNextHopSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverlayNextHopSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverlayNextHopSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverlayNextHopSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverlayNextHopSpec& from) {
    OverlayNextHopSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverlayNextHopSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.OverlayNextHopSpec";
  }
  protected:
  explicit OverlayNextHopSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelNameRefFieldNumber = 1,
  };
  // string tunnel_name_ref = 1;
  void clear_tunnel_name_ref();
  const std::string& tunnel_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tunnel_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tunnel_name_ref();
  PROTOBUF_NODISCARD std::string* release_tunnel_name_ref();
  void set_allocated_tunnel_name_ref(std::string* tunnel_name_ref);
  private:
  const std::string& _internal_tunnel_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tunnel_name_ref(const std::string& value);
  std::string* _internal_mutable_tunnel_name_ref();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tunnel_name_ref_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class IPNextHopSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.IPNextHopSpec) */ {
 public:
  inline IPNextHopSpec() : IPNextHopSpec(nullptr) {}
  ~IPNextHopSpec() override;
  explicit PROTOBUF_CONSTEXPR IPNextHopSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IPNextHopSpec(const IPNextHopSpec& from);
  IPNextHopSpec(IPNextHopSpec&& from) noexcept
    : IPNextHopSpec() {
    *this = ::std::move(from);
  }

  inline IPNextHopSpec& operator=(const IPNextHopSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline IPNextHopSpec& operator=(IPNextHopSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IPNextHopSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const IPNextHopSpec* internal_default_instance() {
    return reinterpret_cast<const IPNextHopSpec*>(
               &_IPNextHopSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IPNextHopSpec& a, IPNextHopSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(IPNextHopSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IPNextHopSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IPNextHopSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IPNextHopSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IPNextHopSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IPNextHopSpec& from) {
    IPNextHopSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IPNextHopSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.IPNextHopSpec";
  }
  protected:
  explicit IPNextHopSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpcNameRefFieldNumber = 1,
    kMacFieldNumber = 4,
    kIpAddressFieldNumber = 2,
    kVlanFieldNumber = 3,
  };
  // string vpc_name_ref = 1;
  void clear_vpc_name_ref();
  const std::string& vpc_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpc_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpc_name_ref();
  PROTOBUF_NODISCARD std::string* release_vpc_name_ref();
  void set_allocated_vpc_name_ref(std::string* vpc_name_ref);
  private:
  const std::string& _internal_vpc_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpc_name_ref(const std::string& value);
  std::string* _internal_mutable_vpc_name_ref();
  public:

  // bytes mac = 4;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 2;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& ip_address() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_ip_address();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_ip_address();
  void set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_ip_address() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_ip_address();
  public:
  void unsafe_arena_set_allocated_ip_address(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_ip_address();

  // int32 vlan = 3;
  void clear_vlan();
  int32_t vlan() const;
  void set_vlan(int32_t value);
  private:
  int32_t _internal_vlan() const;
  void _internal_set_vlan(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.IPNextHopSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpc_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address_;
    int32_t vlan_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopStatus) */ {
 public:
  inline NextHopStatus() : NextHopStatus(nullptr) {}
  ~NextHopStatus() override;
  explicit PROTOBUF_CONSTEXPR NextHopStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopStatus(const NextHopStatus& from);
  NextHopStatus(NextHopStatus&& from) noexcept
    : NextHopStatus() {
    *this = ::std::move(from);
  }

  inline NextHopStatus& operator=(const NextHopStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopStatus& operator=(NextHopStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopStatus& default_instance() {
    return *internal_default_instance();
  }
  enum NhinfoCase {
    kUnderlayNhInfo = 2,
    kOverlayNhInfo = 3,
    NHINFO_NOT_SET = 0,
  };

  static inline const NextHopStatus* internal_default_instance() {
    return reinterpret_cast<const NextHopStatus*>(
               &_NextHopStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NextHopStatus& a, NextHopStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopStatus& from) {
    NextHopStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopStatus";
  }
  protected:
  explicit NextHopStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHwHandleFieldNumber = 1,
    kUnderlayNhInfoFieldNumber = 2,
    kOverlayNhInfoFieldNumber = 3,
  };
  // .opi_api.network.opinetcommon.v1alpha1.HwHandle hw_handle = 1;
  bool has_hw_handle() const;
  private:
  bool _internal_has_hw_handle() const;
  public:
  void clear_hw_handle();
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& hw_handle() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::HwHandle* release_hw_handle();
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* mutable_hw_handle();
  void set_allocated_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& _internal_hw_handle() const;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _internal_mutable_hw_handle();
  public:
  void unsafe_arena_set_allocated_hw_handle(
      ::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle);
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* unsafe_arena_release_hw_handle();

  // .opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus underlay_nh_info = 2;
  bool has_underlay_nh_info() const;
  private:
  bool _internal_has_underlay_nh_info() const;
  public:
  void clear_underlay_nh_info();
  const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus& underlay_nh_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* release_underlay_nh_info();
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* mutable_underlay_nh_info();
  void set_allocated_underlay_nh_info(::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* underlay_nh_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus& _internal_underlay_nh_info() const;
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* _internal_mutable_underlay_nh_info();
  public:
  void unsafe_arena_set_allocated_underlay_nh_info(
      ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* underlay_nh_info);
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* unsafe_arena_release_underlay_nh_info();

  // .opi_api.network.cloud.v1alpha1.OverlayNextHopStatus overlay_nh_info = 3;
  bool has_overlay_nh_info() const;
  private:
  bool _internal_has_overlay_nh_info() const;
  public:
  void clear_overlay_nh_info();
  const ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus& overlay_nh_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* release_overlay_nh_info();
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* mutable_overlay_nh_info();
  void set_allocated_overlay_nh_info(::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* overlay_nh_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus& _internal_overlay_nh_info() const;
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* _internal_mutable_overlay_nh_info();
  public:
  void unsafe_arena_set_allocated_overlay_nh_info(
      ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* overlay_nh_info);
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* unsafe_arena_release_overlay_nh_info();

  void clear_nhinfo();
  NhinfoCase nhinfo_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopStatus)
 private:
  class _Internal;
  void set_has_underlay_nh_info();
  void set_has_overlay_nh_info();

  inline bool has_nhinfo() const;
  inline void clear_has_nhinfo();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle_;
    union NhinfoUnion {
      constexpr NhinfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* underlay_nh_info_;
      ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* overlay_nh_info_;
    } nhinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class UnderlayNextHopStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus) */ {
 public:
  inline UnderlayNextHopStatus() : UnderlayNextHopStatus(nullptr) {}
  ~UnderlayNextHopStatus() override;
  explicit PROTOBUF_CONSTEXPR UnderlayNextHopStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnderlayNextHopStatus(const UnderlayNextHopStatus& from);
  UnderlayNextHopStatus(UnderlayNextHopStatus&& from) noexcept
    : UnderlayNextHopStatus() {
    *this = ::std::move(from);
  }

  inline UnderlayNextHopStatus& operator=(const UnderlayNextHopStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnderlayNextHopStatus& operator=(UnderlayNextHopStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnderlayNextHopStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnderlayNextHopStatus* internal_default_instance() {
    return reinterpret_cast<const UnderlayNextHopStatus*>(
               &_UnderlayNextHopStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UnderlayNextHopStatus& a, UnderlayNextHopStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(UnderlayNextHopStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnderlayNextHopStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnderlayNextHopStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnderlayNextHopStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnderlayNextHopStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnderlayNextHopStatus& from) {
    UnderlayNextHopStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnderlayNextHopStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus";
  }
  protected:
  explicit UnderlayNextHopStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
    kVlanFieldNumber = 2,
  };
  // int32 port = 1;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // int32 vlan = 2;
  void clear_vlan();
  int32_t vlan() const;
  void set_vlan(int32_t value);
  private:
  int32_t _internal_vlan() const;
  void _internal_set_vlan(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t port_;
    int32_t vlan_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class OverlayNextHopStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus) */ {
 public:
  inline OverlayNextHopStatus() : OverlayNextHopStatus(nullptr) {}
  ~OverlayNextHopStatus() override;
  explicit PROTOBUF_CONSTEXPR OverlayNextHopStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverlayNextHopStatus(const OverlayNextHopStatus& from);
  OverlayNextHopStatus(OverlayNextHopStatus&& from) noexcept
    : OverlayNextHopStatus() {
    *this = ::std::move(from);
  }

  inline OverlayNextHopStatus& operator=(const OverlayNextHopStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverlayNextHopStatus& operator=(OverlayNextHopStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverlayNextHopStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverlayNextHopStatus* internal_default_instance() {
    return reinterpret_cast<const OverlayNextHopStatus*>(
               &_OverlayNextHopStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OverlayNextHopStatus& a, OverlayNextHopStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OverlayNextHopStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverlayNextHopStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverlayNextHopStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverlayNextHopStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverlayNextHopStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverlayNextHopStatus& from) {
    OverlayNextHopStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverlayNextHopStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.OverlayNextHopStatus";
  }
  protected:
  explicit OverlayNextHopStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelIpFieldNumber = 1,
  };
  // .opi_api.network.opinetcommon.v1alpha1.IPAddress tunnel_ip = 1;
  bool has_tunnel_ip() const;
  private:
  bool _internal_has_tunnel_ip() const;
  public:
  void clear_tunnel_ip();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& tunnel_ip() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_tunnel_ip();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_tunnel_ip();
  void set_allocated_tunnel_ip(::opi_api::network::opinetcommon::v1alpha1::IPAddress* tunnel_ip);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_tunnel_ip() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_tunnel_ip();
  public:
  void unsafe_arena_set_allocated_tunnel_ip(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* tunnel_ip);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_tunnel_ip();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* tunnel_ip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopLookup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopLookup) */ {
 public:
  inline NextHopLookup() : NextHopLookup(nullptr) {}
  ~NextHopLookup() override;
  explicit PROTOBUF_CONSTEXPR NextHopLookup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopLookup(const NextHopLookup& from);
  NextHopLookup(NextHopLookup&& from) noexcept
    : NextHopLookup() {
    *this = ::std::move(from);
  }

  inline NextHopLookup& operator=(const NextHopLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopLookup& operator=(NextHopLookup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopLookup& default_instance() {
    return *internal_default_instance();
  }
  enum GettypeCase {
    kType = 1,
    kNhNameRef = 2,
    GETTYPE_NOT_SET = 0,
  };

  static inline const NextHopLookup* internal_default_instance() {
    return reinterpret_cast<const NextHopLookup*>(
               &_NextHopLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NextHopLookup& a, NextHopLookup& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopLookup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopLookup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopLookup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopLookup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopLookup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopLookup& from) {
    NextHopLookup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopLookup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopLookup";
  }
  protected:
  explicit NextHopLookup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNhNameRefFieldNumber = 2,
  };
  // .opi_api.network.cloud.v1alpha1.NextHopType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::NextHopType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::NextHopType value);
  private:
  ::opi_api::network::cloud::v1alpha1::NextHopType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::NextHopType value);
  public:

  // string nh_name_ref = 2;
  bool has_nh_name_ref() const;
  private:
  bool _internal_has_nh_name_ref() const;
  public:
  void clear_nh_name_ref();
  const std::string& nh_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nh_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nh_name_ref();
  PROTOBUF_NODISCARD std::string* release_nh_name_ref();
  void set_allocated_nh_name_ref(std::string* nh_name_ref);
  private:
  const std::string& _internal_nh_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nh_name_ref(const std::string& value);
  std::string* _internal_mutable_nh_name_ref();
  public:

  void clear_gettype();
  GettypeCase gettype_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopLookup)
 private:
  class _Internal;
  void set_has_type();
  void set_has_nh_name_ref();

  inline bool has_gettype() const;
  inline void clear_has_gettype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union GettypeUnion {
      constexpr GettypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int type_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nh_name_ref_;
    } gettype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopGroup) */ {
 public:
  inline NextHopGroup() : NextHopGroup(nullptr) {}
  ~NextHopGroup() override;
  explicit PROTOBUF_CONSTEXPR NextHopGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopGroup(const NextHopGroup& from);
  NextHopGroup(NextHopGroup&& from) noexcept
    : NextHopGroup() {
    *this = ::std::move(from);
  }

  inline NextHopGroup& operator=(const NextHopGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopGroup& operator=(NextHopGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextHopGroup* internal_default_instance() {
    return reinterpret_cast<const NextHopGroup*>(
               &_NextHopGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NextHopGroup& a, NextHopGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopGroup& from) {
    NextHopGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopGroup";
  }
  protected:
  explicit NextHopGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.network.cloud.v1alpha1.NextHopGroupSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* spec);
  ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.NextHopGroupStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* status);
  ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* spec_;
    ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopGroupSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopGroupSpec) */ {
 public:
  inline NextHopGroupSpec() : NextHopGroupSpec(nullptr) {}
  ~NextHopGroupSpec() override;
  explicit PROTOBUF_CONSTEXPR NextHopGroupSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopGroupSpec(const NextHopGroupSpec& from);
  NextHopGroupSpec(NextHopGroupSpec&& from) noexcept
    : NextHopGroupSpec() {
    *this = ::std::move(from);
  }

  inline NextHopGroupSpec& operator=(const NextHopGroupSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopGroupSpec& operator=(NextHopGroupSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopGroupSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextHopGroupSpec* internal_default_instance() {
    return reinterpret_cast<const NextHopGroupSpec*>(
               &_NextHopGroupSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NextHopGroupSpec& a, NextHopGroupSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopGroupSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopGroupSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopGroupSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopGroupSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopGroupSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopGroupSpec& from) {
    NextHopGroupSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopGroupSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopGroupSpec";
  }
  protected:
  explicit NextHopGroupSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .opi_api.network.cloud.v1alpha1.NextHopSpec members = 2;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopSpec >*
      mutable_members();
  private:
  const ::opi_api::network::cloud::v1alpha1::NextHopSpec& _internal_members(int index) const;
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* _internal_add_members();
  public:
  const ::opi_api::network::cloud::v1alpha1::NextHopSpec& members(int index) const;
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopSpec >&
      members() const;

  // .opi_api.network.cloud.v1alpha1.NextHopGroupType type = 1;
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::NextHopGroupType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value);
  private:
  ::opi_api::network::cloud::v1alpha1::NextHopGroupType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopGroupSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopSpec > members_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopGroupStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopGroupStatus) */ {
 public:
  inline NextHopGroupStatus() : NextHopGroupStatus(nullptr) {}
  ~NextHopGroupStatus() override;
  explicit PROTOBUF_CONSTEXPR NextHopGroupStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopGroupStatus(const NextHopGroupStatus& from);
  NextHopGroupStatus(NextHopGroupStatus&& from) noexcept
    : NextHopGroupStatus() {
    *this = ::std::move(from);
  }

  inline NextHopGroupStatus& operator=(const NextHopGroupStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopGroupStatus& operator=(NextHopGroupStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopGroupStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextHopGroupStatus* internal_default_instance() {
    return reinterpret_cast<const NextHopGroupStatus*>(
               &_NextHopGroupStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NextHopGroupStatus& a, NextHopGroupStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopGroupStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopGroupStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopGroupStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopGroupStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopGroupStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopGroupStatus& from) {
    NextHopGroupStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopGroupStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopGroupStatus";
  }
  protected:
  explicit NextHopGroupStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 1,
    kHwHandleFieldNumber = 2,
  };
  // repeated .opi_api.network.cloud.v1alpha1.NextHopStatus members = 1;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopStatus >*
      mutable_members();
  private:
  const ::opi_api::network::cloud::v1alpha1::NextHopStatus& _internal_members(int index) const;
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* _internal_add_members();
  public:
  const ::opi_api::network::cloud::v1alpha1::NextHopStatus& members(int index) const;
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopStatus >&
      members() const;

  // .opi_api.network.opinetcommon.v1alpha1.HwHandle hw_handle = 2;
  bool has_hw_handle() const;
  private:
  bool _internal_has_hw_handle() const;
  public:
  void clear_hw_handle();
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& hw_handle() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::HwHandle* release_hw_handle();
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* mutable_hw_handle();
  void set_allocated_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& _internal_hw_handle() const;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _internal_mutable_hw_handle();
  public:
  void unsafe_arena_set_allocated_hw_handle(
      ::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle);
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* unsafe_arena_release_hw_handle();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopGroupStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopStatus > members_;
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// -------------------------------------------------------------------

class NextHopGroupLookup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.NextHopGroupLookup) */ {
 public:
  inline NextHopGroupLookup() : NextHopGroupLookup(nullptr) {}
  ~NextHopGroupLookup() override;
  explicit PROTOBUF_CONSTEXPR NextHopGroupLookup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NextHopGroupLookup(const NextHopGroupLookup& from);
  NextHopGroupLookup(NextHopGroupLookup&& from) noexcept
    : NextHopGroupLookup() {
    *this = ::std::move(from);
  }

  inline NextHopGroupLookup& operator=(const NextHopGroupLookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextHopGroupLookup& operator=(NextHopGroupLookup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextHopGroupLookup& default_instance() {
    return *internal_default_instance();
  }
  enum GettypeCase {
    kType = 1,
    kNhGroupNameRef = 2,
    GETTYPE_NOT_SET = 0,
  };

  static inline const NextHopGroupLookup* internal_default_instance() {
    return reinterpret_cast<const NextHopGroupLookup*>(
               &_NextHopGroupLookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NextHopGroupLookup& a, NextHopGroupLookup& b) {
    a.Swap(&b);
  }
  inline void Swap(NextHopGroupLookup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextHopGroupLookup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextHopGroupLookup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextHopGroupLookup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NextHopGroupLookup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NextHopGroupLookup& from) {
    NextHopGroupLookup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextHopGroupLookup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.NextHopGroupLookup";
  }
  protected:
  explicit NextHopGroupLookup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNhGroupNameRefFieldNumber = 2,
  };
  // .opi_api.network.cloud.v1alpha1.NextHopGroupType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::NextHopGroupType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value);
  private:
  ::opi_api::network::cloud::v1alpha1::NextHopGroupType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value);
  public:

  // string nh_group_name_ref = 2;
  bool has_nh_group_name_ref() const;
  private:
  bool _internal_has_nh_group_name_ref() const;
  public:
  void clear_nh_group_name_ref();
  const std::string& nh_group_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nh_group_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nh_group_name_ref();
  PROTOBUF_NODISCARD std::string* release_nh_group_name_ref();
  void set_allocated_nh_group_name_ref(std::string* nh_group_name_ref);
  private:
  const std::string& _internal_nh_group_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nh_group_name_ref(const std::string& value);
  std::string* _internal_mutable_nh_group_name_ref();
  public:

  void clear_gettype();
  GettypeCase gettype_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.NextHopGroupLookup)
 private:
  class _Internal;
  void set_has_type();
  void set_has_nh_group_name_ref();

  inline bool has_gettype() const;
  inline void clear_has_gettype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union GettypeUnion {
      constexpr GettypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int type_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nh_group_name_ref_;
    } gettype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_nexthop_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NextHop

// string name = 1;
inline void NextHop::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NextHop::name() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHop.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NextHop::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHop.name)
}
inline std::string* NextHop::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHop.name)
  return _s;
}
inline const std::string& NextHop::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NextHop::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NextHop::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NextHop::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHop.name)
  return _impl_.name_.Release();
}
inline void NextHop::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHop.name)
}

// .opi_api.network.cloud.v1alpha1.NextHopSpec spec = 2;
inline bool NextHop::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool NextHop::has_spec() const {
  return _internal_has_spec();
}
inline void NextHop::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopSpec& NextHop::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::NextHopSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::NextHopSpec&>(
      ::opi_api::network::cloud::v1alpha1::_NextHopSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopSpec& NextHop::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHop.spec)
  return _internal_spec();
}
inline void NextHop::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::NextHopSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHop.spec)
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHop::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHop::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHop.spec)
  
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHop::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHop::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHop.spec)
  return _msg;
}
inline void NextHop::set_allocated_spec(::opi_api::network::cloud::v1alpha1::NextHopSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHop.spec)
}

// .opi_api.network.cloud.v1alpha1.NextHopStatus status = 3;
inline bool NextHop::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool NextHop::has_status() const {
  return _internal_has_status();
}
inline void NextHop::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopStatus& NextHop::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::NextHopStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::NextHopStatus&>(
      ::opi_api::network::cloud::v1alpha1::_NextHopStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopStatus& NextHop::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHop.status)
  return _internal_status();
}
inline void NextHop::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::NextHopStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHop.status)
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHop::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHop::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHop.status)
  
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHop::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHop::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHop.status)
  return _msg;
}
inline void NextHop::set_allocated_status(::opi_api::network::cloud::v1alpha1::NextHopStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHop.status)
}

// -------------------------------------------------------------------

// NextHopSpec

// .opi_api.network.cloud.v1alpha1.OverlayNextHopSpec overlay_nh_info = 1;
inline bool NextHopSpec::_internal_has_overlay_nh_info() const {
  return nhinfo_case() == kOverlayNhInfo;
}
inline bool NextHopSpec::has_overlay_nh_info() const {
  return _internal_has_overlay_nh_info();
}
inline void NextHopSpec::set_has_overlay_nh_info() {
  _impl_._oneof_case_[0] = kOverlayNhInfo;
}
inline void NextHopSpec::clear_overlay_nh_info() {
  if (_internal_has_overlay_nh_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.nhinfo_.overlay_nh_info_;
    }
    clear_has_nhinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* NextHopSpec::release_overlay_nh_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopSpec.overlay_nh_info)
  if (_internal_has_overlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* temp = _impl_.nhinfo_.overlay_nh_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nhinfo_.overlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec& NextHopSpec::_internal_overlay_nh_info() const {
  return _internal_has_overlay_nh_info()
      ? *_impl_.nhinfo_.overlay_nh_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec&>(::opi_api::network::cloud::v1alpha1::_OverlayNextHopSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec& NextHopSpec::overlay_nh_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopSpec.overlay_nh_info)
  return _internal_overlay_nh_info();
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* NextHopSpec::unsafe_arena_release_overlay_nh_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.NextHopSpec.overlay_nh_info)
  if (_internal_has_overlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* temp = _impl_.nhinfo_.overlay_nh_info_;
    _impl_.nhinfo_.overlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NextHopSpec::unsafe_arena_set_allocated_overlay_nh_info(::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* overlay_nh_info) {
  clear_nhinfo();
  if (overlay_nh_info) {
    set_has_overlay_nh_info();
    _impl_.nhinfo_.overlay_nh_info_ = overlay_nh_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopSpec.overlay_nh_info)
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* NextHopSpec::_internal_mutable_overlay_nh_info() {
  if (!_internal_has_overlay_nh_info()) {
    clear_nhinfo();
    set_has_overlay_nh_info();
    _impl_.nhinfo_.overlay_nh_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec >(GetArenaForAllocation());
  }
  return _impl_.nhinfo_.overlay_nh_info_;
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* NextHopSpec::mutable_overlay_nh_info() {
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopSpec* _msg = _internal_mutable_overlay_nh_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopSpec.overlay_nh_info)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec underlay_nh_info = 2;
inline bool NextHopSpec::_internal_has_underlay_nh_info() const {
  return nhinfo_case() == kUnderlayNhInfo;
}
inline bool NextHopSpec::has_underlay_nh_info() const {
  return _internal_has_underlay_nh_info();
}
inline void NextHopSpec::set_has_underlay_nh_info() {
  _impl_._oneof_case_[0] = kUnderlayNhInfo;
}
inline void NextHopSpec::clear_underlay_nh_info() {
  if (_internal_has_underlay_nh_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.nhinfo_.underlay_nh_info_;
    }
    clear_has_nhinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* NextHopSpec::release_underlay_nh_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopSpec.underlay_nh_info)
  if (_internal_has_underlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* temp = _impl_.nhinfo_.underlay_nh_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nhinfo_.underlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec& NextHopSpec::_internal_underlay_nh_info() const {
  return _internal_has_underlay_nh_info()
      ? *_impl_.nhinfo_.underlay_nh_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec&>(::opi_api::network::cloud::v1alpha1::_UnderlayNextHopSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec& NextHopSpec::underlay_nh_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopSpec.underlay_nh_info)
  return _internal_underlay_nh_info();
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* NextHopSpec::unsafe_arena_release_underlay_nh_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.NextHopSpec.underlay_nh_info)
  if (_internal_has_underlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* temp = _impl_.nhinfo_.underlay_nh_info_;
    _impl_.nhinfo_.underlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NextHopSpec::unsafe_arena_set_allocated_underlay_nh_info(::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* underlay_nh_info) {
  clear_nhinfo();
  if (underlay_nh_info) {
    set_has_underlay_nh_info();
    _impl_.nhinfo_.underlay_nh_info_ = underlay_nh_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopSpec.underlay_nh_info)
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* NextHopSpec::_internal_mutable_underlay_nh_info() {
  if (!_internal_has_underlay_nh_info()) {
    clear_nhinfo();
    set_has_underlay_nh_info();
    _impl_.nhinfo_.underlay_nh_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec >(GetArenaForAllocation());
  }
  return _impl_.nhinfo_.underlay_nh_info_;
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* NextHopSpec::mutable_underlay_nh_info() {
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopSpec* _msg = _internal_mutable_underlay_nh_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopSpec.underlay_nh_info)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.IPNextHopSpec ip_nh_info = 3;
inline bool NextHopSpec::_internal_has_ip_nh_info() const {
  return nhinfo_case() == kIpNhInfo;
}
inline bool NextHopSpec::has_ip_nh_info() const {
  return _internal_has_ip_nh_info();
}
inline void NextHopSpec::set_has_ip_nh_info() {
  _impl_._oneof_case_[0] = kIpNhInfo;
}
inline void NextHopSpec::clear_ip_nh_info() {
  if (_internal_has_ip_nh_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.nhinfo_.ip_nh_info_;
    }
    clear_has_nhinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* NextHopSpec::release_ip_nh_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopSpec.ip_nh_info)
  if (_internal_has_ip_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* temp = _impl_.nhinfo_.ip_nh_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nhinfo_.ip_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::IPNextHopSpec& NextHopSpec::_internal_ip_nh_info() const {
  return _internal_has_ip_nh_info()
      ? *_impl_.nhinfo_.ip_nh_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::IPNextHopSpec&>(::opi_api::network::cloud::v1alpha1::_IPNextHopSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::IPNextHopSpec& NextHopSpec::ip_nh_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopSpec.ip_nh_info)
  return _internal_ip_nh_info();
}
inline ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* NextHopSpec::unsafe_arena_release_ip_nh_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.NextHopSpec.ip_nh_info)
  if (_internal_has_ip_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* temp = _impl_.nhinfo_.ip_nh_info_;
    _impl_.nhinfo_.ip_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NextHopSpec::unsafe_arena_set_allocated_ip_nh_info(::opi_api::network::cloud::v1alpha1::IPNextHopSpec* ip_nh_info) {
  clear_nhinfo();
  if (ip_nh_info) {
    set_has_ip_nh_info();
    _impl_.nhinfo_.ip_nh_info_ = ip_nh_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopSpec.ip_nh_info)
}
inline ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* NextHopSpec::_internal_mutable_ip_nh_info() {
  if (!_internal_has_ip_nh_info()) {
    clear_nhinfo();
    set_has_ip_nh_info();
    _impl_.nhinfo_.ip_nh_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::IPNextHopSpec >(GetArenaForAllocation());
  }
  return _impl_.nhinfo_.ip_nh_info_;
}
inline ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* NextHopSpec::mutable_ip_nh_info() {
  ::opi_api::network::cloud::v1alpha1::IPNextHopSpec* _msg = _internal_mutable_ip_nh_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopSpec.ip_nh_info)
  return _msg;
}

inline bool NextHopSpec::has_nhinfo() const {
  return nhinfo_case() != NHINFO_NOT_SET;
}
inline void NextHopSpec::clear_has_nhinfo() {
  _impl_._oneof_case_[0] = NHINFO_NOT_SET;
}
inline NextHopSpec::NhinfoCase NextHopSpec::nhinfo_case() const {
  return NextHopSpec::NhinfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnderlayNextHopSpec

// string interface_name_ref = 1;
inline void UnderlayNextHopSpec::clear_interface_name_ref() {
  _impl_.interface_name_ref_.ClearToEmpty();
}
inline const std::string& UnderlayNextHopSpec::interface_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.interface_name_ref)
  return _internal_interface_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnderlayNextHopSpec::set_interface_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.interface_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.interface_name_ref)
}
inline std::string* UnderlayNextHopSpec::mutable_interface_name_ref() {
  std::string* _s = _internal_mutable_interface_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.interface_name_ref)
  return _s;
}
inline const std::string& UnderlayNextHopSpec::_internal_interface_name_ref() const {
  return _impl_.interface_name_ref_.Get();
}
inline void UnderlayNextHopSpec::_internal_set_interface_name_ref(const std::string& value) {
  
  _impl_.interface_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* UnderlayNextHopSpec::_internal_mutable_interface_name_ref() {
  
  return _impl_.interface_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* UnderlayNextHopSpec::release_interface_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.interface_name_ref)
  return _impl_.interface_name_ref_.Release();
}
inline void UnderlayNextHopSpec::set_allocated_interface_name_ref(std::string* interface_name_ref) {
  if (interface_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.interface_name_ref_.SetAllocated(interface_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.interface_name_ref_.IsDefault()) {
    _impl_.interface_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.interface_name_ref)
}

// bytes underlay_nh_mac = 2;
inline void UnderlayNextHopSpec::clear_underlay_nh_mac() {
  _impl_.underlay_nh_mac_.ClearToEmpty();
}
inline const std::string& UnderlayNextHopSpec::underlay_nh_mac() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.underlay_nh_mac)
  return _internal_underlay_nh_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnderlayNextHopSpec::set_underlay_nh_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.underlay_nh_mac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.underlay_nh_mac)
}
inline std::string* UnderlayNextHopSpec::mutable_underlay_nh_mac() {
  std::string* _s = _internal_mutable_underlay_nh_mac();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.underlay_nh_mac)
  return _s;
}
inline const std::string& UnderlayNextHopSpec::_internal_underlay_nh_mac() const {
  return _impl_.underlay_nh_mac_.Get();
}
inline void UnderlayNextHopSpec::_internal_set_underlay_nh_mac(const std::string& value) {
  
  _impl_.underlay_nh_mac_.Set(value, GetArenaForAllocation());
}
inline std::string* UnderlayNextHopSpec::_internal_mutable_underlay_nh_mac() {
  
  return _impl_.underlay_nh_mac_.Mutable(GetArenaForAllocation());
}
inline std::string* UnderlayNextHopSpec::release_underlay_nh_mac() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.underlay_nh_mac)
  return _impl_.underlay_nh_mac_.Release();
}
inline void UnderlayNextHopSpec::set_allocated_underlay_nh_mac(std::string* underlay_nh_mac) {
  if (underlay_nh_mac != nullptr) {
    
  } else {
    
  }
  _impl_.underlay_nh_mac_.SetAllocated(underlay_nh_mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.underlay_nh_mac_.IsDefault()) {
    _impl_.underlay_nh_mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.UnderlayNextHopSpec.underlay_nh_mac)
}

// -------------------------------------------------------------------

// OverlayNextHopSpec

// string tunnel_name_ref = 1;
inline void OverlayNextHopSpec::clear_tunnel_name_ref() {
  _impl_.tunnel_name_ref_.ClearToEmpty();
}
inline const std::string& OverlayNextHopSpec::tunnel_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec.tunnel_name_ref)
  return _internal_tunnel_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverlayNextHopSpec::set_tunnel_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tunnel_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec.tunnel_name_ref)
}
inline std::string* OverlayNextHopSpec::mutable_tunnel_name_ref() {
  std::string* _s = _internal_mutable_tunnel_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec.tunnel_name_ref)
  return _s;
}
inline const std::string& OverlayNextHopSpec::_internal_tunnel_name_ref() const {
  return _impl_.tunnel_name_ref_.Get();
}
inline void OverlayNextHopSpec::_internal_set_tunnel_name_ref(const std::string& value) {
  
  _impl_.tunnel_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* OverlayNextHopSpec::_internal_mutable_tunnel_name_ref() {
  
  return _impl_.tunnel_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* OverlayNextHopSpec::release_tunnel_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec.tunnel_name_ref)
  return _impl_.tunnel_name_ref_.Release();
}
inline void OverlayNextHopSpec::set_allocated_tunnel_name_ref(std::string* tunnel_name_ref) {
  if (tunnel_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.tunnel_name_ref_.SetAllocated(tunnel_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tunnel_name_ref_.IsDefault()) {
    _impl_.tunnel_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.OverlayNextHopSpec.tunnel_name_ref)
}

// -------------------------------------------------------------------

// IPNextHopSpec

// string vpc_name_ref = 1;
inline void IPNextHopSpec::clear_vpc_name_ref() {
  _impl_.vpc_name_ref_.ClearToEmpty();
}
inline const std::string& IPNextHopSpec::vpc_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vpc_name_ref)
  return _internal_vpc_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPNextHopSpec::set_vpc_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vpc_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vpc_name_ref)
}
inline std::string* IPNextHopSpec::mutable_vpc_name_ref() {
  std::string* _s = _internal_mutable_vpc_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vpc_name_ref)
  return _s;
}
inline const std::string& IPNextHopSpec::_internal_vpc_name_ref() const {
  return _impl_.vpc_name_ref_.Get();
}
inline void IPNextHopSpec::_internal_set_vpc_name_ref(const std::string& value) {
  
  _impl_.vpc_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* IPNextHopSpec::_internal_mutable_vpc_name_ref() {
  
  return _impl_.vpc_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* IPNextHopSpec::release_vpc_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vpc_name_ref)
  return _impl_.vpc_name_ref_.Release();
}
inline void IPNextHopSpec::set_allocated_vpc_name_ref(std::string* vpc_name_ref) {
  if (vpc_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.vpc_name_ref_.SetAllocated(vpc_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vpc_name_ref_.IsDefault()) {
    _impl_.vpc_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vpc_name_ref)
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 2;
inline bool IPNextHopSpec::_internal_has_ip_address() const {
  return this != internal_default_instance() && _impl_.ip_address_ != nullptr;
}
inline bool IPNextHopSpec::has_ip_address() const {
  return _internal_has_ip_address();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPNextHopSpec::_internal_ip_address() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = _impl_.ip_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& IPNextHopSpec::ip_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.IPNextHopSpec.ip_address)
  return _internal_ip_address();
}
inline void IPNextHopSpec::unsafe_arena_set_allocated_ip_address(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_address_);
  }
  _impl_.ip_address_ = ip_address;
  if (ip_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.IPNextHopSpec.ip_address)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPNextHopSpec::release_ip_address() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.ip_address_;
  _impl_.ip_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPNextHopSpec::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.IPNextHopSpec.ip_address)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.ip_address_;
  _impl_.ip_address_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPNextHopSpec::_internal_mutable_ip_address() {
  
  if (_impl_.ip_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    _impl_.ip_address_ = p;
  }
  return _impl_.ip_address_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* IPNextHopSpec::mutable_ip_address() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.IPNextHopSpec.ip_address)
  return _msg;
}
inline void IPNextHopSpec::set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_address_);
  }
  if (ip_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address));
    if (message_arena != submessage_arena) {
      ip_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ip_address_ = ip_address;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.IPNextHopSpec.ip_address)
}

// int32 vlan = 3;
inline void IPNextHopSpec::clear_vlan() {
  _impl_.vlan_ = 0;
}
inline int32_t IPNextHopSpec::_internal_vlan() const {
  return _impl_.vlan_;
}
inline int32_t IPNextHopSpec::vlan() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vlan)
  return _internal_vlan();
}
inline void IPNextHopSpec::_internal_set_vlan(int32_t value) {
  
  _impl_.vlan_ = value;
}
inline void IPNextHopSpec::set_vlan(int32_t value) {
  _internal_set_vlan(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.IPNextHopSpec.vlan)
}

// bytes mac = 4;
inline void IPNextHopSpec::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& IPNextHopSpec::mac() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.IPNextHopSpec.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IPNextHopSpec::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.IPNextHopSpec.mac)
}
inline std::string* IPNextHopSpec::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.IPNextHopSpec.mac)
  return _s;
}
inline const std::string& IPNextHopSpec::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void IPNextHopSpec::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* IPNextHopSpec::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* IPNextHopSpec::release_mac() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.IPNextHopSpec.mac)
  return _impl_.mac_.Release();
}
inline void IPNextHopSpec::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.IPNextHopSpec.mac)
}

// -------------------------------------------------------------------

// NextHopStatus

// .opi_api.network.opinetcommon.v1alpha1.HwHandle hw_handle = 1;
inline bool NextHopStatus::_internal_has_hw_handle() const {
  return this != internal_default_instance() && _impl_.hw_handle_ != nullptr;
}
inline bool NextHopStatus::has_hw_handle() const {
  return _internal_has_hw_handle();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& NextHopStatus::_internal_hw_handle() const {
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle* p = _impl_.hw_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::HwHandle&>(
      ::opi_api::network::opinetcommon::v1alpha1::_HwHandle_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& NextHopStatus::hw_handle() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopStatus.hw_handle)
  return _internal_hw_handle();
}
inline void NextHopStatus::unsafe_arena_set_allocated_hw_handle(
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hw_handle_);
  }
  _impl_.hw_handle_ = hw_handle;
  if (hw_handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopStatus.hw_handle)
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopStatus::release_hw_handle() {
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.hw_handle_;
  _impl_.hw_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopStatus::unsafe_arena_release_hw_handle() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopStatus.hw_handle)
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.hw_handle_;
  _impl_.hw_handle_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopStatus::_internal_mutable_hw_handle() {
  
  if (_impl_.hw_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(GetArenaForAllocation());
    _impl_.hw_handle_ = p;
  }
  return _impl_.hw_handle_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopStatus::mutable_hw_handle() {
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _msg = _internal_mutable_hw_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopStatus.hw_handle)
  return _msg;
}
inline void NextHopStatus::set_allocated_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hw_handle_);
  }
  if (hw_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hw_handle));
    if (message_arena != submessage_arena) {
      hw_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hw_handle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hw_handle_ = hw_handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopStatus.hw_handle)
}

// .opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus underlay_nh_info = 2;
inline bool NextHopStatus::_internal_has_underlay_nh_info() const {
  return nhinfo_case() == kUnderlayNhInfo;
}
inline bool NextHopStatus::has_underlay_nh_info() const {
  return _internal_has_underlay_nh_info();
}
inline void NextHopStatus::set_has_underlay_nh_info() {
  _impl_._oneof_case_[0] = kUnderlayNhInfo;
}
inline void NextHopStatus::clear_underlay_nh_info() {
  if (_internal_has_underlay_nh_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.nhinfo_.underlay_nh_info_;
    }
    clear_has_nhinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* NextHopStatus::release_underlay_nh_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopStatus.underlay_nh_info)
  if (_internal_has_underlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* temp = _impl_.nhinfo_.underlay_nh_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nhinfo_.underlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus& NextHopStatus::_internal_underlay_nh_info() const {
  return _internal_has_underlay_nh_info()
      ? *_impl_.nhinfo_.underlay_nh_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus&>(::opi_api::network::cloud::v1alpha1::_UnderlayNextHopStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus& NextHopStatus::underlay_nh_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopStatus.underlay_nh_info)
  return _internal_underlay_nh_info();
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* NextHopStatus::unsafe_arena_release_underlay_nh_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.NextHopStatus.underlay_nh_info)
  if (_internal_has_underlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* temp = _impl_.nhinfo_.underlay_nh_info_;
    _impl_.nhinfo_.underlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NextHopStatus::unsafe_arena_set_allocated_underlay_nh_info(::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* underlay_nh_info) {
  clear_nhinfo();
  if (underlay_nh_info) {
    set_has_underlay_nh_info();
    _impl_.nhinfo_.underlay_nh_info_ = underlay_nh_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopStatus.underlay_nh_info)
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* NextHopStatus::_internal_mutable_underlay_nh_info() {
  if (!_internal_has_underlay_nh_info()) {
    clear_nhinfo();
    set_has_underlay_nh_info();
    _impl_.nhinfo_.underlay_nh_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus >(GetArenaForAllocation());
  }
  return _impl_.nhinfo_.underlay_nh_info_;
}
inline ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* NextHopStatus::mutable_underlay_nh_info() {
  ::opi_api::network::cloud::v1alpha1::UnderlayNextHopStatus* _msg = _internal_mutable_underlay_nh_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopStatus.underlay_nh_info)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.OverlayNextHopStatus overlay_nh_info = 3;
inline bool NextHopStatus::_internal_has_overlay_nh_info() const {
  return nhinfo_case() == kOverlayNhInfo;
}
inline bool NextHopStatus::has_overlay_nh_info() const {
  return _internal_has_overlay_nh_info();
}
inline void NextHopStatus::set_has_overlay_nh_info() {
  _impl_._oneof_case_[0] = kOverlayNhInfo;
}
inline void NextHopStatus::clear_overlay_nh_info() {
  if (_internal_has_overlay_nh_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.nhinfo_.overlay_nh_info_;
    }
    clear_has_nhinfo();
  }
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* NextHopStatus::release_overlay_nh_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopStatus.overlay_nh_info)
  if (_internal_has_overlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* temp = _impl_.nhinfo_.overlay_nh_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.nhinfo_.overlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus& NextHopStatus::_internal_overlay_nh_info() const {
  return _internal_has_overlay_nh_info()
      ? *_impl_.nhinfo_.overlay_nh_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus&>(::opi_api::network::cloud::v1alpha1::_OverlayNextHopStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus& NextHopStatus::overlay_nh_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopStatus.overlay_nh_info)
  return _internal_overlay_nh_info();
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* NextHopStatus::unsafe_arena_release_overlay_nh_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.NextHopStatus.overlay_nh_info)
  if (_internal_has_overlay_nh_info()) {
    clear_has_nhinfo();
    ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* temp = _impl_.nhinfo_.overlay_nh_info_;
    _impl_.nhinfo_.overlay_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NextHopStatus::unsafe_arena_set_allocated_overlay_nh_info(::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* overlay_nh_info) {
  clear_nhinfo();
  if (overlay_nh_info) {
    set_has_overlay_nh_info();
    _impl_.nhinfo_.overlay_nh_info_ = overlay_nh_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopStatus.overlay_nh_info)
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* NextHopStatus::_internal_mutable_overlay_nh_info() {
  if (!_internal_has_overlay_nh_info()) {
    clear_nhinfo();
    set_has_overlay_nh_info();
    _impl_.nhinfo_.overlay_nh_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus >(GetArenaForAllocation());
  }
  return _impl_.nhinfo_.overlay_nh_info_;
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* NextHopStatus::mutable_overlay_nh_info() {
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopStatus* _msg = _internal_mutable_overlay_nh_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopStatus.overlay_nh_info)
  return _msg;
}

inline bool NextHopStatus::has_nhinfo() const {
  return nhinfo_case() != NHINFO_NOT_SET;
}
inline void NextHopStatus::clear_has_nhinfo() {
  _impl_._oneof_case_[0] = NHINFO_NOT_SET;
}
inline NextHopStatus::NhinfoCase NextHopStatus::nhinfo_case() const {
  return NextHopStatus::NhinfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnderlayNextHopStatus

// int32 port = 1;
inline void UnderlayNextHopStatus::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t UnderlayNextHopStatus::_internal_port() const {
  return _impl_.port_;
}
inline int32_t UnderlayNextHopStatus::port() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus.port)
  return _internal_port();
}
inline void UnderlayNextHopStatus::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void UnderlayNextHopStatus::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus.port)
}

// int32 vlan = 2;
inline void UnderlayNextHopStatus::clear_vlan() {
  _impl_.vlan_ = 0;
}
inline int32_t UnderlayNextHopStatus::_internal_vlan() const {
  return _impl_.vlan_;
}
inline int32_t UnderlayNextHopStatus::vlan() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus.vlan)
  return _internal_vlan();
}
inline void UnderlayNextHopStatus::_internal_set_vlan(int32_t value) {
  
  _impl_.vlan_ = value;
}
inline void UnderlayNextHopStatus::set_vlan(int32_t value) {
  _internal_set_vlan(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.UnderlayNextHopStatus.vlan)
}

// -------------------------------------------------------------------

// OverlayNextHopStatus

// .opi_api.network.opinetcommon.v1alpha1.IPAddress tunnel_ip = 1;
inline bool OverlayNextHopStatus::_internal_has_tunnel_ip() const {
  return this != internal_default_instance() && _impl_.tunnel_ip_ != nullptr;
}
inline bool OverlayNextHopStatus::has_tunnel_ip() const {
  return _internal_has_tunnel_ip();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& OverlayNextHopStatus::_internal_tunnel_ip() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = _impl_.tunnel_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& OverlayNextHopStatus::tunnel_ip() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus.tunnel_ip)
  return _internal_tunnel_ip();
}
inline void OverlayNextHopStatus::unsafe_arena_set_allocated_tunnel_ip(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* tunnel_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tunnel_ip_);
  }
  _impl_.tunnel_ip_ = tunnel_ip;
  if (tunnel_ip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus.tunnel_ip)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopStatus::release_tunnel_ip() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.tunnel_ip_;
  _impl_.tunnel_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopStatus::unsafe_arena_release_tunnel_ip() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus.tunnel_ip)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.tunnel_ip_;
  _impl_.tunnel_ip_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopStatus::_internal_mutable_tunnel_ip() {
  
  if (_impl_.tunnel_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    _impl_.tunnel_ip_ = p;
  }
  return _impl_.tunnel_ip_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopStatus::mutable_tunnel_ip() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_tunnel_ip();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus.tunnel_ip)
  return _msg;
}
inline void OverlayNextHopStatus::set_allocated_tunnel_ip(::opi_api::network::opinetcommon::v1alpha1::IPAddress* tunnel_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tunnel_ip_);
  }
  if (tunnel_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tunnel_ip));
    if (message_arena != submessage_arena) {
      tunnel_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tunnel_ip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tunnel_ip_ = tunnel_ip;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.OverlayNextHopStatus.tunnel_ip)
}

// -------------------------------------------------------------------

// NextHopLookup

// .opi_api.network.cloud.v1alpha1.NextHopType type = 1;
inline bool NextHopLookup::_internal_has_type() const {
  return gettype_case() == kType;
}
inline bool NextHopLookup::has_type() const {
  return _internal_has_type();
}
inline void NextHopLookup::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline void NextHopLookup::clear_type() {
  if (_internal_has_type()) {
    _impl_.gettype_.type_ = 0;
    clear_has_gettype();
  }
}
inline ::opi_api::network::cloud::v1alpha1::NextHopType NextHopLookup::_internal_type() const {
  if (_internal_has_type()) {
    return static_cast< ::opi_api::network::cloud::v1alpha1::NextHopType >(_impl_.gettype_.type_);
  }
  return static_cast< ::opi_api::network::cloud::v1alpha1::NextHopType >(0);
}
inline ::opi_api::network::cloud::v1alpha1::NextHopType NextHopLookup::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopLookup.type)
  return _internal_type();
}
inline void NextHopLookup::_internal_set_type(::opi_api::network::cloud::v1alpha1::NextHopType value) {
  if (!_internal_has_type()) {
    clear_gettype();
    set_has_type();
  }
  _impl_.gettype_.type_ = value;
}
inline void NextHopLookup::set_type(::opi_api::network::cloud::v1alpha1::NextHopType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHopLookup.type)
}

// string nh_name_ref = 2;
inline bool NextHopLookup::_internal_has_nh_name_ref() const {
  return gettype_case() == kNhNameRef;
}
inline bool NextHopLookup::has_nh_name_ref() const {
  return _internal_has_nh_name_ref();
}
inline void NextHopLookup::set_has_nh_name_ref() {
  _impl_._oneof_case_[0] = kNhNameRef;
}
inline void NextHopLookup::clear_nh_name_ref() {
  if (_internal_has_nh_name_ref()) {
    _impl_.gettype_.nh_name_ref_.Destroy();
    clear_has_gettype();
  }
}
inline const std::string& NextHopLookup::nh_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopLookup.nh_name_ref)
  return _internal_nh_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void NextHopLookup::set_nh_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nh_name_ref()) {
    clear_gettype();
    set_has_nh_name_ref();
    _impl_.gettype_.nh_name_ref_.InitDefault();
  }
  _impl_.gettype_.nh_name_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHopLookup.nh_name_ref)
}
inline std::string* NextHopLookup::mutable_nh_name_ref() {
  std::string* _s = _internal_mutable_nh_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopLookup.nh_name_ref)
  return _s;
}
inline const std::string& NextHopLookup::_internal_nh_name_ref() const {
  if (_internal_has_nh_name_ref()) {
    return _impl_.gettype_.nh_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void NextHopLookup::_internal_set_nh_name_ref(const std::string& value) {
  if (!_internal_has_nh_name_ref()) {
    clear_gettype();
    set_has_nh_name_ref();
    _impl_.gettype_.nh_name_ref_.InitDefault();
  }
  _impl_.gettype_.nh_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* NextHopLookup::_internal_mutable_nh_name_ref() {
  if (!_internal_has_nh_name_ref()) {
    clear_gettype();
    set_has_nh_name_ref();
    _impl_.gettype_.nh_name_ref_.InitDefault();
  }
  return _impl_.gettype_.nh_name_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* NextHopLookup::release_nh_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopLookup.nh_name_ref)
  if (_internal_has_nh_name_ref()) {
    clear_has_gettype();
    return _impl_.gettype_.nh_name_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void NextHopLookup::set_allocated_nh_name_ref(std::string* nh_name_ref) {
  if (has_gettype()) {
    clear_gettype();
  }
  if (nh_name_ref != nullptr) {
    set_has_nh_name_ref();
    _impl_.gettype_.nh_name_ref_.InitAllocated(nh_name_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopLookup.nh_name_ref)
}

inline bool NextHopLookup::has_gettype() const {
  return gettype_case() != GETTYPE_NOT_SET;
}
inline void NextHopLookup::clear_has_gettype() {
  _impl_._oneof_case_[0] = GETTYPE_NOT_SET;
}
inline NextHopLookup::GettypeCase NextHopLookup::gettype_case() const {
  return NextHopLookup::GettypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NextHopGroup

// string name = 1;
inline void NextHopGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NextHopGroup::name() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NextHopGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHopGroup.name)
}
inline std::string* NextHopGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroup.name)
  return _s;
}
inline const std::string& NextHopGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NextHopGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NextHopGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NextHopGroup::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopGroup.name)
  return _impl_.name_.Release();
}
inline void NextHopGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroup.name)
}

// .opi_api.network.cloud.v1alpha1.NextHopGroupSpec spec = 2;
inline bool NextHopGroup::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool NextHopGroup::has_spec() const {
  return _internal_has_spec();
}
inline void NextHopGroup::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec& NextHopGroup::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec&>(
      ::opi_api::network::cloud::v1alpha1::_NextHopGroupSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec& NextHopGroup::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroup.spec)
  return _internal_spec();
}
inline void NextHopGroup::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroup.spec)
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* NextHopGroup::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* NextHopGroup::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopGroup.spec)
  
  ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* NextHopGroup::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopGroupSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* NextHopGroup::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroup.spec)
  return _msg;
}
inline void NextHopGroup::set_allocated_spec(::opi_api::network::cloud::v1alpha1::NextHopGroupSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroup.spec)
}

// .opi_api.network.cloud.v1alpha1.NextHopGroupStatus status = 3;
inline bool NextHopGroup::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool NextHopGroup::has_status() const {
  return _internal_has_status();
}
inline void NextHopGroup::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus& NextHopGroup::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus&>(
      ::opi_api::network::cloud::v1alpha1::_NextHopGroupStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus& NextHopGroup::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroup.status)
  return _internal_status();
}
inline void NextHopGroup::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroup.status)
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* NextHopGroup::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* NextHopGroup::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopGroup.status)
  
  ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* NextHopGroup::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::NextHopGroupStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* NextHopGroup::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroup.status)
  return _msg;
}
inline void NextHopGroup::set_allocated_status(::opi_api::network::cloud::v1alpha1::NextHopGroupStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroup.status)
}

// -------------------------------------------------------------------

// NextHopGroupSpec

// .opi_api.network.cloud.v1alpha1.NextHopGroupType type = 1;
inline void NextHopGroupSpec::clear_type() {
  _impl_.type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupType NextHopGroupSpec::_internal_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::NextHopGroupType >(_impl_.type_);
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupType NextHopGroupSpec::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.type)
  return _internal_type();
}
inline void NextHopGroupSpec::_internal_set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value) {
  
  _impl_.type_ = value;
}
inline void NextHopGroupSpec::set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.type)
}

// repeated .opi_api.network.cloud.v1alpha1.NextHopSpec members = 2;
inline int NextHopGroupSpec::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int NextHopGroupSpec::members_size() const {
  return _internal_members_size();
}
inline void NextHopGroupSpec::clear_members() {
  _impl_.members_.Clear();
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHopGroupSpec::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopSpec >*
NextHopGroupSpec::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.members)
  return &_impl_.members_;
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopSpec& NextHopGroupSpec::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopSpec& NextHopGroupSpec::members(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.members)
  return _internal_members(index);
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHopGroupSpec::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::opi_api::network::cloud::v1alpha1::NextHopSpec* NextHopGroupSpec::add_members() {
  ::opi_api::network::cloud::v1alpha1::NextHopSpec* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopSpec >&
NextHopGroupSpec::members() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.NextHopGroupSpec.members)
  return _impl_.members_;
}

// -------------------------------------------------------------------

// NextHopGroupStatus

// repeated .opi_api.network.cloud.v1alpha1.NextHopStatus members = 1;
inline int NextHopGroupStatus::_internal_members_size() const {
  return _impl_.members_.size();
}
inline int NextHopGroupStatus::members_size() const {
  return _internal_members_size();
}
inline void NextHopGroupStatus::clear_members() {
  _impl_.members_.Clear();
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHopGroupStatus::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.members)
  return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopStatus >*
NextHopGroupStatus::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.members)
  return &_impl_.members_;
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopStatus& NextHopGroupStatus::_internal_members(int index) const {
  return _impl_.members_.Get(index);
}
inline const ::opi_api::network::cloud::v1alpha1::NextHopStatus& NextHopGroupStatus::members(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.members)
  return _internal_members(index);
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHopGroupStatus::_internal_add_members() {
  return _impl_.members_.Add();
}
inline ::opi_api::network::cloud::v1alpha1::NextHopStatus* NextHopGroupStatus::add_members() {
  ::opi_api::network::cloud::v1alpha1::NextHopStatus* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::NextHopStatus >&
NextHopGroupStatus::members() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.members)
  return _impl_.members_;
}

// .opi_api.network.opinetcommon.v1alpha1.HwHandle hw_handle = 2;
inline bool NextHopGroupStatus::_internal_has_hw_handle() const {
  return this != internal_default_instance() && _impl_.hw_handle_ != nullptr;
}
inline bool NextHopGroupStatus::has_hw_handle() const {
  return _internal_has_hw_handle();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& NextHopGroupStatus::_internal_hw_handle() const {
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle* p = _impl_.hw_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::HwHandle&>(
      ::opi_api::network::opinetcommon::v1alpha1::_HwHandle_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& NextHopGroupStatus::hw_handle() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.hw_handle)
  return _internal_hw_handle();
}
inline void NextHopGroupStatus::unsafe_arena_set_allocated_hw_handle(
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hw_handle_);
  }
  _impl_.hw_handle_ = hw_handle;
  if (hw_handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.hw_handle)
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopGroupStatus::release_hw_handle() {
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.hw_handle_;
  _impl_.hw_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopGroupStatus::unsafe_arena_release_hw_handle() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.hw_handle)
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.hw_handle_;
  _impl_.hw_handle_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopGroupStatus::_internal_mutable_hw_handle() {
  
  if (_impl_.hw_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(GetArenaForAllocation());
    _impl_.hw_handle_ = p;
  }
  return _impl_.hw_handle_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* NextHopGroupStatus::mutable_hw_handle() {
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _msg = _internal_mutable_hw_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.hw_handle)
  return _msg;
}
inline void NextHopGroupStatus::set_allocated_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* hw_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hw_handle_);
  }
  if (hw_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hw_handle));
    if (message_arena != submessage_arena) {
      hw_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hw_handle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hw_handle_ = hw_handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroupStatus.hw_handle)
}

// -------------------------------------------------------------------

// NextHopGroupLookup

// .opi_api.network.cloud.v1alpha1.NextHopGroupType type = 1;
inline bool NextHopGroupLookup::_internal_has_type() const {
  return gettype_case() == kType;
}
inline bool NextHopGroupLookup::has_type() const {
  return _internal_has_type();
}
inline void NextHopGroupLookup::set_has_type() {
  _impl_._oneof_case_[0] = kType;
}
inline void NextHopGroupLookup::clear_type() {
  if (_internal_has_type()) {
    _impl_.gettype_.type_ = 0;
    clear_has_gettype();
  }
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupType NextHopGroupLookup::_internal_type() const {
  if (_internal_has_type()) {
    return static_cast< ::opi_api::network::cloud::v1alpha1::NextHopGroupType >(_impl_.gettype_.type_);
  }
  return static_cast< ::opi_api::network::cloud::v1alpha1::NextHopGroupType >(0);
}
inline ::opi_api::network::cloud::v1alpha1::NextHopGroupType NextHopGroupLookup::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.type)
  return _internal_type();
}
inline void NextHopGroupLookup::_internal_set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value) {
  if (!_internal_has_type()) {
    clear_gettype();
    set_has_type();
  }
  _impl_.gettype_.type_ = value;
}
inline void NextHopGroupLookup::set_type(::opi_api::network::cloud::v1alpha1::NextHopGroupType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.type)
}

// string nh_group_name_ref = 2;
inline bool NextHopGroupLookup::_internal_has_nh_group_name_ref() const {
  return gettype_case() == kNhGroupNameRef;
}
inline bool NextHopGroupLookup::has_nh_group_name_ref() const {
  return _internal_has_nh_group_name_ref();
}
inline void NextHopGroupLookup::set_has_nh_group_name_ref() {
  _impl_._oneof_case_[0] = kNhGroupNameRef;
}
inline void NextHopGroupLookup::clear_nh_group_name_ref() {
  if (_internal_has_nh_group_name_ref()) {
    _impl_.gettype_.nh_group_name_ref_.Destroy();
    clear_has_gettype();
  }
}
inline const std::string& NextHopGroupLookup::nh_group_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.nh_group_name_ref)
  return _internal_nh_group_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void NextHopGroupLookup::set_nh_group_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nh_group_name_ref()) {
    clear_gettype();
    set_has_nh_group_name_ref();
    _impl_.gettype_.nh_group_name_ref_.InitDefault();
  }
  _impl_.gettype_.nh_group_name_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.nh_group_name_ref)
}
inline std::string* NextHopGroupLookup::mutable_nh_group_name_ref() {
  std::string* _s = _internal_mutable_nh_group_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.nh_group_name_ref)
  return _s;
}
inline const std::string& NextHopGroupLookup::_internal_nh_group_name_ref() const {
  if (_internal_has_nh_group_name_ref()) {
    return _impl_.gettype_.nh_group_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void NextHopGroupLookup::_internal_set_nh_group_name_ref(const std::string& value) {
  if (!_internal_has_nh_group_name_ref()) {
    clear_gettype();
    set_has_nh_group_name_ref();
    _impl_.gettype_.nh_group_name_ref_.InitDefault();
  }
  _impl_.gettype_.nh_group_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* NextHopGroupLookup::_internal_mutable_nh_group_name_ref() {
  if (!_internal_has_nh_group_name_ref()) {
    clear_gettype();
    set_has_nh_group_name_ref();
    _impl_.gettype_.nh_group_name_ref_.InitDefault();
  }
  return _impl_.gettype_.nh_group_name_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* NextHopGroupLookup::release_nh_group_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.nh_group_name_ref)
  if (_internal_has_nh_group_name_ref()) {
    clear_has_gettype();
    return _impl_.gettype_.nh_group_name_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void NextHopGroupLookup::set_allocated_nh_group_name_ref(std::string* nh_group_name_ref) {
  if (has_gettype()) {
    clear_gettype();
  }
  if (nh_group_name_ref != nullptr) {
    set_has_nh_group_name_ref();
    _impl_.gettype_.nh_group_name_ref_.InitAllocated(nh_group_name_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.NextHopGroupLookup.nh_group_name_ref)
}

inline bool NextHopGroupLookup::has_gettype() const {
  return gettype_case() != GETTYPE_NOT_SET;
}
inline void NextHopGroupLookup::clear_has_gettype() {
  _impl_._oneof_case_[0] = GETTYPE_NOT_SET;
}
inline NextHopGroupLookup::GettypeCase NextHopGroupLookup::gettype_case() const {
  return NextHopGroupLookup::GettypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::NextHopType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::NextHopType>() {
  return ::opi_api::network::cloud::v1alpha1::NextHopType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::NextHopGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::NextHopGroupType>() {
  return ::opi_api::network::cloud::v1alpha1::NextHopGroupType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_nexthop_2eproto
