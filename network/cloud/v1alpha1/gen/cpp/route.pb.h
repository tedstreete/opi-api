// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: route.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_route_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_route_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networktypes.pb.h"
#include "google/api/resource.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_route_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_route_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_route_2eproto;
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
class OverlayNextHopIPInfo;
struct OverlayNextHopIPInfoDefaultTypeInternal;
extern OverlayNextHopIPInfoDefaultTypeInternal _OverlayNextHopIPInfo_default_instance_;
class Route;
struct RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class RouteAttrs;
struct RouteAttrsDefaultTypeInternal;
extern RouteAttrsDefaultTypeInternal _RouteAttrs_default_instance_;
class RouteId;
struct RouteIdDefaultTypeInternal;
extern RouteIdDefaultTypeInternal _RouteId_default_instance_;
class RouteInfo;
struct RouteInfoDefaultTypeInternal;
extern RouteInfoDefaultTypeInternal _RouteInfo_default_instance_;
class RouteSpec;
struct RouteSpecDefaultTypeInternal;
extern RouteSpecDefaultTypeInternal _RouteSpec_default_instance_;
class RouteStatus;
struct RouteStatusDefaultTypeInternal;
extern RouteStatusDefaultTypeInternal _RouteStatus_default_instance_;
class RouteTable;
struct RouteTableDefaultTypeInternal;
extern RouteTableDefaultTypeInternal _RouteTable_default_instance_;
class RouteTableSpec;
struct RouteTableSpecDefaultTypeInternal;
extern RouteTableSpecDefaultTypeInternal _RouteTableSpec_default_instance_;
class RouteTableStatus;
struct RouteTableStatusDefaultTypeInternal;
extern RouteTableStatusDefaultTypeInternal _RouteTableStatus_default_instance_;
class VPCPeerNhInfo;
struct VPCPeerNhInfoDefaultTypeInternal;
extern VPCPeerNhInfoDefaultTypeInternal _VPCPeerNhInfo_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::Route* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::Route>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteAttrs* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteAttrs>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteId* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteId>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteInfo* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteInfo>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteTable* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteTable>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteTableSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteTableSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::RouteTableStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteTableStatus>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {

enum RouteClass : int {
  ROUTE_CLASS_UNSPECIFIED = 0,
  ROUTE_CLASS_INTERNET = 1,
  ROUTE_CLASS_SERVICE = 2,
  ROUTE_CLASS_VPC = 3,
  RouteClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteClass_IsValid(int value);
constexpr RouteClass RouteClass_MIN = ROUTE_CLASS_UNSPECIFIED;
constexpr RouteClass RouteClass_MAX = ROUTE_CLASS_VPC;
constexpr int RouteClass_ARRAYSIZE = RouteClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteClass_descriptor();
template<typename T>
inline const std::string& RouteClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteClass_descriptor(), enum_t_value);
}
inline bool RouteClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteClass>(
    RouteClass_descriptor(), name, value);
}
// ===================================================================

class RouteTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteTable) */ {
 public:
  inline RouteTable() : RouteTable(nullptr) {}
  ~RouteTable() override;
  explicit constexpr RouteTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTable(const RouteTable& from);
  RouteTable(RouteTable&& from) noexcept
    : RouteTable() {
    *this = ::std::move(from);
  }

  inline RouteTable& operator=(const RouteTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTable& operator=(RouteTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTable* internal_default_instance() {
    return reinterpret_cast<const RouteTable*>(
               &_RouteTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RouteTable& a, RouteTable& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteTable";
  }
  protected:
  explicit RouteTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.network.cloud.v1alpha1.RouteTableSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::RouteTableSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::RouteTableSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::RouteTableSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteTableSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::RouteTableSpec* spec);
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.RouteTableStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::RouteTableStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::RouteTableStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::RouteTableStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteTableStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::RouteTableStatus* status);
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* spec_;
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteTableSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteTableSpec) */ {
 public:
  inline RouteTableSpec() : RouteTableSpec(nullptr) {}
  ~RouteTableSpec() override;
  explicit constexpr RouteTableSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTableSpec(const RouteTableSpec& from);
  RouteTableSpec(RouteTableSpec&& from) noexcept
    : RouteTableSpec() {
    *this = ::std::move(from);
  }

  inline RouteTableSpec& operator=(const RouteTableSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTableSpec& operator=(RouteTableSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTableSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTableSpec* internal_default_instance() {
    return reinterpret_cast<const RouteTableSpec*>(
               &_RouteTableSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouteTableSpec& a, RouteTableSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTableSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTableSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteTableSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteTableSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTableSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTableSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTableSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteTableSpec";
  }
  protected:
  explicit RouteTableSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 3,
    kAfFieldNumber = 1,
    kPriorityEnableFieldNumber = 2,
  };
  // repeated .opi_api.network.cloud.v1alpha1.RouteInfo routes = 3;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::opi_api::network::cloud::v1alpha1::RouteInfo* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::RouteInfo >*
      mutable_routes();
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteInfo& _internal_routes(int index) const;
  ::opi_api::network::cloud::v1alpha1::RouteInfo* _internal_add_routes();
  public:
  const ::opi_api::network::cloud::v1alpha1::RouteInfo& routes(int index) const;
  ::opi_api::network::cloud::v1alpha1::RouteInfo* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::RouteInfo >&
      routes() const;

  // .opi_api.network.opinetcommon.v1alpha1.IpAf af = 1;
  void clear_af();
  ::opi_api::network::opinetcommon::v1alpha1::IpAf af() const;
  void set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value);
  private:
  ::opi_api::network::opinetcommon::v1alpha1::IpAf _internal_af() const;
  void _internal_set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value);
  public:

  // bool priority_enable = 2;
  void clear_priority_enable();
  bool priority_enable() const;
  void set_priority_enable(bool value);
  private:
  bool _internal_priority_enable() const;
  void _internal_set_priority_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteTableSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::RouteInfo > routes_;
  int af_;
  bool priority_enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteInfo) */ {
 public:
  inline RouteInfo() : RouteInfo(nullptr) {}
  ~RouteInfo() override;
  explicit constexpr RouteInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteInfo(const RouteInfo& from);
  RouteInfo(RouteInfo&& from) noexcept
    : RouteInfo() {
    *this = ::std::move(from);
  }

  inline RouteInfo& operator=(const RouteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteInfo& operator=(RouteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteInfo* internal_default_instance() {
    return reinterpret_cast<const RouteInfo*>(
               &_RouteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouteInfo& a, RouteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteInfo";
  }
  protected:
  explicit RouteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteIdFieldNumber = 1,
    kAttrsFieldNumber = 2,
  };
  // string route_id = 1;
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // .opi_api.network.cloud.v1alpha1.RouteAttrs attrs = 2;
  bool has_attrs() const;
  private:
  bool _internal_has_attrs() const;
  public:
  void clear_attrs();
  const ::opi_api::network::cloud::v1alpha1::RouteAttrs& attrs() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::RouteAttrs* release_attrs();
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* mutable_attrs();
  void set_allocated_attrs(::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs);
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteAttrs& _internal_attrs() const;
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* _internal_mutable_attrs();
  public:
  void unsafe_arena_set_allocated_attrs(
      ::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs);
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* unsafe_arena_release_attrs();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteTableStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteTableStatus) */ {
 public:
  inline RouteTableStatus() : RouteTableStatus(nullptr) {}
  ~RouteTableStatus() override;
  explicit constexpr RouteTableStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteTableStatus(const RouteTableStatus& from);
  RouteTableStatus(RouteTableStatus&& from) noexcept
    : RouteTableStatus() {
    *this = ::std::move(from);
  }

  inline RouteTableStatus& operator=(const RouteTableStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteTableStatus& operator=(RouteTableStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteTableStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteTableStatus* internal_default_instance() {
    return reinterpret_cast<const RouteTableStatus*>(
               &_RouteTableStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RouteTableStatus& a, RouteTableStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteTableStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteTableStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteTableStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteTableStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteTableStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteTableStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteTableStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteTableStatus";
  }
  protected:
  explicit RouteTableStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpcCountFieldNumber = 1,
    kSubnetCountFieldNumber = 2,
    kVnicCountFieldNumber = 3,
    kPoolIdFieldNumber = 4,
    kRouteTableBaseAddressFieldNumber = 6,
    kHwIdxFieldNumber = 5,
    kHwLpmBlockIdxFieldNumber = 7,
    kHwLpmRewriteBlockIdxFieldNumber = 8,
  };
  // int32 vpc_count = 1;
  void clear_vpc_count();
  int32_t vpc_count() const;
  void set_vpc_count(int32_t value);
  private:
  int32_t _internal_vpc_count() const;
  void _internal_set_vpc_count(int32_t value);
  public:

  // int32 subnet_count = 2;
  void clear_subnet_count();
  int32_t subnet_count() const;
  void set_subnet_count(int32_t value);
  private:
  int32_t _internal_subnet_count() const;
  void _internal_set_subnet_count(int32_t value);
  public:

  // int32 vnic_count = 3;
  void clear_vnic_count();
  int32_t vnic_count() const;
  void set_vnic_count(int32_t value);
  private:
  int32_t _internal_vnic_count() const;
  void _internal_set_vnic_count(int32_t value);
  public:

  // int32 pool_id = 4;
  void clear_pool_id();
  int32_t pool_id() const;
  void set_pool_id(int32_t value);
  private:
  int32_t _internal_pool_id() const;
  void _internal_set_pool_id(int32_t value);
  public:

  // uint64 route_table_base_address = 6;
  void clear_route_table_base_address();
  uint64_t route_table_base_address() const;
  void set_route_table_base_address(uint64_t value);
  private:
  uint64_t _internal_route_table_base_address() const;
  void _internal_set_route_table_base_address(uint64_t value);
  public:

  // int32 hw_idx = 5;
  void clear_hw_idx();
  int32_t hw_idx() const;
  void set_hw_idx(int32_t value);
  private:
  int32_t _internal_hw_idx() const;
  void _internal_set_hw_idx(int32_t value);
  public:

  // int32 hw_lpm_block_idx = 7;
  void clear_hw_lpm_block_idx();
  int32_t hw_lpm_block_idx() const;
  void set_hw_lpm_block_idx(int32_t value);
  private:
  int32_t _internal_hw_lpm_block_idx() const;
  void _internal_set_hw_lpm_block_idx(int32_t value);
  public:

  // int32 hw_lpm_rewrite_block_idx = 8;
  void clear_hw_lpm_rewrite_block_idx();
  int32_t hw_lpm_rewrite_block_idx() const;
  void set_hw_lpm_rewrite_block_idx(int32_t value);
  private:
  int32_t _internal_hw_lpm_rewrite_block_idx() const;
  void _internal_set_hw_lpm_rewrite_block_idx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteTableStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t vpc_count_;
  int32_t subnet_count_;
  int32_t vnic_count_;
  int32_t pool_id_;
  uint64_t route_table_base_address_;
  int32_t hw_idx_;
  int32_t hw_lpm_block_idx_;
  int32_t hw_lpm_rewrite_block_idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteAttrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteAttrs) */ {
 public:
  inline RouteAttrs() : RouteAttrs(nullptr) {}
  ~RouteAttrs() override;
  explicit constexpr RouteAttrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteAttrs(const RouteAttrs& from);
  RouteAttrs(RouteAttrs&& from) noexcept
    : RouteAttrs() {
    *this = ::std::move(from);
  }

  inline RouteAttrs& operator=(const RouteAttrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteAttrs& operator=(RouteAttrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteAttrs& default_instance() {
    return *internal_default_instance();
  }
  enum NhCase {
    kOverlayNhIpInfo = 5,
    kNexthopNameRef = 6,
    kNhGroupNameRef = 7,
    kVpcNhInfo = 8,
    kTunnelNameRef = 9,
    kRouteTableNameRef = 10,
    kEvalMapping = 11,
    NH_NOT_SET = 0,
  };

  static inline const RouteAttrs* internal_default_instance() {
    return reinterpret_cast<const RouteAttrs*>(
               &_RouteAttrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RouteAttrs& a, RouteAttrs& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteAttrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteAttrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteAttrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteAttrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteAttrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteAttrs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteAttrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteAttrs";
  }
  protected:
  explicit RouteAttrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayMacFieldNumber = 14,
    kPrefixFieldNumber = 1,
    kEncapFieldNumber = 13,
    kRouteClassFieldNumber = 2,
    kClassPriorityFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kTosFieldNumber = 12,
    kOverlayNhIpInfoFieldNumber = 5,
    kNexthopNameRefFieldNumber = 6,
    kNhGroupNameRefFieldNumber = 7,
    kVpcNhInfoFieldNumber = 8,
    kTunnelNameRefFieldNumber = 9,
    kRouteTableNameRefFieldNumber = 10,
    kEvalMappingFieldNumber = 11,
  };
  // bytes overlay_mac = 14;
  void clear_overlay_mac();
  const std::string& overlay_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_overlay_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_overlay_mac();
  PROTOBUF_NODISCARD std::string* release_overlay_mac();
  void set_allocated_overlay_mac(std::string* overlay_mac);
  private:
  const std::string& _internal_overlay_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_overlay_mac(const std::string& value);
  std::string* _internal_mutable_overlay_mac();
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& prefix() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* release_prefix();
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* mutable_prefix();
  void set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& _internal_prefix() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _internal_mutable_prefix();
  public:
  void unsafe_arena_set_allocated_prefix(
      ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix);
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* unsafe_arena_release_prefix();

  // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 13;
  bool has_encap() const;
  private:
  bool _internal_has_encap() const;
  public:
  void clear_encap();
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& encap() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::Encap* release_encap();
  ::opi_api::network::opinetcommon::v1alpha1::Encap* mutable_encap();
  void set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& _internal_encap() const;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _internal_mutable_encap();
  public:
  void unsafe_arena_set_allocated_encap(
      ::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  ::opi_api::network::opinetcommon::v1alpha1::Encap* unsafe_arena_release_encap();

  // .opi_api.network.cloud.v1alpha1.RouteClass route_class = 2;
  void clear_route_class();
  ::opi_api::network::cloud::v1alpha1::RouteClass route_class() const;
  void set_route_class(::opi_api::network::cloud::v1alpha1::RouteClass value);
  private:
  ::opi_api::network::cloud::v1alpha1::RouteClass _internal_route_class() const;
  void _internal_set_route_class(::opi_api::network::cloud::v1alpha1::RouteClass value);
  public:

  // int32 class_priority = 3;
  void clear_class_priority();
  int32_t class_priority() const;
  void set_class_priority(int32_t value);
  private:
  int32_t _internal_class_priority() const;
  void _internal_set_class_priority(int32_t value);
  public:

  // int32 priority = 4;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // int32 tos = 12;
  void clear_tos();
  int32_t tos() const;
  void set_tos(int32_t value);
  private:
  int32_t _internal_tos() const;
  void _internal_set_tos(int32_t value);
  public:

  // .opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo overlay_nh_ip_info = 5;
  bool has_overlay_nh_ip_info() const;
  private:
  bool _internal_has_overlay_nh_ip_info() const;
  public:
  void clear_overlay_nh_ip_info();
  const ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo& overlay_nh_ip_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* release_overlay_nh_ip_info();
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* mutable_overlay_nh_ip_info();
  void set_allocated_overlay_nh_ip_info(::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* overlay_nh_ip_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo& _internal_overlay_nh_ip_info() const;
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* _internal_mutable_overlay_nh_ip_info();
  public:
  void unsafe_arena_set_allocated_overlay_nh_ip_info(
      ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* overlay_nh_ip_info);
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* unsafe_arena_release_overlay_nh_ip_info();

  // string nexthop_name_ref = 6;
  bool has_nexthop_name_ref() const;
  private:
  bool _internal_has_nexthop_name_ref() const;
  public:
  void clear_nexthop_name_ref();
  const std::string& nexthop_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nexthop_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nexthop_name_ref();
  PROTOBUF_NODISCARD std::string* release_nexthop_name_ref();
  void set_allocated_nexthop_name_ref(std::string* nexthop_name_ref);
  private:
  const std::string& _internal_nexthop_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nexthop_name_ref(const std::string& value);
  std::string* _internal_mutable_nexthop_name_ref();
  public:

  // string nh_group_name_ref = 7;
  bool has_nh_group_name_ref() const;
  private:
  bool _internal_has_nh_group_name_ref() const;
  public:
  void clear_nh_group_name_ref();
  const std::string& nh_group_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nh_group_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nh_group_name_ref();
  PROTOBUF_NODISCARD std::string* release_nh_group_name_ref();
  void set_allocated_nh_group_name_ref(std::string* nh_group_name_ref);
  private:
  const std::string& _internal_nh_group_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nh_group_name_ref(const std::string& value);
  std::string* _internal_mutable_nh_group_name_ref();
  public:

  // .opi_api.network.cloud.v1alpha1.VPCPeerNhInfo vpc_nh_info = 8;
  bool has_vpc_nh_info() const;
  private:
  bool _internal_has_vpc_nh_info() const;
  public:
  void clear_vpc_nh_info();
  const ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo& vpc_nh_info() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* release_vpc_nh_info();
  ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* mutable_vpc_nh_info();
  void set_allocated_vpc_nh_info(::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* vpc_nh_info);
  private:
  const ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo& _internal_vpc_nh_info() const;
  ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* _internal_mutable_vpc_nh_info();
  public:
  void unsafe_arena_set_allocated_vpc_nh_info(
      ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* vpc_nh_info);
  ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* unsafe_arena_release_vpc_nh_info();

  // string tunnel_name_ref = 9;
  bool has_tunnel_name_ref() const;
  private:
  bool _internal_has_tunnel_name_ref() const;
  public:
  void clear_tunnel_name_ref();
  const std::string& tunnel_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tunnel_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tunnel_name_ref();
  PROTOBUF_NODISCARD std::string* release_tunnel_name_ref();
  void set_allocated_tunnel_name_ref(std::string* tunnel_name_ref);
  private:
  const std::string& _internal_tunnel_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tunnel_name_ref(const std::string& value);
  std::string* _internal_mutable_tunnel_name_ref();
  public:

  // string route_table_name_ref = 10;
  bool has_route_table_name_ref() const;
  private:
  bool _internal_has_route_table_name_ref() const;
  public:
  void clear_route_table_name_ref();
  const std::string& route_table_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_table_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_table_name_ref();
  PROTOBUF_NODISCARD std::string* release_route_table_name_ref();
  void set_allocated_route_table_name_ref(std::string* route_table_name_ref);
  private:
  const std::string& _internal_route_table_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_table_name_ref(const std::string& value);
  std::string* _internal_mutable_route_table_name_ref();
  public:

  // bool eval_mapping = 11;
  bool has_eval_mapping() const;
  private:
  bool _internal_has_eval_mapping() const;
  public:
  void clear_eval_mapping();
  bool eval_mapping() const;
  void set_eval_mapping(bool value);
  private:
  bool _internal_eval_mapping() const;
  void _internal_set_eval_mapping(bool value);
  public:

  void clear_nh();
  NhCase nh_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteAttrs)
 private:
  class _Internal;
  void set_has_overlay_nh_ip_info();
  void set_has_nexthop_name_ref();
  void set_has_nh_group_name_ref();
  void set_has_vpc_nh_info();
  void set_has_tunnel_name_ref();
  void set_has_route_table_name_ref();
  void set_has_eval_mapping();

  inline bool has_nh() const;
  inline void clear_has_nh();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr overlay_mac_;
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix_;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* encap_;
  int route_class_;
  int32_t class_priority_;
  int32_t priority_;
  int32_t tos_;
  union NhUnion {
    constexpr NhUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* overlay_nh_ip_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nexthop_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nh_group_name_ref_;
    ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* vpc_nh_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tunnel_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_table_name_ref_;
    bool eval_mapping_;
  } nh_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class VPCPeerNhInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo) */ {
 public:
  inline VPCPeerNhInfo() : VPCPeerNhInfo(nullptr) {}
  ~VPCPeerNhInfo() override;
  explicit constexpr VPCPeerNhInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VPCPeerNhInfo(const VPCPeerNhInfo& from);
  VPCPeerNhInfo(VPCPeerNhInfo&& from) noexcept
    : VPCPeerNhInfo() {
    *this = ::std::move(from);
  }

  inline VPCPeerNhInfo& operator=(const VPCPeerNhInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VPCPeerNhInfo& operator=(VPCPeerNhInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VPCPeerNhInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VPCPeerNhInfo* internal_default_instance() {
    return reinterpret_cast<const VPCPeerNhInfo*>(
               &_VPCPeerNhInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VPCPeerNhInfo& a, VPCPeerNhInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VPCPeerNhInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VPCPeerNhInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VPCPeerNhInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VPCPeerNhInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VPCPeerNhInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VPCPeerNhInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VPCPeerNhInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.VPCPeerNhInfo";
  }
  protected:
  explicit VPCPeerNhInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpcNameRefFieldNumber = 1,
    kRouteTableNameRefFieldNumber = 2,
  };
  // string vpc_name_ref = 1;
  void clear_vpc_name_ref();
  const std::string& vpc_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpc_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpc_name_ref();
  PROTOBUF_NODISCARD std::string* release_vpc_name_ref();
  void set_allocated_vpc_name_ref(std::string* vpc_name_ref);
  private:
  const std::string& _internal_vpc_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpc_name_ref(const std::string& value);
  std::string* _internal_mutable_vpc_name_ref();
  public:

  // string route_table_name_ref = 2;
  void clear_route_table_name_ref();
  const std::string& route_table_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_table_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_table_name_ref();
  PROTOBUF_NODISCARD std::string* release_route_table_name_ref();
  void set_allocated_route_table_name_ref(std::string* route_table_name_ref);
  private:
  const std::string& _internal_route_table_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_table_name_ref(const std::string& value);
  std::string* _internal_mutable_route_table_name_ref();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpc_name_ref_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_table_name_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class OverlayNextHopIPInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo) */ {
 public:
  inline OverlayNextHopIPInfo() : OverlayNextHopIPInfo(nullptr) {}
  ~OverlayNextHopIPInfo() override;
  explicit constexpr OverlayNextHopIPInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverlayNextHopIPInfo(const OverlayNextHopIPInfo& from);
  OverlayNextHopIPInfo(OverlayNextHopIPInfo&& from) noexcept
    : OverlayNextHopIPInfo() {
    *this = ::std::move(from);
  }

  inline OverlayNextHopIPInfo& operator=(const OverlayNextHopIPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverlayNextHopIPInfo& operator=(OverlayNextHopIPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverlayNextHopIPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverlayNextHopIPInfo* internal_default_instance() {
    return reinterpret_cast<const OverlayNextHopIPInfo*>(
               &_OverlayNextHopIPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OverlayNextHopIPInfo& a, OverlayNextHopIPInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OverlayNextHopIPInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverlayNextHopIPInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverlayNextHopIPInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverlayNextHopIPInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverlayNextHopIPInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OverlayNextHopIPInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverlayNextHopIPInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo";
  }
  protected:
  explicit OverlayNextHopIPInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNexthopIpFieldNumber = 1,
    kNexthopMacFieldNumber = 2,
    kVpcNameRefFieldNumber = 3,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.IPAddress nexthop_ip = 1;
  int nexthop_ip_size() const;
  private:
  int _internal_nexthop_ip_size() const;
  public:
  void clear_nexthop_ip();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_nexthop_ip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >*
      mutable_nexthop_ip();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_nexthop_ip(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_add_nexthop_ip();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& nexthop_ip(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* add_nexthop_ip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >&
      nexthop_ip() const;

  // repeated bytes nexthop_mac = 2;
  int nexthop_mac_size() const;
  private:
  int _internal_nexthop_mac_size() const;
  public:
  void clear_nexthop_mac();
  const std::string& nexthop_mac(int index) const;
  std::string* mutable_nexthop_mac(int index);
  void set_nexthop_mac(int index, const std::string& value);
  void set_nexthop_mac(int index, std::string&& value);
  void set_nexthop_mac(int index, const char* value);
  void set_nexthop_mac(int index, const void* value, size_t size);
  std::string* add_nexthop_mac();
  void add_nexthop_mac(const std::string& value);
  void add_nexthop_mac(std::string&& value);
  void add_nexthop_mac(const char* value);
  void add_nexthop_mac(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nexthop_mac() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nexthop_mac();
  private:
  const std::string& _internal_nexthop_mac(int index) const;
  std::string* _internal_add_nexthop_mac();
  public:

  // string vpc_name_ref = 3;
  void clear_vpc_name_ref();
  const std::string& vpc_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpc_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpc_name_ref();
  PROTOBUF_NODISCARD std::string* release_vpc_name_ref();
  void set_allocated_vpc_name_ref(std::string* vpc_name_ref);
  private:
  const std::string& _internal_vpc_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpc_name_ref(const std::string& value);
  std::string* _internal_mutable_vpc_name_ref();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress > nexthop_ip_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nexthop_mac_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpc_name_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteId) */ {
 public:
  inline RouteId() : RouteId(nullptr) {}
  ~RouteId() override;
  explicit constexpr RouteId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteId(const RouteId& from);
  RouteId(RouteId&& from) noexcept
    : RouteId() {
    *this = ::std::move(from);
  }

  inline RouteId& operator=(const RouteId& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteId& operator=(RouteId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteId& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteId* internal_default_instance() {
    return reinterpret_cast<const RouteId*>(
               &_RouteId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RouteId& a, RouteId& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteId";
  }
  protected:
  explicit RouteId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteIdFieldNumber = 1,
    kRouteTableNameRefFieldNumber = 2,
  };
  // string route_id = 1;
  void clear_route_id();
  const std::string& route_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* route_id);
  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(const std::string& value);
  std::string* _internal_mutable_route_id();
  public:

  // string route_table_name_ref = 2;
  void clear_route_table_name_ref();
  const std::string& route_table_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_table_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_table_name_ref();
  PROTOBUF_NODISCARD std::string* release_route_table_name_ref();
  void set_allocated_route_table_name_ref(std::string* route_table_name_ref);
  private:
  const std::string& _internal_route_table_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_table_name_ref(const std::string& value);
  std::string* _internal_mutable_route_table_name_ref();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_table_name_ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class Route final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.Route) */ {
 public:
  inline Route() : Route(nullptr) {}
  ~Route() override;
  explicit constexpr Route(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Route(const Route& from);
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline Route& operator=(Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }
  inline void Swap(Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Route* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Route>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Route& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Route& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Route* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.Route";
  }
  protected:
  explicit Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.network.cloud.v1alpha1.RouteSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::RouteSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::RouteSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::RouteSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::RouteSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::RouteSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::RouteSpec* spec);
  ::opi_api::network::cloud::v1alpha1::RouteSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.RouteStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::RouteStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::RouteStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::RouteStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::RouteStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::RouteStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::RouteStatus* status);
  ::opi_api::network::cloud::v1alpha1::RouteStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.Route)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::opi_api::network::cloud::v1alpha1::RouteSpec* spec_;
  ::opi_api::network::cloud::v1alpha1::RouteStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteSpec) */ {
 public:
  inline RouteSpec() : RouteSpec(nullptr) {}
  ~RouteSpec() override;
  explicit constexpr RouteSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteSpec(const RouteSpec& from);
  RouteSpec(RouteSpec&& from) noexcept
    : RouteSpec() {
    *this = ::std::move(from);
  }

  inline RouteSpec& operator=(const RouteSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteSpec& operator=(RouteSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteSpec* internal_default_instance() {
    return reinterpret_cast<const RouteSpec*>(
               &_RouteSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RouteSpec& a, RouteSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteSpec";
  }
  protected:
  explicit RouteSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteTableNameRefFieldNumber = 1,
    kAttrsFieldNumber = 2,
  };
  // string route_table_name_ref = 1;
  void clear_route_table_name_ref();
  const std::string& route_table_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_route_table_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_route_table_name_ref();
  PROTOBUF_NODISCARD std::string* release_route_table_name_ref();
  void set_allocated_route_table_name_ref(std::string* route_table_name_ref);
  private:
  const std::string& _internal_route_table_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_table_name_ref(const std::string& value);
  std::string* _internal_mutable_route_table_name_ref();
  public:

  // .opi_api.network.cloud.v1alpha1.RouteAttrs attrs = 2;
  bool has_attrs() const;
  private:
  bool _internal_has_attrs() const;
  public:
  void clear_attrs();
  const ::opi_api::network::cloud::v1alpha1::RouteAttrs& attrs() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::RouteAttrs* release_attrs();
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* mutable_attrs();
  void set_allocated_attrs(::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs);
  private:
  const ::opi_api::network::cloud::v1alpha1::RouteAttrs& _internal_attrs() const;
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* _internal_mutable_attrs();
  public:
  void unsafe_arena_set_allocated_attrs(
      ::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs);
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* unsafe_arena_release_attrs();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr route_table_name_ref_;
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// -------------------------------------------------------------------

class RouteStatus final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.RouteStatus) */ {
 public:
  inline RouteStatus() : RouteStatus(nullptr) {}
  explicit constexpr RouteStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteStatus(const RouteStatus& from);
  RouteStatus(RouteStatus&& from) noexcept
    : RouteStatus() {
    *this = ::std::move(from);
  }

  inline RouteStatus& operator=(const RouteStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteStatus& operator=(RouteStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteStatus* internal_default_instance() {
    return reinterpret_cast<const RouteStatus*>(
               &_RouteStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RouteStatus& a, RouteStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RouteStatus& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RouteStatus& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.RouteStatus";
  }
  protected:
  explicit RouteStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.RouteStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_route_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouteTable

// string name = 1;
inline void RouteTable::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RouteTable::name() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteTable::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTable.name)
}
inline std::string* RouteTable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteTable.name)
  return _s;
}
inline const std::string& RouteTable::_internal_name() const {
  return name_.Get();
}
inline void RouteTable::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteTable::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteTable::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteTable.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteTable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteTable.name)
}

// .opi_api.network.cloud.v1alpha1.RouteTableSpec spec = 2;
inline bool RouteTable::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool RouteTable::has_spec() const {
  return _internal_has_spec();
}
inline void RouteTable::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteTableSpec& RouteTable::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::RouteTableSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::RouteTableSpec&>(
      ::opi_api::network::cloud::v1alpha1::_RouteTableSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteTableSpec& RouteTable::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTable.spec)
  return _internal_spec();
}
inline void RouteTable::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::RouteTableSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteTable.spec)
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableSpec* RouteTable::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableSpec* RouteTable::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteTable.spec)
  
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableSpec* RouteTable::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteTableSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableSpec* RouteTable::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::RouteTableSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteTable.spec)
  return _msg;
}
inline void RouteTable::set_allocated_spec(::opi_api::network::cloud::v1alpha1::RouteTableSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::RouteTableSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteTable.spec)
}

// .opi_api.network.cloud.v1alpha1.RouteTableStatus status = 3;
inline bool RouteTable::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool RouteTable::has_status() const {
  return _internal_has_status();
}
inline void RouteTable::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteTableStatus& RouteTable::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::RouteTableStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::RouteTableStatus&>(
      ::opi_api::network::cloud::v1alpha1::_RouteTableStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteTableStatus& RouteTable::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTable.status)
  return _internal_status();
}
inline void RouteTable::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::RouteTableStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteTable.status)
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableStatus* RouteTable::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableStatus* RouteTable::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteTable.status)
  
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableStatus* RouteTable::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteTableStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::network::cloud::v1alpha1::RouteTableStatus* RouteTable::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::RouteTableStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteTable.status)
  return _msg;
}
inline void RouteTable::set_allocated_status(::opi_api::network::cloud::v1alpha1::RouteTableStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::RouteTableStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteTable.status)
}

// -------------------------------------------------------------------

// RouteTableSpec

// .opi_api.network.opinetcommon.v1alpha1.IpAf af = 1;
inline void RouteTableSpec::clear_af() {
  af_ = 0;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IpAf RouteTableSpec::_internal_af() const {
  return static_cast< ::opi_api::network::opinetcommon::v1alpha1::IpAf >(af_);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IpAf RouteTableSpec::af() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableSpec.af)
  return _internal_af();
}
inline void RouteTableSpec::_internal_set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value) {
  
  af_ = value;
}
inline void RouteTableSpec::set_af(::opi_api::network::opinetcommon::v1alpha1::IpAf value) {
  _internal_set_af(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableSpec.af)
}

// bool priority_enable = 2;
inline void RouteTableSpec::clear_priority_enable() {
  priority_enable_ = false;
}
inline bool RouteTableSpec::_internal_priority_enable() const {
  return priority_enable_;
}
inline bool RouteTableSpec::priority_enable() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableSpec.priority_enable)
  return _internal_priority_enable();
}
inline void RouteTableSpec::_internal_set_priority_enable(bool value) {
  
  priority_enable_ = value;
}
inline void RouteTableSpec::set_priority_enable(bool value) {
  _internal_set_priority_enable(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableSpec.priority_enable)
}

// repeated .opi_api.network.cloud.v1alpha1.RouteInfo routes = 3;
inline int RouteTableSpec::_internal_routes_size() const {
  return routes_.size();
}
inline int RouteTableSpec::routes_size() const {
  return _internal_routes_size();
}
inline void RouteTableSpec::clear_routes() {
  routes_.Clear();
}
inline ::opi_api::network::cloud::v1alpha1::RouteInfo* RouteTableSpec::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteTableSpec.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::RouteInfo >*
RouteTableSpec::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.RouteTableSpec.routes)
  return &routes_;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteInfo& RouteTableSpec::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteInfo& RouteTableSpec::routes(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableSpec.routes)
  return _internal_routes(index);
}
inline ::opi_api::network::cloud::v1alpha1::RouteInfo* RouteTableSpec::_internal_add_routes() {
  return routes_.Add();
}
inline ::opi_api::network::cloud::v1alpha1::RouteInfo* RouteTableSpec::add_routes() {
  ::opi_api::network::cloud::v1alpha1::RouteInfo* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.RouteTableSpec.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::cloud::v1alpha1::RouteInfo >&
RouteTableSpec::routes() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.RouteTableSpec.routes)
  return routes_;
}

// -------------------------------------------------------------------

// RouteInfo

// string route_id = 1;
inline void RouteInfo::clear_route_id() {
  route_id_.ClearToEmpty();
}
inline const std::string& RouteInfo::route_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteInfo.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteInfo::set_route_id(ArgT0&& arg0, ArgT... args) {
 
 route_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteInfo.route_id)
}
inline std::string* RouteInfo::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteInfo.route_id)
  return _s;
}
inline const std::string& RouteInfo::_internal_route_id() const {
  return route_id_.Get();
}
inline void RouteInfo::_internal_set_route_id(const std::string& value) {
  
  route_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteInfo::_internal_mutable_route_id() {
  
  return route_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteInfo::release_route_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteInfo.route_id)
  return route_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteInfo::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    
  } else {
    
  }
  route_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), route_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    route_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteInfo.route_id)
}

// .opi_api.network.cloud.v1alpha1.RouteAttrs attrs = 2;
inline bool RouteInfo::_internal_has_attrs() const {
  return this != internal_default_instance() && attrs_ != nullptr;
}
inline bool RouteInfo::has_attrs() const {
  return _internal_has_attrs();
}
inline void RouteInfo::clear_attrs() {
  if (GetArenaForAllocation() == nullptr && attrs_ != nullptr) {
    delete attrs_;
  }
  attrs_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteAttrs& RouteInfo::_internal_attrs() const {
  const ::opi_api::network::cloud::v1alpha1::RouteAttrs* p = attrs_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::RouteAttrs&>(
      ::opi_api::network::cloud::v1alpha1::_RouteAttrs_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteAttrs& RouteInfo::attrs() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteInfo.attrs)
  return _internal_attrs();
}
inline void RouteInfo::unsafe_arena_set_allocated_attrs(
    ::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attrs_);
  }
  attrs_ = attrs;
  if (attrs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteInfo.attrs)
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteInfo::release_attrs() {
  
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* temp = attrs_;
  attrs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteInfo::unsafe_arena_release_attrs() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteInfo.attrs)
  
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* temp = attrs_;
  attrs_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteInfo::_internal_mutable_attrs() {
  
  if (attrs_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteAttrs>(GetArenaForAllocation());
    attrs_ = p;
  }
  return attrs_;
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteInfo::mutable_attrs() {
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* _msg = _internal_mutable_attrs();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteInfo.attrs)
  return _msg;
}
inline void RouteInfo::set_allocated_attrs(::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attrs_;
  }
  if (attrs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::RouteAttrs>::GetOwningArena(attrs);
    if (message_arena != submessage_arena) {
      attrs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attrs, submessage_arena);
    }
    
  } else {
    
  }
  attrs_ = attrs;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteInfo.attrs)
}

// -------------------------------------------------------------------

// RouteTableStatus

// int32 vpc_count = 1;
inline void RouteTableStatus::clear_vpc_count() {
  vpc_count_ = 0;
}
inline int32_t RouteTableStatus::_internal_vpc_count() const {
  return vpc_count_;
}
inline int32_t RouteTableStatus::vpc_count() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.vpc_count)
  return _internal_vpc_count();
}
inline void RouteTableStatus::_internal_set_vpc_count(int32_t value) {
  
  vpc_count_ = value;
}
inline void RouteTableStatus::set_vpc_count(int32_t value) {
  _internal_set_vpc_count(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.vpc_count)
}

// int32 subnet_count = 2;
inline void RouteTableStatus::clear_subnet_count() {
  subnet_count_ = 0;
}
inline int32_t RouteTableStatus::_internal_subnet_count() const {
  return subnet_count_;
}
inline int32_t RouteTableStatus::subnet_count() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.subnet_count)
  return _internal_subnet_count();
}
inline void RouteTableStatus::_internal_set_subnet_count(int32_t value) {
  
  subnet_count_ = value;
}
inline void RouteTableStatus::set_subnet_count(int32_t value) {
  _internal_set_subnet_count(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.subnet_count)
}

// int32 vnic_count = 3;
inline void RouteTableStatus::clear_vnic_count() {
  vnic_count_ = 0;
}
inline int32_t RouteTableStatus::_internal_vnic_count() const {
  return vnic_count_;
}
inline int32_t RouteTableStatus::vnic_count() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.vnic_count)
  return _internal_vnic_count();
}
inline void RouteTableStatus::_internal_set_vnic_count(int32_t value) {
  
  vnic_count_ = value;
}
inline void RouteTableStatus::set_vnic_count(int32_t value) {
  _internal_set_vnic_count(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.vnic_count)
}

// int32 pool_id = 4;
inline void RouteTableStatus::clear_pool_id() {
  pool_id_ = 0;
}
inline int32_t RouteTableStatus::_internal_pool_id() const {
  return pool_id_;
}
inline int32_t RouteTableStatus::pool_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.pool_id)
  return _internal_pool_id();
}
inline void RouteTableStatus::_internal_set_pool_id(int32_t value) {
  
  pool_id_ = value;
}
inline void RouteTableStatus::set_pool_id(int32_t value) {
  _internal_set_pool_id(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.pool_id)
}

// int32 hw_idx = 5;
inline void RouteTableStatus::clear_hw_idx() {
  hw_idx_ = 0;
}
inline int32_t RouteTableStatus::_internal_hw_idx() const {
  return hw_idx_;
}
inline int32_t RouteTableStatus::hw_idx() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.hw_idx)
  return _internal_hw_idx();
}
inline void RouteTableStatus::_internal_set_hw_idx(int32_t value) {
  
  hw_idx_ = value;
}
inline void RouteTableStatus::set_hw_idx(int32_t value) {
  _internal_set_hw_idx(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.hw_idx)
}

// uint64 route_table_base_address = 6;
inline void RouteTableStatus::clear_route_table_base_address() {
  route_table_base_address_ = uint64_t{0u};
}
inline uint64_t RouteTableStatus::_internal_route_table_base_address() const {
  return route_table_base_address_;
}
inline uint64_t RouteTableStatus::route_table_base_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.route_table_base_address)
  return _internal_route_table_base_address();
}
inline void RouteTableStatus::_internal_set_route_table_base_address(uint64_t value) {
  
  route_table_base_address_ = value;
}
inline void RouteTableStatus::set_route_table_base_address(uint64_t value) {
  _internal_set_route_table_base_address(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.route_table_base_address)
}

// int32 hw_lpm_block_idx = 7;
inline void RouteTableStatus::clear_hw_lpm_block_idx() {
  hw_lpm_block_idx_ = 0;
}
inline int32_t RouteTableStatus::_internal_hw_lpm_block_idx() const {
  return hw_lpm_block_idx_;
}
inline int32_t RouteTableStatus::hw_lpm_block_idx() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.hw_lpm_block_idx)
  return _internal_hw_lpm_block_idx();
}
inline void RouteTableStatus::_internal_set_hw_lpm_block_idx(int32_t value) {
  
  hw_lpm_block_idx_ = value;
}
inline void RouteTableStatus::set_hw_lpm_block_idx(int32_t value) {
  _internal_set_hw_lpm_block_idx(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.hw_lpm_block_idx)
}

// int32 hw_lpm_rewrite_block_idx = 8;
inline void RouteTableStatus::clear_hw_lpm_rewrite_block_idx() {
  hw_lpm_rewrite_block_idx_ = 0;
}
inline int32_t RouteTableStatus::_internal_hw_lpm_rewrite_block_idx() const {
  return hw_lpm_rewrite_block_idx_;
}
inline int32_t RouteTableStatus::hw_lpm_rewrite_block_idx() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteTableStatus.hw_lpm_rewrite_block_idx)
  return _internal_hw_lpm_rewrite_block_idx();
}
inline void RouteTableStatus::_internal_set_hw_lpm_rewrite_block_idx(int32_t value) {
  
  hw_lpm_rewrite_block_idx_ = value;
}
inline void RouteTableStatus::set_hw_lpm_rewrite_block_idx(int32_t value) {
  _internal_set_hw_lpm_rewrite_block_idx(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteTableStatus.hw_lpm_rewrite_block_idx)
}

// -------------------------------------------------------------------

// RouteAttrs

// .opi_api.network.opinetcommon.v1alpha1.IPPrefix prefix = 1;
inline bool RouteAttrs::_internal_has_prefix() const {
  return this != internal_default_instance() && prefix_ != nullptr;
}
inline bool RouteAttrs::has_prefix() const {
  return _internal_has_prefix();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& RouteAttrs::_internal_prefix() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* p = prefix_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPPrefix_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPPrefix& RouteAttrs::prefix() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.prefix)
  return _internal_prefix();
}
inline void RouteAttrs::unsafe_arena_set_allocated_prefix(
    ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  prefix_ = prefix;
  if (prefix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.prefix)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RouteAttrs::release_prefix() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = prefix_;
  prefix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RouteAttrs::unsafe_arena_release_prefix() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.prefix)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* temp = prefix_;
  prefix_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RouteAttrs::_internal_mutable_prefix() {
  
  if (prefix_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPPrefix>(GetArenaForAllocation());
    prefix_ = p;
  }
  return prefix_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* RouteAttrs::mutable_prefix() {
  ::opi_api::network::opinetcommon::v1alpha1::IPPrefix* _msg = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.prefix)
  return _msg;
}
inline void RouteAttrs::set_allocated_prefix(::opi_api::network::opinetcommon::v1alpha1::IPPrefix* prefix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix_);
  }
  if (prefix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prefix));
    if (message_arena != submessage_arena) {
      prefix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prefix, submessage_arena);
    }
    
  } else {
    
  }
  prefix_ = prefix;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.prefix)
}

// .opi_api.network.cloud.v1alpha1.RouteClass route_class = 2;
inline void RouteAttrs::clear_route_class() {
  route_class_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::RouteClass RouteAttrs::_internal_route_class() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::RouteClass >(route_class_);
}
inline ::opi_api::network::cloud::v1alpha1::RouteClass RouteAttrs::route_class() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.route_class)
  return _internal_route_class();
}
inline void RouteAttrs::_internal_set_route_class(::opi_api::network::cloud::v1alpha1::RouteClass value) {
  
  route_class_ = value;
}
inline void RouteAttrs::set_route_class(::opi_api::network::cloud::v1alpha1::RouteClass value) {
  _internal_set_route_class(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.route_class)
}

// int32 class_priority = 3;
inline void RouteAttrs::clear_class_priority() {
  class_priority_ = 0;
}
inline int32_t RouteAttrs::_internal_class_priority() const {
  return class_priority_;
}
inline int32_t RouteAttrs::class_priority() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.class_priority)
  return _internal_class_priority();
}
inline void RouteAttrs::_internal_set_class_priority(int32_t value) {
  
  class_priority_ = value;
}
inline void RouteAttrs::set_class_priority(int32_t value) {
  _internal_set_class_priority(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.class_priority)
}

// int32 priority = 4;
inline void RouteAttrs::clear_priority() {
  priority_ = 0;
}
inline int32_t RouteAttrs::_internal_priority() const {
  return priority_;
}
inline int32_t RouteAttrs::priority() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.priority)
  return _internal_priority();
}
inline void RouteAttrs::_internal_set_priority(int32_t value) {
  
  priority_ = value;
}
inline void RouteAttrs::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.priority)
}

// .opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo overlay_nh_ip_info = 5;
inline bool RouteAttrs::_internal_has_overlay_nh_ip_info() const {
  return nh_case() == kOverlayNhIpInfo;
}
inline bool RouteAttrs::has_overlay_nh_ip_info() const {
  return _internal_has_overlay_nh_ip_info();
}
inline void RouteAttrs::set_has_overlay_nh_ip_info() {
  _oneof_case_[0] = kOverlayNhIpInfo;
}
inline void RouteAttrs::clear_overlay_nh_ip_info() {
  if (_internal_has_overlay_nh_ip_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nh_.overlay_nh_ip_info_;
    }
    clear_has_nh();
  }
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* RouteAttrs::release_overlay_nh_ip_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_nh_ip_info)
  if (_internal_has_overlay_nh_ip_info()) {
    clear_has_nh();
      ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* temp = nh_.overlay_nh_ip_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nh_.overlay_nh_ip_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo& RouteAttrs::_internal_overlay_nh_ip_info() const {
  return _internal_has_overlay_nh_ip_info()
      ? *nh_.overlay_nh_ip_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo&>(::opi_api::network::cloud::v1alpha1::_OverlayNextHopIPInfo_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo& RouteAttrs::overlay_nh_ip_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_nh_ip_info)
  return _internal_overlay_nh_ip_info();
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* RouteAttrs::unsafe_arena_release_overlay_nh_ip_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_nh_ip_info)
  if (_internal_has_overlay_nh_ip_info()) {
    clear_has_nh();
    ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* temp = nh_.overlay_nh_ip_info_;
    nh_.overlay_nh_ip_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouteAttrs::unsafe_arena_set_allocated_overlay_nh_ip_info(::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* overlay_nh_ip_info) {
  clear_nh();
  if (overlay_nh_ip_info) {
    set_has_overlay_nh_ip_info();
    nh_.overlay_nh_ip_info_ = overlay_nh_ip_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_nh_ip_info)
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* RouteAttrs::_internal_mutable_overlay_nh_ip_info() {
  if (!_internal_has_overlay_nh_ip_info()) {
    clear_nh();
    set_has_overlay_nh_ip_info();
    nh_.overlay_nh_ip_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo >(GetArenaForAllocation());
  }
  return nh_.overlay_nh_ip_info_;
}
inline ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* RouteAttrs::mutable_overlay_nh_ip_info() {
  ::opi_api::network::cloud::v1alpha1::OverlayNextHopIPInfo* _msg = _internal_mutable_overlay_nh_ip_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_nh_ip_info)
  return _msg;
}

// string nexthop_name_ref = 6;
inline bool RouteAttrs::_internal_has_nexthop_name_ref() const {
  return nh_case() == kNexthopNameRef;
}
inline bool RouteAttrs::has_nexthop_name_ref() const {
  return _internal_has_nexthop_name_ref();
}
inline void RouteAttrs::set_has_nexthop_name_ref() {
  _oneof_case_[0] = kNexthopNameRef;
}
inline void RouteAttrs::clear_nexthop_name_ref() {
  if (_internal_has_nexthop_name_ref()) {
    nh_.nexthop_name_ref_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_nh();
  }
}
inline const std::string& RouteAttrs::nexthop_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.nexthop_name_ref)
  return _internal_nexthop_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void RouteAttrs::set_nexthop_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nexthop_name_ref()) {
    clear_nh();
    set_has_nexthop_name_ref();
    nh_.nexthop_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.nexthop_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.nexthop_name_ref)
}
inline std::string* RouteAttrs::mutable_nexthop_name_ref() {
  std::string* _s = _internal_mutable_nexthop_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.nexthop_name_ref)
  return _s;
}
inline const std::string& RouteAttrs::_internal_nexthop_name_ref() const {
  if (_internal_has_nexthop_name_ref()) {
    return nh_.nexthop_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAttrs::_internal_set_nexthop_name_ref(const std::string& value) {
  if (!_internal_has_nexthop_name_ref()) {
    clear_nh();
    set_has_nexthop_name_ref();
    nh_.nexthop_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.nexthop_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteAttrs::_internal_mutable_nexthop_name_ref() {
  if (!_internal_has_nexthop_name_ref()) {
    clear_nh();
    set_has_nexthop_name_ref();
    nh_.nexthop_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return nh_.nexthop_name_ref_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteAttrs::release_nexthop_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.nexthop_name_ref)
  if (_internal_has_nexthop_name_ref()) {
    clear_has_nh();
    return nh_.nexthop_name_ref_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void RouteAttrs::set_allocated_nexthop_name_ref(std::string* nexthop_name_ref) {
  if (has_nh()) {
    clear_nh();
  }
  if (nexthop_name_ref != nullptr) {
    set_has_nexthop_name_ref();
    nh_.nexthop_name_ref_.UnsafeSetDefault(nexthop_name_ref);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(nexthop_name_ref);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.nexthop_name_ref)
}

// string nh_group_name_ref = 7;
inline bool RouteAttrs::_internal_has_nh_group_name_ref() const {
  return nh_case() == kNhGroupNameRef;
}
inline bool RouteAttrs::has_nh_group_name_ref() const {
  return _internal_has_nh_group_name_ref();
}
inline void RouteAttrs::set_has_nh_group_name_ref() {
  _oneof_case_[0] = kNhGroupNameRef;
}
inline void RouteAttrs::clear_nh_group_name_ref() {
  if (_internal_has_nh_group_name_ref()) {
    nh_.nh_group_name_ref_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_nh();
  }
}
inline const std::string& RouteAttrs::nh_group_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.nh_group_name_ref)
  return _internal_nh_group_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void RouteAttrs::set_nh_group_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nh_group_name_ref()) {
    clear_nh();
    set_has_nh_group_name_ref();
    nh_.nh_group_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.nh_group_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.nh_group_name_ref)
}
inline std::string* RouteAttrs::mutable_nh_group_name_ref() {
  std::string* _s = _internal_mutable_nh_group_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.nh_group_name_ref)
  return _s;
}
inline const std::string& RouteAttrs::_internal_nh_group_name_ref() const {
  if (_internal_has_nh_group_name_ref()) {
    return nh_.nh_group_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAttrs::_internal_set_nh_group_name_ref(const std::string& value) {
  if (!_internal_has_nh_group_name_ref()) {
    clear_nh();
    set_has_nh_group_name_ref();
    nh_.nh_group_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.nh_group_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteAttrs::_internal_mutable_nh_group_name_ref() {
  if (!_internal_has_nh_group_name_ref()) {
    clear_nh();
    set_has_nh_group_name_ref();
    nh_.nh_group_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return nh_.nh_group_name_ref_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteAttrs::release_nh_group_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.nh_group_name_ref)
  if (_internal_has_nh_group_name_ref()) {
    clear_has_nh();
    return nh_.nh_group_name_ref_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void RouteAttrs::set_allocated_nh_group_name_ref(std::string* nh_group_name_ref) {
  if (has_nh()) {
    clear_nh();
  }
  if (nh_group_name_ref != nullptr) {
    set_has_nh_group_name_ref();
    nh_.nh_group_name_ref_.UnsafeSetDefault(nh_group_name_ref);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(nh_group_name_ref);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.nh_group_name_ref)
}

// .opi_api.network.cloud.v1alpha1.VPCPeerNhInfo vpc_nh_info = 8;
inline bool RouteAttrs::_internal_has_vpc_nh_info() const {
  return nh_case() == kVpcNhInfo;
}
inline bool RouteAttrs::has_vpc_nh_info() const {
  return _internal_has_vpc_nh_info();
}
inline void RouteAttrs::set_has_vpc_nh_info() {
  _oneof_case_[0] = kVpcNhInfo;
}
inline void RouteAttrs::clear_vpc_nh_info() {
  if (_internal_has_vpc_nh_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete nh_.vpc_nh_info_;
    }
    clear_has_nh();
  }
}
inline ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* RouteAttrs::release_vpc_nh_info() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.vpc_nh_info)
  if (_internal_has_vpc_nh_info()) {
    clear_has_nh();
      ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* temp = nh_.vpc_nh_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    nh_.vpc_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo& RouteAttrs::_internal_vpc_nh_info() const {
  return _internal_has_vpc_nh_info()
      ? *nh_.vpc_nh_info_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo&>(::opi_api::network::cloud::v1alpha1::_VPCPeerNhInfo_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo& RouteAttrs::vpc_nh_info() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.vpc_nh_info)
  return _internal_vpc_nh_info();
}
inline ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* RouteAttrs::unsafe_arena_release_vpc_nh_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.RouteAttrs.vpc_nh_info)
  if (_internal_has_vpc_nh_info()) {
    clear_has_nh();
    ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* temp = nh_.vpc_nh_info_;
    nh_.vpc_nh_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RouteAttrs::unsafe_arena_set_allocated_vpc_nh_info(::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* vpc_nh_info) {
  clear_nh();
  if (vpc_nh_info) {
    set_has_vpc_nh_info();
    nh_.vpc_nh_info_ = vpc_nh_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.vpc_nh_info)
}
inline ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* RouteAttrs::_internal_mutable_vpc_nh_info() {
  if (!_internal_has_vpc_nh_info()) {
    clear_nh();
    set_has_vpc_nh_info();
    nh_.vpc_nh_info_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo >(GetArenaForAllocation());
  }
  return nh_.vpc_nh_info_;
}
inline ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* RouteAttrs::mutable_vpc_nh_info() {
  ::opi_api::network::cloud::v1alpha1::VPCPeerNhInfo* _msg = _internal_mutable_vpc_nh_info();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.vpc_nh_info)
  return _msg;
}

// string tunnel_name_ref = 9;
inline bool RouteAttrs::_internal_has_tunnel_name_ref() const {
  return nh_case() == kTunnelNameRef;
}
inline bool RouteAttrs::has_tunnel_name_ref() const {
  return _internal_has_tunnel_name_ref();
}
inline void RouteAttrs::set_has_tunnel_name_ref() {
  _oneof_case_[0] = kTunnelNameRef;
}
inline void RouteAttrs::clear_tunnel_name_ref() {
  if (_internal_has_tunnel_name_ref()) {
    nh_.tunnel_name_ref_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_nh();
  }
}
inline const std::string& RouteAttrs::tunnel_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.tunnel_name_ref)
  return _internal_tunnel_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void RouteAttrs::set_tunnel_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tunnel_name_ref()) {
    clear_nh();
    set_has_tunnel_name_ref();
    nh_.tunnel_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.tunnel_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.tunnel_name_ref)
}
inline std::string* RouteAttrs::mutable_tunnel_name_ref() {
  std::string* _s = _internal_mutable_tunnel_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.tunnel_name_ref)
  return _s;
}
inline const std::string& RouteAttrs::_internal_tunnel_name_ref() const {
  if (_internal_has_tunnel_name_ref()) {
    return nh_.tunnel_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAttrs::_internal_set_tunnel_name_ref(const std::string& value) {
  if (!_internal_has_tunnel_name_ref()) {
    clear_nh();
    set_has_tunnel_name_ref();
    nh_.tunnel_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.tunnel_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteAttrs::_internal_mutable_tunnel_name_ref() {
  if (!_internal_has_tunnel_name_ref()) {
    clear_nh();
    set_has_tunnel_name_ref();
    nh_.tunnel_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return nh_.tunnel_name_ref_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteAttrs::release_tunnel_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.tunnel_name_ref)
  if (_internal_has_tunnel_name_ref()) {
    clear_has_nh();
    return nh_.tunnel_name_ref_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void RouteAttrs::set_allocated_tunnel_name_ref(std::string* tunnel_name_ref) {
  if (has_nh()) {
    clear_nh();
  }
  if (tunnel_name_ref != nullptr) {
    set_has_tunnel_name_ref();
    nh_.tunnel_name_ref_.UnsafeSetDefault(tunnel_name_ref);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(tunnel_name_ref);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.tunnel_name_ref)
}

// string route_table_name_ref = 10;
inline bool RouteAttrs::_internal_has_route_table_name_ref() const {
  return nh_case() == kRouteTableNameRef;
}
inline bool RouteAttrs::has_route_table_name_ref() const {
  return _internal_has_route_table_name_ref();
}
inline void RouteAttrs::set_has_route_table_name_ref() {
  _oneof_case_[0] = kRouteTableNameRef;
}
inline void RouteAttrs::clear_route_table_name_ref() {
  if (_internal_has_route_table_name_ref()) {
    nh_.route_table_name_ref_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_nh();
  }
}
inline const std::string& RouteAttrs::route_table_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.route_table_name_ref)
  return _internal_route_table_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void RouteAttrs::set_route_table_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_route_table_name_ref()) {
    clear_nh();
    set_has_route_table_name_ref();
    nh_.route_table_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.route_table_name_ref)
}
inline std::string* RouteAttrs::mutable_route_table_name_ref() {
  std::string* _s = _internal_mutable_route_table_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.route_table_name_ref)
  return _s;
}
inline const std::string& RouteAttrs::_internal_route_table_name_ref() const {
  if (_internal_has_route_table_name_ref()) {
    return nh_.route_table_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAttrs::_internal_set_route_table_name_ref(const std::string& value) {
  if (!_internal_has_route_table_name_ref()) {
    clear_nh();
    set_has_route_table_name_ref();
    nh_.route_table_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  nh_.route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteAttrs::_internal_mutable_route_table_name_ref() {
  if (!_internal_has_route_table_name_ref()) {
    clear_nh();
    set_has_route_table_name_ref();
    nh_.route_table_name_ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return nh_.route_table_name_ref_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteAttrs::release_route_table_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.route_table_name_ref)
  if (_internal_has_route_table_name_ref()) {
    clear_has_nh();
    return nh_.route_table_name_ref_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void RouteAttrs::set_allocated_route_table_name_ref(std::string* route_table_name_ref) {
  if (has_nh()) {
    clear_nh();
  }
  if (route_table_name_ref != nullptr) {
    set_has_route_table_name_ref();
    nh_.route_table_name_ref_.UnsafeSetDefault(route_table_name_ref);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(route_table_name_ref);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.route_table_name_ref)
}

// bool eval_mapping = 11;
inline bool RouteAttrs::_internal_has_eval_mapping() const {
  return nh_case() == kEvalMapping;
}
inline bool RouteAttrs::has_eval_mapping() const {
  return _internal_has_eval_mapping();
}
inline void RouteAttrs::set_has_eval_mapping() {
  _oneof_case_[0] = kEvalMapping;
}
inline void RouteAttrs::clear_eval_mapping() {
  if (_internal_has_eval_mapping()) {
    nh_.eval_mapping_ = false;
    clear_has_nh();
  }
}
inline bool RouteAttrs::_internal_eval_mapping() const {
  if (_internal_has_eval_mapping()) {
    return nh_.eval_mapping_;
  }
  return false;
}
inline void RouteAttrs::_internal_set_eval_mapping(bool value) {
  if (!_internal_has_eval_mapping()) {
    clear_nh();
    set_has_eval_mapping();
  }
  nh_.eval_mapping_ = value;
}
inline bool RouteAttrs::eval_mapping() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.eval_mapping)
  return _internal_eval_mapping();
}
inline void RouteAttrs::set_eval_mapping(bool value) {
  _internal_set_eval_mapping(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.eval_mapping)
}

// int32 tos = 12;
inline void RouteAttrs::clear_tos() {
  tos_ = 0;
}
inline int32_t RouteAttrs::_internal_tos() const {
  return tos_;
}
inline int32_t RouteAttrs::tos() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.tos)
  return _internal_tos();
}
inline void RouteAttrs::_internal_set_tos(int32_t value) {
  
  tos_ = value;
}
inline void RouteAttrs::set_tos(int32_t value) {
  _internal_set_tos(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.tos)
}

// .opi_api.network.opinetcommon.v1alpha1.Encap encap = 13;
inline bool RouteAttrs::_internal_has_encap() const {
  return this != internal_default_instance() && encap_ != nullptr;
}
inline bool RouteAttrs::has_encap() const {
  return _internal_has_encap();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& RouteAttrs::_internal_encap() const {
  const ::opi_api::network::opinetcommon::v1alpha1::Encap* p = encap_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::Encap&>(
      ::opi_api::network::opinetcommon::v1alpha1::_Encap_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& RouteAttrs::encap() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.encap)
  return _internal_encap();
}
inline void RouteAttrs::unsafe_arena_set_allocated_encap(
    ::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap_);
  }
  encap_ = encap;
  if (encap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.encap)
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* RouteAttrs::release_encap() {
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = encap_;
  encap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* RouteAttrs::unsafe_arena_release_encap() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.encap)
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = encap_;
  encap_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* RouteAttrs::_internal_mutable_encap() {
  
  if (encap_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::Encap>(GetArenaForAllocation());
    encap_ = p;
  }
  return encap_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* RouteAttrs::mutable_encap() {
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _msg = _internal_mutable_encap();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.encap)
  return _msg;
}
inline void RouteAttrs::set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap_);
  }
  if (encap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap));
    if (message_arena != submessage_arena) {
      encap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encap, submessage_arena);
    }
    
  } else {
    
  }
  encap_ = encap;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.encap)
}

// bytes overlay_mac = 14;
inline void RouteAttrs::clear_overlay_mac() {
  overlay_mac_.ClearToEmpty();
}
inline const std::string& RouteAttrs::overlay_mac() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_mac)
  return _internal_overlay_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteAttrs::set_overlay_mac(ArgT0&& arg0, ArgT... args) {
 
 overlay_mac_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_mac)
}
inline std::string* RouteAttrs::mutable_overlay_mac() {
  std::string* _s = _internal_mutable_overlay_mac();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_mac)
  return _s;
}
inline const std::string& RouteAttrs::_internal_overlay_mac() const {
  return overlay_mac_.Get();
}
inline void RouteAttrs::_internal_set_overlay_mac(const std::string& value) {
  
  overlay_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteAttrs::_internal_mutable_overlay_mac() {
  
  return overlay_mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteAttrs::release_overlay_mac() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_mac)
  return overlay_mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteAttrs::set_allocated_overlay_mac(std::string* overlay_mac) {
  if (overlay_mac != nullptr) {
    
  } else {
    
  }
  overlay_mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), overlay_mac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (overlay_mac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    overlay_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteAttrs.overlay_mac)
}

inline bool RouteAttrs::has_nh() const {
  return nh_case() != NH_NOT_SET;
}
inline void RouteAttrs::clear_has_nh() {
  _oneof_case_[0] = NH_NOT_SET;
}
inline RouteAttrs::NhCase RouteAttrs::nh_case() const {
  return RouteAttrs::NhCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VPCPeerNhInfo

// string vpc_name_ref = 1;
inline void VPCPeerNhInfo::clear_vpc_name_ref() {
  vpc_name_ref_.ClearToEmpty();
}
inline const std::string& VPCPeerNhInfo::vpc_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.vpc_name_ref)
  return _internal_vpc_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VPCPeerNhInfo::set_vpc_name_ref(ArgT0&& arg0, ArgT... args) {
 
 vpc_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.vpc_name_ref)
}
inline std::string* VPCPeerNhInfo::mutable_vpc_name_ref() {
  std::string* _s = _internal_mutable_vpc_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.vpc_name_ref)
  return _s;
}
inline const std::string& VPCPeerNhInfo::_internal_vpc_name_ref() const {
  return vpc_name_ref_.Get();
}
inline void VPCPeerNhInfo::_internal_set_vpc_name_ref(const std::string& value) {
  
  vpc_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VPCPeerNhInfo::_internal_mutable_vpc_name_ref() {
  
  return vpc_name_ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VPCPeerNhInfo::release_vpc_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.vpc_name_ref)
  return vpc_name_ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VPCPeerNhInfo::set_allocated_vpc_name_ref(std::string* vpc_name_ref) {
  if (vpc_name_ref != nullptr) {
    
  } else {
    
  }
  vpc_name_ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vpc_name_ref,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vpc_name_ref_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vpc_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.vpc_name_ref)
}

// string route_table_name_ref = 2;
inline void VPCPeerNhInfo::clear_route_table_name_ref() {
  route_table_name_ref_.ClearToEmpty();
}
inline const std::string& VPCPeerNhInfo::route_table_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.route_table_name_ref)
  return _internal_route_table_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VPCPeerNhInfo::set_route_table_name_ref(ArgT0&& arg0, ArgT... args) {
 
 route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.route_table_name_ref)
}
inline std::string* VPCPeerNhInfo::mutable_route_table_name_ref() {
  std::string* _s = _internal_mutable_route_table_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.route_table_name_ref)
  return _s;
}
inline const std::string& VPCPeerNhInfo::_internal_route_table_name_ref() const {
  return route_table_name_ref_.Get();
}
inline void VPCPeerNhInfo::_internal_set_route_table_name_ref(const std::string& value) {
  
  route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VPCPeerNhInfo::_internal_mutable_route_table_name_ref() {
  
  return route_table_name_ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VPCPeerNhInfo::release_route_table_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.route_table_name_ref)
  return route_table_name_ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VPCPeerNhInfo::set_allocated_route_table_name_ref(std::string* route_table_name_ref) {
  if (route_table_name_ref != nullptr) {
    
  } else {
    
  }
  route_table_name_ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), route_table_name_ref,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_table_name_ref_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    route_table_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.VPCPeerNhInfo.route_table_name_ref)
}

// -------------------------------------------------------------------

// OverlayNextHopIPInfo

// repeated .opi_api.network.opinetcommon.v1alpha1.IPAddress nexthop_ip = 1;
inline int OverlayNextHopIPInfo::_internal_nexthop_ip_size() const {
  return nexthop_ip_.size();
}
inline int OverlayNextHopIPInfo::nexthop_ip_size() const {
  return _internal_nexthop_ip_size();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopIPInfo::mutable_nexthop_ip(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_ip)
  return nexthop_ip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >*
OverlayNextHopIPInfo::mutable_nexthop_ip() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_ip)
  return &nexthop_ip_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& OverlayNextHopIPInfo::_internal_nexthop_ip(int index) const {
  return nexthop_ip_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& OverlayNextHopIPInfo::nexthop_ip(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_ip)
  return _internal_nexthop_ip(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopIPInfo::_internal_add_nexthop_ip() {
  return nexthop_ip_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* OverlayNextHopIPInfo::add_nexthop_ip() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _add = _internal_add_nexthop_ip();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_ip)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >&
OverlayNextHopIPInfo::nexthop_ip() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_ip)
  return nexthop_ip_;
}

// repeated bytes nexthop_mac = 2;
inline int OverlayNextHopIPInfo::_internal_nexthop_mac_size() const {
  return nexthop_mac_.size();
}
inline int OverlayNextHopIPInfo::nexthop_mac_size() const {
  return _internal_nexthop_mac_size();
}
inline void OverlayNextHopIPInfo::clear_nexthop_mac() {
  nexthop_mac_.Clear();
}
inline std::string* OverlayNextHopIPInfo::add_nexthop_mac() {
  std::string* _s = _internal_add_nexthop_mac();
  // @@protoc_insertion_point(field_add_mutable:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
  return _s;
}
inline const std::string& OverlayNextHopIPInfo::_internal_nexthop_mac(int index) const {
  return nexthop_mac_.Get(index);
}
inline const std::string& OverlayNextHopIPInfo::nexthop_mac(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
  return _internal_nexthop_mac(index);
}
inline std::string* OverlayNextHopIPInfo::mutable_nexthop_mac(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
  return nexthop_mac_.Mutable(index);
}
inline void OverlayNextHopIPInfo::set_nexthop_mac(int index, const std::string& value) {
  nexthop_mac_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline void OverlayNextHopIPInfo::set_nexthop_mac(int index, std::string&& value) {
  nexthop_mac_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline void OverlayNextHopIPInfo::set_nexthop_mac(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_mac_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline void OverlayNextHopIPInfo::set_nexthop_mac(int index, const void* value, size_t size) {
  nexthop_mac_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline std::string* OverlayNextHopIPInfo::_internal_add_nexthop_mac() {
  return nexthop_mac_.Add();
}
inline void OverlayNextHopIPInfo::add_nexthop_mac(const std::string& value) {
  nexthop_mac_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline void OverlayNextHopIPInfo::add_nexthop_mac(std::string&& value) {
  nexthop_mac_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline void OverlayNextHopIPInfo::add_nexthop_mac(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nexthop_mac_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline void OverlayNextHopIPInfo::add_nexthop_mac(const void* value, size_t size) {
  nexthop_mac_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OverlayNextHopIPInfo::nexthop_mac() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
  return nexthop_mac_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OverlayNextHopIPInfo::mutable_nexthop_mac() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.nexthop_mac)
  return &nexthop_mac_;
}

// string vpc_name_ref = 3;
inline void OverlayNextHopIPInfo::clear_vpc_name_ref() {
  vpc_name_ref_.ClearToEmpty();
}
inline const std::string& OverlayNextHopIPInfo::vpc_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.vpc_name_ref)
  return _internal_vpc_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverlayNextHopIPInfo::set_vpc_name_ref(ArgT0&& arg0, ArgT... args) {
 
 vpc_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.vpc_name_ref)
}
inline std::string* OverlayNextHopIPInfo::mutable_vpc_name_ref() {
  std::string* _s = _internal_mutable_vpc_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.vpc_name_ref)
  return _s;
}
inline const std::string& OverlayNextHopIPInfo::_internal_vpc_name_ref() const {
  return vpc_name_ref_.Get();
}
inline void OverlayNextHopIPInfo::_internal_set_vpc_name_ref(const std::string& value) {
  
  vpc_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OverlayNextHopIPInfo::_internal_mutable_vpc_name_ref() {
  
  return vpc_name_ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OverlayNextHopIPInfo::release_vpc_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.vpc_name_ref)
  return vpc_name_ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OverlayNextHopIPInfo::set_allocated_vpc_name_ref(std::string* vpc_name_ref) {
  if (vpc_name_ref != nullptr) {
    
  } else {
    
  }
  vpc_name_ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vpc_name_ref,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vpc_name_ref_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vpc_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.OverlayNextHopIPInfo.vpc_name_ref)
}

// -------------------------------------------------------------------

// RouteId

// string route_id = 1;
inline void RouteId::clear_route_id() {
  route_id_.ClearToEmpty();
}
inline const std::string& RouteId::route_id() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteId.route_id)
  return _internal_route_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteId::set_route_id(ArgT0&& arg0, ArgT... args) {
 
 route_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteId.route_id)
}
inline std::string* RouteId::mutable_route_id() {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteId.route_id)
  return _s;
}
inline const std::string& RouteId::_internal_route_id() const {
  return route_id_.Get();
}
inline void RouteId::_internal_set_route_id(const std::string& value) {
  
  route_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteId::_internal_mutable_route_id() {
  
  return route_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteId::release_route_id() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteId.route_id)
  return route_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteId::set_allocated_route_id(std::string* route_id) {
  if (route_id != nullptr) {
    
  } else {
    
  }
  route_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), route_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    route_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteId.route_id)
}

// string route_table_name_ref = 2;
inline void RouteId::clear_route_table_name_ref() {
  route_table_name_ref_.ClearToEmpty();
}
inline const std::string& RouteId::route_table_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteId.route_table_name_ref)
  return _internal_route_table_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteId::set_route_table_name_ref(ArgT0&& arg0, ArgT... args) {
 
 route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteId.route_table_name_ref)
}
inline std::string* RouteId::mutable_route_table_name_ref() {
  std::string* _s = _internal_mutable_route_table_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteId.route_table_name_ref)
  return _s;
}
inline const std::string& RouteId::_internal_route_table_name_ref() const {
  return route_table_name_ref_.Get();
}
inline void RouteId::_internal_set_route_table_name_ref(const std::string& value) {
  
  route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteId::_internal_mutable_route_table_name_ref() {
  
  return route_table_name_ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteId::release_route_table_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteId.route_table_name_ref)
  return route_table_name_ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteId::set_allocated_route_table_name_ref(std::string* route_table_name_ref) {
  if (route_table_name_ref != nullptr) {
    
  } else {
    
  }
  route_table_name_ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), route_table_name_ref,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_table_name_ref_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    route_table_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteId.route_table_name_ref)
}

// -------------------------------------------------------------------

// Route

// string name = 1;
inline void Route::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Route::name() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Route.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Route::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.Route.name)
}
inline std::string* Route::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Route.name)
  return _s;
}
inline const std::string& Route::_internal_name() const {
  return name_.Get();
}
inline void Route::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Route::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Route::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Route.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Route::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Route.name)
}

// .opi_api.network.cloud.v1alpha1.RouteSpec spec = 2;
inline bool Route::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Route::has_spec() const {
  return _internal_has_spec();
}
inline void Route::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteSpec& Route::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::RouteSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::RouteSpec&>(
      ::opi_api::network::cloud::v1alpha1::_RouteSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteSpec& Route::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Route.spec)
  return _internal_spec();
}
inline void Route::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::RouteSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Route.spec)
}
inline ::opi_api::network::cloud::v1alpha1::RouteSpec* Route::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::RouteSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteSpec* Route::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Route.spec)
  
  ::opi_api::network::cloud::v1alpha1::RouteSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteSpec* Route::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::network::cloud::v1alpha1::RouteSpec* Route::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::RouteSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Route.spec)
  return _msg;
}
inline void Route::set_allocated_spec(::opi_api::network::cloud::v1alpha1::RouteSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::RouteSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Route.spec)
}

// .opi_api.network.cloud.v1alpha1.RouteStatus status = 3;
inline bool Route::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Route::has_status() const {
  return _internal_has_status();
}
inline void Route::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteStatus& Route::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::RouteStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::RouteStatus&>(
      ::opi_api::network::cloud::v1alpha1::_RouteStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteStatus& Route::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Route.status)
  return _internal_status();
}
inline void Route::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::RouteStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Route.status)
}
inline ::opi_api::network::cloud::v1alpha1::RouteStatus* Route::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::RouteStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteStatus* Route::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Route.status)
  
  ::opi_api::network::cloud::v1alpha1::RouteStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteStatus* Route::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::network::cloud::v1alpha1::RouteStatus* Route::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::RouteStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Route.status)
  return _msg;
}
inline void Route::set_allocated_status(::opi_api::network::cloud::v1alpha1::RouteStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::RouteStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Route.status)
}

// -------------------------------------------------------------------

// RouteSpec

// string route_table_name_ref = 1;
inline void RouteSpec::clear_route_table_name_ref() {
  route_table_name_ref_.ClearToEmpty();
}
inline const std::string& RouteSpec::route_table_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteSpec.route_table_name_ref)
  return _internal_route_table_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteSpec::set_route_table_name_ref(ArgT0&& arg0, ArgT... args) {
 
 route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.RouteSpec.route_table_name_ref)
}
inline std::string* RouteSpec::mutable_route_table_name_ref() {
  std::string* _s = _internal_mutable_route_table_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteSpec.route_table_name_ref)
  return _s;
}
inline const std::string& RouteSpec::_internal_route_table_name_ref() const {
  return route_table_name_ref_.Get();
}
inline void RouteSpec::_internal_set_route_table_name_ref(const std::string& value) {
  
  route_table_name_ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteSpec::_internal_mutable_route_table_name_ref() {
  
  return route_table_name_ref_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteSpec::release_route_table_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteSpec.route_table_name_ref)
  return route_table_name_ref_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteSpec::set_allocated_route_table_name_ref(std::string* route_table_name_ref) {
  if (route_table_name_ref != nullptr) {
    
  } else {
    
  }
  route_table_name_ref_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), route_table_name_ref,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (route_table_name_ref_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    route_table_name_ref_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteSpec.route_table_name_ref)
}

// .opi_api.network.cloud.v1alpha1.RouteAttrs attrs = 2;
inline bool RouteSpec::_internal_has_attrs() const {
  return this != internal_default_instance() && attrs_ != nullptr;
}
inline bool RouteSpec::has_attrs() const {
  return _internal_has_attrs();
}
inline void RouteSpec::clear_attrs() {
  if (GetArenaForAllocation() == nullptr && attrs_ != nullptr) {
    delete attrs_;
  }
  attrs_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::RouteAttrs& RouteSpec::_internal_attrs() const {
  const ::opi_api::network::cloud::v1alpha1::RouteAttrs* p = attrs_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::RouteAttrs&>(
      ::opi_api::network::cloud::v1alpha1::_RouteAttrs_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::RouteAttrs& RouteSpec::attrs() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.RouteSpec.attrs)
  return _internal_attrs();
}
inline void RouteSpec::unsafe_arena_set_allocated_attrs(
    ::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attrs_);
  }
  attrs_ = attrs;
  if (attrs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.RouteSpec.attrs)
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteSpec::release_attrs() {
  
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* temp = attrs_;
  attrs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteSpec::unsafe_arena_release_attrs() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.RouteSpec.attrs)
  
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* temp = attrs_;
  attrs_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteSpec::_internal_mutable_attrs() {
  
  if (attrs_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::RouteAttrs>(GetArenaForAllocation());
    attrs_ = p;
  }
  return attrs_;
}
inline ::opi_api::network::cloud::v1alpha1::RouteAttrs* RouteSpec::mutable_attrs() {
  ::opi_api::network::cloud::v1alpha1::RouteAttrs* _msg = _internal_mutable_attrs();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.RouteSpec.attrs)
  return _msg;
}
inline void RouteSpec::set_allocated_attrs(::opi_api::network::cloud::v1alpha1::RouteAttrs* attrs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attrs_;
  }
  if (attrs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::network::cloud::v1alpha1::RouteAttrs>::GetOwningArena(attrs);
    if (message_arena != submessage_arena) {
      attrs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attrs, submessage_arena);
    }
    
  } else {
    
  }
  attrs_ = attrs;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.RouteSpec.attrs)
}

// -------------------------------------------------------------------

// RouteStatus

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::RouteClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::RouteClass>() {
  return ::opi_api::network::cloud::v1alpha1::RouteClass_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_route_2eproto
