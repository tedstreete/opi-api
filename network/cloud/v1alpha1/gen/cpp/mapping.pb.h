// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mapping.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mapping_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mapping_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "networktypes.pb.h"
#include "google/api/resource.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mapping_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mapping_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mapping_2eproto;
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {
class L2MappingKey;
struct L2MappingKeyDefaultTypeInternal;
extern L2MappingKeyDefaultTypeInternal _L2MappingKey_default_instance_;
class L3MappingKey;
struct L3MappingKeyDefaultTypeInternal;
extern L3MappingKeyDefaultTypeInternal _L3MappingKey_default_instance_;
class Mapping;
struct MappingDefaultTypeInternal;
extern MappingDefaultTypeInternal _Mapping_default_instance_;
class MappingLookupFilter;
struct MappingLookupFilterDefaultTypeInternal;
extern MappingLookupFilterDefaultTypeInternal _MappingLookupFilter_default_instance_;
class MappingSpec;
struct MappingSpecDefaultTypeInternal;
extern MappingSpecDefaultTypeInternal _MappingSpec_default_instance_;
class MappingStatus;
struct MappingStatusDefaultTypeInternal;
extern MappingStatusDefaultTypeInternal _MappingStatus_default_instance_;
}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::network::cloud::v1alpha1::L2MappingKey* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::L2MappingKey>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::L3MappingKey* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::L3MappingKey>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::Mapping* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::Mapping>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::MappingLookupFilter* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingLookupFilter>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::MappingSpec* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingSpec>(Arena*);
template<> ::opi_api::network::cloud::v1alpha1::MappingStatus* Arena::CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace network {
namespace cloud {
namespace v1alpha1 {

enum MappingType : int {
  MAPPING_TYPE_UNSPECIFIED = 0,
  MAPPING_TYPE_VPC = 1,
  MAPPING_TYPE_SERVICE = 2,
  MAPPING_TYPE_LB_VIP = 3,
  MappingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MappingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MappingType_IsValid(int value);
constexpr MappingType MappingType_MIN = MAPPING_TYPE_UNSPECIFIED;
constexpr MappingType MappingType_MAX = MAPPING_TYPE_LB_VIP;
constexpr int MappingType_ARRAYSIZE = MappingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MappingType_descriptor();
template<typename T>
inline const std::string& MappingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MappingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MappingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MappingType_descriptor(), enum_t_value);
}
inline bool MappingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MappingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MappingType>(
    MappingType_descriptor(), name, value);
}
enum MappingKeyType : int {
  MAPPING_KEY_TYPE_UNSPECIFIED = 0,
  MAPPING_KEY_TYPE_L2 = 1,
  MAPPING_KEY_TYPE_L3 = 2,
  MappingKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MappingKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MappingKeyType_IsValid(int value);
constexpr MappingKeyType MappingKeyType_MIN = MAPPING_KEY_TYPE_UNSPECIFIED;
constexpr MappingKeyType MappingKeyType_MAX = MAPPING_KEY_TYPE_L3;
constexpr int MappingKeyType_ARRAYSIZE = MappingKeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MappingKeyType_descriptor();
template<typename T>
inline const std::string& MappingKeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MappingKeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MappingKeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MappingKeyType_descriptor(), enum_t_value);
}
inline bool MappingKeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MappingKeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MappingKeyType>(
    MappingKeyType_descriptor(), name, value);
}
// ===================================================================

class Mapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.Mapping) */ {
 public:
  inline Mapping() : Mapping(nullptr) {}
  ~Mapping() override;
  explicit PROTOBUF_CONSTEXPR Mapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mapping(const Mapping& from);
  Mapping(Mapping&& from) noexcept
    : Mapping() {
    *this = ::std::move(from);
  }

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mapping& operator=(Mapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mapping* internal_default_instance() {
    return reinterpret_cast<const Mapping*>(
               &_Mapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Mapping& a, Mapping& b) {
    a.Swap(&b);
  }
  inline void Swap(Mapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mapping& from) {
    Mapping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.Mapping";
  }
  protected:
  explicit Mapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.network.cloud.v1alpha1.MappingSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::network::cloud::v1alpha1::MappingSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::MappingSpec* release_spec();
  ::opi_api::network::cloud::v1alpha1::MappingSpec* mutable_spec();
  void set_allocated_spec(::opi_api::network::cloud::v1alpha1::MappingSpec* spec);
  private:
  const ::opi_api::network::cloud::v1alpha1::MappingSpec& _internal_spec() const;
  ::opi_api::network::cloud::v1alpha1::MappingSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::network::cloud::v1alpha1::MappingSpec* spec);
  ::opi_api::network::cloud::v1alpha1::MappingSpec* unsafe_arena_release_spec();

  // .opi_api.network.cloud.v1alpha1.MappingStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::network::cloud::v1alpha1::MappingStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::MappingStatus* release_status();
  ::opi_api::network::cloud::v1alpha1::MappingStatus* mutable_status();
  void set_allocated_status(::opi_api::network::cloud::v1alpha1::MappingStatus* status);
  private:
  const ::opi_api::network::cloud::v1alpha1::MappingStatus& _internal_status() const;
  ::opi_api::network::cloud::v1alpha1::MappingStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::network::cloud::v1alpha1::MappingStatus* status);
  ::opi_api::network::cloud::v1alpha1::MappingStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.Mapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::network::cloud::v1alpha1::MappingSpec* spec_;
    ::opi_api::network::cloud::v1alpha1::MappingStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class MappingSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.MappingSpec) */ {
 public:
  inline MappingSpec() : MappingSpec(nullptr) {}
  ~MappingSpec() override;
  explicit PROTOBUF_CONSTEXPR MappingSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MappingSpec(const MappingSpec& from);
  MappingSpec(MappingSpec&& from) noexcept
    : MappingSpec() {
    *this = ::std::move(from);
  }

  inline MappingSpec& operator=(const MappingSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline MappingSpec& operator=(MappingSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MappingSpec& default_instance() {
    return *internal_default_instance();
  }
  enum MacOrIpCase {
    kIpKey = 1,
    kMacKey = 2,
    MAC_OR_IP_NOT_SET = 0,
  };

  enum DstinfoCase {
    kVnicNameRef = 4,
    kTunnelNameRef = 5,
    kNhGroupNameRef = 6,
    DSTINFO_NOT_SET = 0,
  };

  static inline const MappingSpec* internal_default_instance() {
    return reinterpret_cast<const MappingSpec*>(
               &_MappingSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MappingSpec& a, MappingSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(MappingSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MappingSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MappingSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MappingSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MappingSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MappingSpec& from) {
    MappingSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MappingSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.MappingSpec";
  }
  protected:
  explicit MappingSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 10,
    kSubnetNameRefFieldNumber = 3,
    kMacAddrFieldNumber = 7,
    kEncapFieldNumber = 8,
    kPublicIpFieldNumber = 9,
    kTypeFieldNumber = 11,
    kIpKeyFieldNumber = 1,
    kMacKeyFieldNumber = 2,
    kVnicNameRefFieldNumber = 4,
    kTunnelNameRefFieldNumber = 5,
    kNhGroupNameRefFieldNumber = 6,
  };
  // repeated uint32 tags = 10;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  uint32_t _internal_tags(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_tags() const;
  void _internal_add_tags(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_tags();
  public:
  uint32_t tags(int index) const;
  void set_tags(int index, uint32_t value);
  void add_tags(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_tags();

  // string subnet_name_ref = 3;
  void clear_subnet_name_ref();
  const std::string& subnet_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subnet_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subnet_name_ref();
  PROTOBUF_NODISCARD std::string* release_subnet_name_ref();
  void set_allocated_subnet_name_ref(std::string* subnet_name_ref);
  private:
  const std::string& _internal_subnet_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subnet_name_ref(const std::string& value);
  std::string* _internal_mutable_subnet_name_ref();
  public:

  // bytes mac_addr = 7;
  void clear_mac_addr();
  const std::string& mac_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_addr();
  PROTOBUF_NODISCARD std::string* release_mac_addr();
  void set_allocated_mac_addr(std::string* mac_addr);
  private:
  const std::string& _internal_mac_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_addr(const std::string& value);
  std::string* _internal_mutable_mac_addr();
  public:

  // .opi_api.network.opinetcommon.v1alpha1.Encap encap = 8;
  bool has_encap() const;
  private:
  bool _internal_has_encap() const;
  public:
  void clear_encap();
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& encap() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::Encap* release_encap();
  ::opi_api::network::opinetcommon::v1alpha1::Encap* mutable_encap();
  void set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::Encap& _internal_encap() const;
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _internal_mutable_encap();
  public:
  void unsafe_arena_set_allocated_encap(
      ::opi_api::network::opinetcommon::v1alpha1::Encap* encap);
  ::opi_api::network::opinetcommon::v1alpha1::Encap* unsafe_arena_release_encap();

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress public_ip = 9;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& public_ip() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_public_ip();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_public_ip();
  void set_allocated_public_ip(::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_public_ip() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_public_ip();
  public:
  void unsafe_arena_set_allocated_public_ip(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_public_ip();

  // .opi_api.network.cloud.v1alpha1.MappingType type = 11;
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::MappingType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MappingType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  public:

  // .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 1;
  bool has_ip_key() const;
  private:
  bool _internal_has_ip_key() const;
  public:
  void clear_ip_key();
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& ip_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L3MappingKey* release_ip_key();
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* mutable_ip_key();
  void set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& _internal_ip_key() const;
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _internal_mutable_ip_key();
  public:
  void unsafe_arena_set_allocated_ip_key(
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* unsafe_arena_release_ip_key();

  // .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 2;
  bool has_mac_key() const;
  private:
  bool _internal_has_mac_key() const;
  public:
  void clear_mac_key();
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& mac_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L2MappingKey* release_mac_key();
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* mutable_mac_key();
  void set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& _internal_mac_key() const;
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _internal_mutable_mac_key();
  public:
  void unsafe_arena_set_allocated_mac_key(
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* unsafe_arena_release_mac_key();

  // string vnic_name_ref = 4;
  bool has_vnic_name_ref() const;
  private:
  bool _internal_has_vnic_name_ref() const;
  public:
  void clear_vnic_name_ref();
  const std::string& vnic_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vnic_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vnic_name_ref();
  PROTOBUF_NODISCARD std::string* release_vnic_name_ref();
  void set_allocated_vnic_name_ref(std::string* vnic_name_ref);
  private:
  const std::string& _internal_vnic_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vnic_name_ref(const std::string& value);
  std::string* _internal_mutable_vnic_name_ref();
  public:

  // string tunnel_name_ref = 5;
  bool has_tunnel_name_ref() const;
  private:
  bool _internal_has_tunnel_name_ref() const;
  public:
  void clear_tunnel_name_ref();
  const std::string& tunnel_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tunnel_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tunnel_name_ref();
  PROTOBUF_NODISCARD std::string* release_tunnel_name_ref();
  void set_allocated_tunnel_name_ref(std::string* tunnel_name_ref);
  private:
  const std::string& _internal_tunnel_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tunnel_name_ref(const std::string& value);
  std::string* _internal_mutable_tunnel_name_ref();
  public:

  // string nh_group_name_ref = 6;
  bool has_nh_group_name_ref() const;
  private:
  bool _internal_has_nh_group_name_ref() const;
  public:
  void clear_nh_group_name_ref();
  const std::string& nh_group_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nh_group_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nh_group_name_ref();
  PROTOBUF_NODISCARD std::string* release_nh_group_name_ref();
  void set_allocated_nh_group_name_ref(std::string* nh_group_name_ref);
  private:
  const std::string& _internal_nh_group_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nh_group_name_ref(const std::string& value);
  std::string* _internal_mutable_nh_group_name_ref();
  public:

  void clear_mac_or_ip();
  MacOrIpCase mac_or_ip_case() const;
  void clear_dstinfo();
  DstinfoCase dstinfo_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.MappingSpec)
 private:
  class _Internal;
  void set_has_ip_key();
  void set_has_mac_key();
  void set_has_vnic_name_ref();
  void set_has_tunnel_name_ref();
  void set_has_nh_group_name_ref();

  inline bool has_mac_or_ip() const;
  inline void clear_has_mac_or_ip();

  inline bool has_dstinfo() const;
  inline void clear_has_dstinfo();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > tags_;
    mutable std::atomic<int> _tags_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subnet_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_addr_;
    ::opi_api::network::opinetcommon::v1alpha1::Encap* encap_;
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip_;
    int type_;
    union MacOrIpUnion {
      constexpr MacOrIpUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key_;
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key_;
    } mac_or_ip_;
    union DstinfoUnion {
      constexpr DstinfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vnic_name_ref_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tunnel_name_ref_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nh_group_name_ref_;
    } dstinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class MappingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.MappingStatus) */ {
 public:
  inline MappingStatus() : MappingStatus(nullptr) {}
  ~MappingStatus() override;
  explicit PROTOBUF_CONSTEXPR MappingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MappingStatus(const MappingStatus& from);
  MappingStatus(MappingStatus&& from) noexcept
    : MappingStatus() {
    *this = ::std::move(from);
  }

  inline MappingStatus& operator=(const MappingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MappingStatus& operator=(MappingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MappingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const MappingStatus* internal_default_instance() {
    return reinterpret_cast<const MappingStatus*>(
               &_MappingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MappingStatus& a, MappingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MappingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MappingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MappingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MappingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MappingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MappingStatus& from) {
    MappingStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MappingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.MappingStatus";
  }
  protected:
  explicit MappingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTunnelIpFieldNumber = 3,
    kSvcPortMapHwHandleFieldNumber = 4,
    kVnfTunnelHwHandleFieldNumber = 5,
    kPublicNatIndexFieldNumber = 1,
    kPrivateNatIndexFieldNumber = 2,
    kRewriteIndexFieldNumber = 6,
  };
  // repeated .opi_api.network.opinetcommon.v1alpha1.IPAddress tunnel_ip = 3;
  int tunnel_ip_size() const;
  private:
  int _internal_tunnel_ip_size() const;
  public:
  void clear_tunnel_ip();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_tunnel_ip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >*
      mutable_tunnel_ip();
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_tunnel_ip(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_add_tunnel_ip();
  public:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& tunnel_ip(int index) const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* add_tunnel_ip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >&
      tunnel_ip() const;

  // .opi_api.network.opinetcommon.v1alpha1.HwHandle svc_port_map_hw_handle = 4;
  bool has_svc_port_map_hw_handle() const;
  private:
  bool _internal_has_svc_port_map_hw_handle() const;
  public:
  void clear_svc_port_map_hw_handle();
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& svc_port_map_hw_handle() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::HwHandle* release_svc_port_map_hw_handle();
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* mutable_svc_port_map_hw_handle();
  void set_allocated_svc_port_map_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& _internal_svc_port_map_hw_handle() const;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _internal_mutable_svc_port_map_hw_handle();
  public:
  void unsafe_arena_set_allocated_svc_port_map_hw_handle(
      ::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle);
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* unsafe_arena_release_svc_port_map_hw_handle();

  // .opi_api.network.opinetcommon.v1alpha1.HwHandle vnf_tunnel_hw_handle = 5;
  bool has_vnf_tunnel_hw_handle() const;
  private:
  bool _internal_has_vnf_tunnel_hw_handle() const;
  public:
  void clear_vnf_tunnel_hw_handle();
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& vnf_tunnel_hw_handle() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::HwHandle* release_vnf_tunnel_hw_handle();
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* mutable_vnf_tunnel_hw_handle();
  void set_allocated_vnf_tunnel_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& _internal_vnf_tunnel_hw_handle() const;
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _internal_mutable_vnf_tunnel_hw_handle();
  public:
  void unsafe_arena_set_allocated_vnf_tunnel_hw_handle(
      ::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle);
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* unsafe_arena_release_vnf_tunnel_hw_handle();

  // int32 public_nat_index = 1;
  void clear_public_nat_index();
  int32_t public_nat_index() const;
  void set_public_nat_index(int32_t value);
  private:
  int32_t _internal_public_nat_index() const;
  void _internal_set_public_nat_index(int32_t value);
  public:

  // int32 private_nat_index = 2;
  void clear_private_nat_index();
  int32_t private_nat_index() const;
  void set_private_nat_index(int32_t value);
  private:
  int32_t _internal_private_nat_index() const;
  void _internal_set_private_nat_index(int32_t value);
  public:

  // int32 rewrite_index = 6;
  void clear_rewrite_index();
  int32_t rewrite_index() const;
  void set_rewrite_index(int32_t value);
  private:
  int32_t _internal_rewrite_index() const;
  void _internal_set_rewrite_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.MappingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress > tunnel_ip_;
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle_;
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle_;
    int32_t public_nat_index_;
    int32_t private_nat_index_;
    int32_t rewrite_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class L3MappingKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.L3MappingKey) */ {
 public:
  inline L3MappingKey() : L3MappingKey(nullptr) {}
  ~L3MappingKey() override;
  explicit PROTOBUF_CONSTEXPR L3MappingKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L3MappingKey(const L3MappingKey& from);
  L3MappingKey(L3MappingKey&& from) noexcept
    : L3MappingKey() {
    *this = ::std::move(from);
  }

  inline L3MappingKey& operator=(const L3MappingKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline L3MappingKey& operator=(L3MappingKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L3MappingKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const L3MappingKey* internal_default_instance() {
    return reinterpret_cast<const L3MappingKey*>(
               &_L3MappingKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(L3MappingKey& a, L3MappingKey& b) {
    a.Swap(&b);
  }
  inline void Swap(L3MappingKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L3MappingKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L3MappingKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L3MappingKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L3MappingKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L3MappingKey& from) {
    L3MappingKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L3MappingKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.L3MappingKey";
  }
  protected:
  explicit L3MappingKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVpcNameRefFieldNumber = 1,
    kIpAddressFieldNumber = 2,
  };
  // string vpc_name_ref = 1;
  void clear_vpc_name_ref();
  const std::string& vpc_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpc_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpc_name_ref();
  PROTOBUF_NODISCARD std::string* release_vpc_name_ref();
  void set_allocated_vpc_name_ref(std::string* vpc_name_ref);
  private:
  const std::string& _internal_vpc_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpc_name_ref(const std::string& value);
  std::string* _internal_mutable_vpc_name_ref();
  public:

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 2;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& ip_address() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_ip_address();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_ip_address();
  void set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_ip_address() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_ip_address();
  public:
  void unsafe_arena_set_allocated_ip_address(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_ip_address();

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.L3MappingKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpc_name_ref_;
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class L2MappingKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.L2MappingKey) */ {
 public:
  inline L2MappingKey() : L2MappingKey(nullptr) {}
  ~L2MappingKey() override;
  explicit PROTOBUF_CONSTEXPR L2MappingKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  L2MappingKey(const L2MappingKey& from);
  L2MappingKey(L2MappingKey&& from) noexcept
    : L2MappingKey() {
    *this = ::std::move(from);
  }

  inline L2MappingKey& operator=(const L2MappingKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline L2MappingKey& operator=(L2MappingKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const L2MappingKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const L2MappingKey* internal_default_instance() {
    return reinterpret_cast<const L2MappingKey*>(
               &_L2MappingKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(L2MappingKey& a, L2MappingKey& b) {
    a.Swap(&b);
  }
  inline void Swap(L2MappingKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(L2MappingKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  L2MappingKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<L2MappingKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const L2MappingKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const L2MappingKey& from) {
    L2MappingKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(L2MappingKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.L2MappingKey";
  }
  protected:
  explicit L2MappingKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubnetNameRefFieldNumber = 1,
    kMacAddressFieldNumber = 2,
  };
  // string subnet_name_ref = 1;
  void clear_subnet_name_ref();
  const std::string& subnet_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subnet_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subnet_name_ref();
  PROTOBUF_NODISCARD std::string* release_subnet_name_ref();
  void set_allocated_subnet_name_ref(std::string* subnet_name_ref);
  private:
  const std::string& _internal_subnet_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subnet_name_ref(const std::string& value);
  std::string* _internal_mutable_subnet_name_ref();
  public:

  // bytes mac_address = 2;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.L2MappingKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subnet_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mapping_2eproto;
};
// -------------------------------------------------------------------

class MappingLookupFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.network.cloud.v1alpha1.MappingLookupFilter) */ {
 public:
  inline MappingLookupFilter() : MappingLookupFilter(nullptr) {}
  ~MappingLookupFilter() override;
  explicit PROTOBUF_CONSTEXPR MappingLookupFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MappingLookupFilter(const MappingLookupFilter& from);
  MappingLookupFilter(MappingLookupFilter&& from) noexcept
    : MappingLookupFilter() {
    *this = ::std::move(from);
  }

  inline MappingLookupFilter& operator=(const MappingLookupFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MappingLookupFilter& operator=(MappingLookupFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MappingLookupFilter& default_instance() {
    return *internal_default_instance();
  }
  enum IpOrMacCase {
    kIpKey = 4,
    kMacKey = 5,
    kIpAddress = 6,
    kMacAddress = 7,
    kVpcNameRef = 8,
    IP_OR_MAC_NOT_SET = 0,
  };

  static inline const MappingLookupFilter* internal_default_instance() {
    return reinterpret_cast<const MappingLookupFilter*>(
               &_MappingLookupFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MappingLookupFilter& a, MappingLookupFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(MappingLookupFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MappingLookupFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MappingLookupFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MappingLookupFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MappingLookupFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MappingLookupFilter& from) {
    MappingLookupFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MappingLookupFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.network.cloud.v1alpha1.MappingLookupFilter";
  }
  protected:
  explicit MappingLookupFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalFieldNumber = 1,
    kKeyTypeFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIpKeyFieldNumber = 4,
    kMacKeyFieldNumber = 5,
    kIpAddressFieldNumber = 6,
    kMacAddressFieldNumber = 7,
    kVpcNameRefFieldNumber = 8,
  };
  // bool local = 1;
  void clear_local();
  bool local() const;
  void set_local(bool value);
  private:
  bool _internal_local() const;
  void _internal_set_local(bool value);
  public:

  // .opi_api.network.cloud.v1alpha1.MappingKeyType key_type = 2;
  void clear_key_type();
  ::opi_api::network::cloud::v1alpha1::MappingKeyType key_type() const;
  void set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MappingKeyType _internal_key_type() const;
  void _internal_set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value);
  public:

  // .opi_api.network.cloud.v1alpha1.MappingType type = 3;
  void clear_type();
  ::opi_api::network::cloud::v1alpha1::MappingType type() const;
  void set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  private:
  ::opi_api::network::cloud::v1alpha1::MappingType _internal_type() const;
  void _internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value);
  public:

  // .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 4;
  bool has_ip_key() const;
  private:
  bool _internal_has_ip_key() const;
  public:
  void clear_ip_key();
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& ip_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L3MappingKey* release_ip_key();
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* mutable_ip_key();
  void set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L3MappingKey& _internal_ip_key() const;
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _internal_mutable_ip_key();
  public:
  void unsafe_arena_set_allocated_ip_key(
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key);
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* unsafe_arena_release_ip_key();

  // .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 5;
  bool has_mac_key() const;
  private:
  bool _internal_has_mac_key() const;
  public:
  void clear_mac_key();
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& mac_key() const;
  PROTOBUF_NODISCARD ::opi_api::network::cloud::v1alpha1::L2MappingKey* release_mac_key();
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* mutable_mac_key();
  void set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  private:
  const ::opi_api::network::cloud::v1alpha1::L2MappingKey& _internal_mac_key() const;
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _internal_mutable_mac_key();
  public:
  void unsafe_arena_set_allocated_mac_key(
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key);
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* unsafe_arena_release_mac_key();

  // .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 6;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& ip_address() const;
  PROTOBUF_NODISCARD ::opi_api::network::opinetcommon::v1alpha1::IPAddress* release_ip_address();
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* mutable_ip_address();
  void set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  private:
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& _internal_ip_address() const;
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _internal_mutable_ip_address();
  public:
  void unsafe_arena_set_allocated_ip_address(
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address);
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* unsafe_arena_release_ip_address();

  // bytes mac_address = 7;
  bool has_mac_address() const;
  private:
  bool _internal_has_mac_address() const;
  public:
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // string vpc_name_ref = 8;
  bool has_vpc_name_ref() const;
  private:
  bool _internal_has_vpc_name_ref() const;
  public:
  void clear_vpc_name_ref();
  const std::string& vpc_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vpc_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vpc_name_ref();
  PROTOBUF_NODISCARD std::string* release_vpc_name_ref();
  void set_allocated_vpc_name_ref(std::string* vpc_name_ref);
  private:
  const std::string& _internal_vpc_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vpc_name_ref(const std::string& value);
  std::string* _internal_mutable_vpc_name_ref();
  public:

  void clear_ip_or_mac();
  IpOrMacCase ip_or_mac_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.network.cloud.v1alpha1.MappingLookupFilter)
 private:
  class _Internal;
  void set_has_ip_key();
  void set_has_mac_key();
  void set_has_ip_address();
  void set_has_mac_address();
  void set_has_vpc_name_ref();

  inline bool has_ip_or_mac() const;
  inline void clear_has_ip_or_mac();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool local_;
    int key_type_;
    int type_;
    union IpOrMacUnion {
      constexpr IpOrMacUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key_;
      ::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key_;
      ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vpc_name_ref_;
    } ip_or_mac_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mapping_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Mapping

// string name = 1;
inline void Mapping::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Mapping::name() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Mapping.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mapping::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.Mapping.name)
}
inline std::string* Mapping::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Mapping.name)
  return _s;
}
inline const std::string& Mapping::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Mapping::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Mapping::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Mapping::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Mapping.name)
  return _impl_.name_.Release();
}
inline void Mapping::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.name)
}

// .opi_api.network.cloud.v1alpha1.MappingSpec spec = 2;
inline bool Mapping::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool Mapping::has_spec() const {
  return _internal_has_spec();
}
inline void Mapping::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::MappingSpec& Mapping::_internal_spec() const {
  const ::opi_api::network::cloud::v1alpha1::MappingSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::MappingSpec&>(
      ::opi_api::network::cloud::v1alpha1::_MappingSpec_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::MappingSpec& Mapping::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Mapping.spec)
  return _internal_spec();
}
inline void Mapping::unsafe_arena_set_allocated_spec(
    ::opi_api::network::cloud::v1alpha1::MappingSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.spec)
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::release_spec() {
  
  ::opi_api::network::cloud::v1alpha1::MappingSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Mapping.spec)
  
  ::opi_api::network::cloud::v1alpha1::MappingSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::opi_api::network::cloud::v1alpha1::MappingSpec* Mapping::mutable_spec() {
  ::opi_api::network::cloud::v1alpha1::MappingSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Mapping.spec)
  return _msg;
}
inline void Mapping::set_allocated_spec(::opi_api::network::cloud::v1alpha1::MappingSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.spec)
}

// .opi_api.network.cloud.v1alpha1.MappingStatus status = 3;
inline bool Mapping::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Mapping::has_status() const {
  return _internal_has_status();
}
inline void Mapping::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::opi_api::network::cloud::v1alpha1::MappingStatus& Mapping::_internal_status() const {
  const ::opi_api::network::cloud::v1alpha1::MappingStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::cloud::v1alpha1::MappingStatus&>(
      ::opi_api::network::cloud::v1alpha1::_MappingStatus_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::MappingStatus& Mapping::status() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.Mapping.status)
  return _internal_status();
}
inline void Mapping::unsafe_arena_set_allocated_status(
    ::opi_api::network::cloud::v1alpha1::MappingStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.status)
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::release_status() {
  
  ::opi_api::network::cloud::v1alpha1::MappingStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.Mapping.status)
  
  ::opi_api::network::cloud::v1alpha1::MappingStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::cloud::v1alpha1::MappingStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::opi_api::network::cloud::v1alpha1::MappingStatus* Mapping::mutable_status() {
  ::opi_api::network::cloud::v1alpha1::MappingStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.Mapping.status)
  return _msg;
}
inline void Mapping::set_allocated_status(::opi_api::network::cloud::v1alpha1::MappingStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.Mapping.status)
}

// -------------------------------------------------------------------

// MappingSpec

// .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 1;
inline bool MappingSpec::_internal_has_ip_key() const {
  return mac_or_ip_case() == kIpKey;
}
inline bool MappingSpec::has_ip_key() const {
  return _internal_has_ip_key();
}
inline void MappingSpec::set_has_ip_key() {
  _impl_._oneof_case_[0] = kIpKey;
}
inline void MappingSpec::clear_ip_key() {
  if (_internal_has_ip_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mac_or_ip_.ip_key_;
    }
    clear_has_mac_or_ip();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::release_ip_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_mac_or_ip();
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = _impl_.mac_or_ip_.ip_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mac_or_ip_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingSpec::_internal_ip_key() const {
  return _internal_has_ip_key()
      ? *_impl_.mac_or_ip_.ip_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L3MappingKey&>(::opi_api::network::cloud::v1alpha1::_L3MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingSpec::ip_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  return _internal_ip_key();
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::unsafe_arena_release_ip_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_mac_or_ip();
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = _impl_.mac_or_ip_.ip_key_;
    _impl_.mac_or_ip_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key) {
  clear_mac_or_ip();
  if (ip_key) {
    set_has_ip_key();
    _impl_.mac_or_ip_.ip_key_ = ip_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::_internal_mutable_ip_key() {
  if (!_internal_has_ip_key()) {
    clear_mac_or_ip();
    set_has_ip_key();
    _impl_.mac_or_ip_.ip_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L3MappingKey >(GetArenaForAllocation());
  }
  return _impl_.mac_or_ip_.ip_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingSpec::mutable_ip_key() {
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _msg = _internal_mutable_ip_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.ip_key)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 2;
inline bool MappingSpec::_internal_has_mac_key() const {
  return mac_or_ip_case() == kMacKey;
}
inline bool MappingSpec::has_mac_key() const {
  return _internal_has_mac_key();
}
inline void MappingSpec::set_has_mac_key() {
  _impl_._oneof_case_[0] = kMacKey;
}
inline void MappingSpec::clear_mac_key() {
  if (_internal_has_mac_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mac_or_ip_.mac_key_;
    }
    clear_has_mac_or_ip();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::release_mac_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_mac_or_ip();
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = _impl_.mac_or_ip_.mac_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mac_or_ip_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingSpec::_internal_mac_key() const {
  return _internal_has_mac_key()
      ? *_impl_.mac_or_ip_.mac_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L2MappingKey&>(::opi_api::network::cloud::v1alpha1::_L2MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingSpec::mac_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  return _internal_mac_key();
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::unsafe_arena_release_mac_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_mac_or_ip();
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = _impl_.mac_or_ip_.mac_key_;
    _impl_.mac_or_ip_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingSpec::unsafe_arena_set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key) {
  clear_mac_or_ip();
  if (mac_key) {
    set_has_mac_key();
    _impl_.mac_or_ip_.mac_key_ = mac_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::_internal_mutable_mac_key() {
  if (!_internal_has_mac_key()) {
    clear_mac_or_ip();
    set_has_mac_key();
    _impl_.mac_or_ip_.mac_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L2MappingKey >(GetArenaForAllocation());
  }
  return _impl_.mac_or_ip_.mac_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingSpec::mutable_mac_key() {
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _msg = _internal_mutable_mac_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.mac_key)
  return _msg;
}

// string subnet_name_ref = 3;
inline void MappingSpec::clear_subnet_name_ref() {
  _impl_.subnet_name_ref_.ClearToEmpty();
}
inline const std::string& MappingSpec::subnet_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_name_ref)
  return _internal_subnet_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MappingSpec::set_subnet_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subnet_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_name_ref)
}
inline std::string* MappingSpec::mutable_subnet_name_ref() {
  std::string* _s = _internal_mutable_subnet_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_name_ref)
  return _s;
}
inline const std::string& MappingSpec::_internal_subnet_name_ref() const {
  return _impl_.subnet_name_ref_.Get();
}
inline void MappingSpec::_internal_set_subnet_name_ref(const std::string& value) {
  
  _impl_.subnet_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingSpec::_internal_mutable_subnet_name_ref() {
  
  return _impl_.subnet_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* MappingSpec::release_subnet_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_name_ref)
  return _impl_.subnet_name_ref_.Release();
}
inline void MappingSpec::set_allocated_subnet_name_ref(std::string* subnet_name_ref) {
  if (subnet_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.subnet_name_ref_.SetAllocated(subnet_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subnet_name_ref_.IsDefault()) {
    _impl_.subnet_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.subnet_name_ref)
}

// string vnic_name_ref = 4;
inline bool MappingSpec::_internal_has_vnic_name_ref() const {
  return dstinfo_case() == kVnicNameRef;
}
inline bool MappingSpec::has_vnic_name_ref() const {
  return _internal_has_vnic_name_ref();
}
inline void MappingSpec::set_has_vnic_name_ref() {
  _impl_._oneof_case_[1] = kVnicNameRef;
}
inline void MappingSpec::clear_vnic_name_ref() {
  if (_internal_has_vnic_name_ref()) {
    _impl_.dstinfo_.vnic_name_ref_.Destroy();
    clear_has_dstinfo();
  }
}
inline const std::string& MappingSpec::vnic_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_name_ref)
  return _internal_vnic_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void MappingSpec::set_vnic_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_vnic_name_ref()) {
    clear_dstinfo();
    set_has_vnic_name_ref();
    _impl_.dstinfo_.vnic_name_ref_.InitDefault();
  }
  _impl_.dstinfo_.vnic_name_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_name_ref)
}
inline std::string* MappingSpec::mutable_vnic_name_ref() {
  std::string* _s = _internal_mutable_vnic_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_name_ref)
  return _s;
}
inline const std::string& MappingSpec::_internal_vnic_name_ref() const {
  if (_internal_has_vnic_name_ref()) {
    return _impl_.dstinfo_.vnic_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MappingSpec::_internal_set_vnic_name_ref(const std::string& value) {
  if (!_internal_has_vnic_name_ref()) {
    clear_dstinfo();
    set_has_vnic_name_ref();
    _impl_.dstinfo_.vnic_name_ref_.InitDefault();
  }
  _impl_.dstinfo_.vnic_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingSpec::_internal_mutable_vnic_name_ref() {
  if (!_internal_has_vnic_name_ref()) {
    clear_dstinfo();
    set_has_vnic_name_ref();
    _impl_.dstinfo_.vnic_name_ref_.InitDefault();
  }
  return _impl_.dstinfo_.vnic_name_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* MappingSpec::release_vnic_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_name_ref)
  if (_internal_has_vnic_name_ref()) {
    clear_has_dstinfo();
    return _impl_.dstinfo_.vnic_name_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void MappingSpec::set_allocated_vnic_name_ref(std::string* vnic_name_ref) {
  if (has_dstinfo()) {
    clear_dstinfo();
  }
  if (vnic_name_ref != nullptr) {
    set_has_vnic_name_ref();
    _impl_.dstinfo_.vnic_name_ref_.InitAllocated(vnic_name_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.vnic_name_ref)
}

// string tunnel_name_ref = 5;
inline bool MappingSpec::_internal_has_tunnel_name_ref() const {
  return dstinfo_case() == kTunnelNameRef;
}
inline bool MappingSpec::has_tunnel_name_ref() const {
  return _internal_has_tunnel_name_ref();
}
inline void MappingSpec::set_has_tunnel_name_ref() {
  _impl_._oneof_case_[1] = kTunnelNameRef;
}
inline void MappingSpec::clear_tunnel_name_ref() {
  if (_internal_has_tunnel_name_ref()) {
    _impl_.dstinfo_.tunnel_name_ref_.Destroy();
    clear_has_dstinfo();
  }
}
inline const std::string& MappingSpec::tunnel_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_name_ref)
  return _internal_tunnel_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void MappingSpec::set_tunnel_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_tunnel_name_ref()) {
    clear_dstinfo();
    set_has_tunnel_name_ref();
    _impl_.dstinfo_.tunnel_name_ref_.InitDefault();
  }
  _impl_.dstinfo_.tunnel_name_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_name_ref)
}
inline std::string* MappingSpec::mutable_tunnel_name_ref() {
  std::string* _s = _internal_mutable_tunnel_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_name_ref)
  return _s;
}
inline const std::string& MappingSpec::_internal_tunnel_name_ref() const {
  if (_internal_has_tunnel_name_ref()) {
    return _impl_.dstinfo_.tunnel_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MappingSpec::_internal_set_tunnel_name_ref(const std::string& value) {
  if (!_internal_has_tunnel_name_ref()) {
    clear_dstinfo();
    set_has_tunnel_name_ref();
    _impl_.dstinfo_.tunnel_name_ref_.InitDefault();
  }
  _impl_.dstinfo_.tunnel_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingSpec::_internal_mutable_tunnel_name_ref() {
  if (!_internal_has_tunnel_name_ref()) {
    clear_dstinfo();
    set_has_tunnel_name_ref();
    _impl_.dstinfo_.tunnel_name_ref_.InitDefault();
  }
  return _impl_.dstinfo_.tunnel_name_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* MappingSpec::release_tunnel_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_name_ref)
  if (_internal_has_tunnel_name_ref()) {
    clear_has_dstinfo();
    return _impl_.dstinfo_.tunnel_name_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void MappingSpec::set_allocated_tunnel_name_ref(std::string* tunnel_name_ref) {
  if (has_dstinfo()) {
    clear_dstinfo();
  }
  if (tunnel_name_ref != nullptr) {
    set_has_tunnel_name_ref();
    _impl_.dstinfo_.tunnel_name_ref_.InitAllocated(tunnel_name_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.tunnel_name_ref)
}

// string nh_group_name_ref = 6;
inline bool MappingSpec::_internal_has_nh_group_name_ref() const {
  return dstinfo_case() == kNhGroupNameRef;
}
inline bool MappingSpec::has_nh_group_name_ref() const {
  return _internal_has_nh_group_name_ref();
}
inline void MappingSpec::set_has_nh_group_name_ref() {
  _impl_._oneof_case_[1] = kNhGroupNameRef;
}
inline void MappingSpec::clear_nh_group_name_ref() {
  if (_internal_has_nh_group_name_ref()) {
    _impl_.dstinfo_.nh_group_name_ref_.Destroy();
    clear_has_dstinfo();
  }
}
inline const std::string& MappingSpec::nh_group_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_name_ref)
  return _internal_nh_group_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void MappingSpec::set_nh_group_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_nh_group_name_ref()) {
    clear_dstinfo();
    set_has_nh_group_name_ref();
    _impl_.dstinfo_.nh_group_name_ref_.InitDefault();
  }
  _impl_.dstinfo_.nh_group_name_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_name_ref)
}
inline std::string* MappingSpec::mutable_nh_group_name_ref() {
  std::string* _s = _internal_mutable_nh_group_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_name_ref)
  return _s;
}
inline const std::string& MappingSpec::_internal_nh_group_name_ref() const {
  if (_internal_has_nh_group_name_ref()) {
    return _impl_.dstinfo_.nh_group_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MappingSpec::_internal_set_nh_group_name_ref(const std::string& value) {
  if (!_internal_has_nh_group_name_ref()) {
    clear_dstinfo();
    set_has_nh_group_name_ref();
    _impl_.dstinfo_.nh_group_name_ref_.InitDefault();
  }
  _impl_.dstinfo_.nh_group_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingSpec::_internal_mutable_nh_group_name_ref() {
  if (!_internal_has_nh_group_name_ref()) {
    clear_dstinfo();
    set_has_nh_group_name_ref();
    _impl_.dstinfo_.nh_group_name_ref_.InitDefault();
  }
  return _impl_.dstinfo_.nh_group_name_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* MappingSpec::release_nh_group_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_name_ref)
  if (_internal_has_nh_group_name_ref()) {
    clear_has_dstinfo();
    return _impl_.dstinfo_.nh_group_name_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void MappingSpec::set_allocated_nh_group_name_ref(std::string* nh_group_name_ref) {
  if (has_dstinfo()) {
    clear_dstinfo();
  }
  if (nh_group_name_ref != nullptr) {
    set_has_nh_group_name_ref();
    _impl_.dstinfo_.nh_group_name_ref_.InitAllocated(nh_group_name_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.nh_group_name_ref)
}

// bytes mac_addr = 7;
inline void MappingSpec::clear_mac_addr() {
  _impl_.mac_addr_.ClearToEmpty();
}
inline const std::string& MappingSpec::mac_addr() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
  return _internal_mac_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MappingSpec::set_mac_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_addr_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
}
inline std::string* MappingSpec::mutable_mac_addr() {
  std::string* _s = _internal_mutable_mac_addr();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
  return _s;
}
inline const std::string& MappingSpec::_internal_mac_addr() const {
  return _impl_.mac_addr_.Get();
}
inline void MappingSpec::_internal_set_mac_addr(const std::string& value) {
  
  _impl_.mac_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingSpec::_internal_mutable_mac_addr() {
  
  return _impl_.mac_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* MappingSpec::release_mac_addr() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
  return _impl_.mac_addr_.Release();
}
inline void MappingSpec::set_allocated_mac_addr(std::string* mac_addr) {
  if (mac_addr != nullptr) {
    
  } else {
    
  }
  _impl_.mac_addr_.SetAllocated(mac_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_addr_.IsDefault()) {
    _impl_.mac_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.mac_addr)
}

// .opi_api.network.opinetcommon.v1alpha1.Encap encap = 8;
inline bool MappingSpec::_internal_has_encap() const {
  return this != internal_default_instance() && _impl_.encap_ != nullptr;
}
inline bool MappingSpec::has_encap() const {
  return _internal_has_encap();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& MappingSpec::_internal_encap() const {
  const ::opi_api::network::opinetcommon::v1alpha1::Encap* p = _impl_.encap_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::Encap&>(
      ::opi_api::network::opinetcommon::v1alpha1::_Encap_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::Encap& MappingSpec::encap() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
  return _internal_encap();
}
inline void MappingSpec::unsafe_arena_set_allocated_encap(
    ::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encap_);
  }
  _impl_.encap_ = encap;
  if (encap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::release_encap() {
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = _impl_.encap_;
  _impl_.encap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::unsafe_arena_release_encap() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
  
  ::opi_api::network::opinetcommon::v1alpha1::Encap* temp = _impl_.encap_;
  _impl_.encap_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::_internal_mutable_encap() {
  
  if (_impl_.encap_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::Encap>(GetArenaForAllocation());
    _impl_.encap_ = p;
  }
  return _impl_.encap_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::Encap* MappingSpec::mutable_encap() {
  ::opi_api::network::opinetcommon::v1alpha1::Encap* _msg = _internal_mutable_encap();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
  return _msg;
}
inline void MappingSpec::set_allocated_encap(::opi_api::network::opinetcommon::v1alpha1::Encap* encap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encap_);
  }
  if (encap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encap));
    if (message_arena != submessage_arena) {
      encap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.encap_ = encap;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.encap)
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress public_ip = 9;
inline bool MappingSpec::_internal_has_public_ip() const {
  return this != internal_default_instance() && _impl_.public_ip_ != nullptr;
}
inline bool MappingSpec::has_public_ip() const {
  return _internal_has_public_ip();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingSpec::_internal_public_ip() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = _impl_.public_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingSpec::public_ip() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
  return _internal_public_ip();
}
inline void MappingSpec::unsafe_arena_set_allocated_public_ip(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_ip_);
  }
  _impl_.public_ip_ = public_ip;
  if (public_ip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::release_public_ip() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.public_ip_;
  _impl_.public_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::unsafe_arena_release_public_ip() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.public_ip_;
  _impl_.public_ip_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::_internal_mutable_public_ip() {
  
  if (_impl_.public_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    _impl_.public_ip_ = p;
  }
  return _impl_.public_ip_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingSpec::mutable_public_ip() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
  return _msg;
}
inline void MappingSpec::set_allocated_public_ip(::opi_api::network::opinetcommon::v1alpha1::IPAddress* public_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.public_ip_);
  }
  if (public_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip));
    if (message_arena != submessage_arena) {
      public_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_ip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.public_ip_ = public_ip;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingSpec.public_ip)
}

// repeated uint32 tags = 10;
inline int MappingSpec::_internal_tags_size() const {
  return _impl_.tags_.size();
}
inline int MappingSpec::tags_size() const {
  return _internal_tags_size();
}
inline void MappingSpec::clear_tags() {
  _impl_.tags_.Clear();
}
inline uint32_t MappingSpec::_internal_tags(int index) const {
  return _impl_.tags_.Get(index);
}
inline uint32_t MappingSpec::tags(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
  return _internal_tags(index);
}
inline void MappingSpec::set_tags(int index, uint32_t value) {
  _impl_.tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
}
inline void MappingSpec::_internal_add_tags(uint32_t value) {
  _impl_.tags_.Add(value);
}
inline void MappingSpec::add_tags(uint32_t value) {
  _internal_add_tags(value);
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MappingSpec::_internal_tags() const {
  return _impl_.tags_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MappingSpec::tags() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MappingSpec::_internal_mutable_tags() {
  return &_impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MappingSpec::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.MappingSpec.tags)
  return _internal_mutable_tags();
}

// .opi_api.network.cloud.v1alpha1.MappingType type = 11;
inline void MappingSpec::clear_type() {
  _impl_.type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingSpec::_internal_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MappingType >(_impl_.type_);
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingSpec::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingSpec.type)
  return _internal_type();
}
inline void MappingSpec::_internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  
  _impl_.type_ = value;
}
inline void MappingSpec::set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingSpec.type)
}

inline bool MappingSpec::has_mac_or_ip() const {
  return mac_or_ip_case() != MAC_OR_IP_NOT_SET;
}
inline void MappingSpec::clear_has_mac_or_ip() {
  _impl_._oneof_case_[0] = MAC_OR_IP_NOT_SET;
}
inline bool MappingSpec::has_dstinfo() const {
  return dstinfo_case() != DSTINFO_NOT_SET;
}
inline void MappingSpec::clear_has_dstinfo() {
  _impl_._oneof_case_[1] = DSTINFO_NOT_SET;
}
inline MappingSpec::MacOrIpCase MappingSpec::mac_or_ip_case() const {
  return MappingSpec::MacOrIpCase(_impl_._oneof_case_[0]);
}
inline MappingSpec::DstinfoCase MappingSpec::dstinfo_case() const {
  return MappingSpec::DstinfoCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// MappingStatus

// int32 public_nat_index = 1;
inline void MappingStatus::clear_public_nat_index() {
  _impl_.public_nat_index_ = 0;
}
inline int32_t MappingStatus::_internal_public_nat_index() const {
  return _impl_.public_nat_index_;
}
inline int32_t MappingStatus::public_nat_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.public_nat_index)
  return _internal_public_nat_index();
}
inline void MappingStatus::_internal_set_public_nat_index(int32_t value) {
  
  _impl_.public_nat_index_ = value;
}
inline void MappingStatus::set_public_nat_index(int32_t value) {
  _internal_set_public_nat_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingStatus.public_nat_index)
}

// int32 private_nat_index = 2;
inline void MappingStatus::clear_private_nat_index() {
  _impl_.private_nat_index_ = 0;
}
inline int32_t MappingStatus::_internal_private_nat_index() const {
  return _impl_.private_nat_index_;
}
inline int32_t MappingStatus::private_nat_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.private_nat_index)
  return _internal_private_nat_index();
}
inline void MappingStatus::_internal_set_private_nat_index(int32_t value) {
  
  _impl_.private_nat_index_ = value;
}
inline void MappingStatus::set_private_nat_index(int32_t value) {
  _internal_set_private_nat_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingStatus.private_nat_index)
}

// repeated .opi_api.network.opinetcommon.v1alpha1.IPAddress tunnel_ip = 3;
inline int MappingStatus::_internal_tunnel_ip_size() const {
  return _impl_.tunnel_ip_.size();
}
inline int MappingStatus::tunnel_ip_size() const {
  return _internal_tunnel_ip_size();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingStatus::mutable_tunnel_ip(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return _impl_.tunnel_ip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >*
MappingStatus::mutable_tunnel_ip() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return &_impl_.tunnel_ip_;
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingStatus::_internal_tunnel_ip(int index) const {
  return _impl_.tunnel_ip_.Get(index);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingStatus::tunnel_ip(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return _internal_tunnel_ip(index);
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingStatus::_internal_add_tunnel_ip() {
  return _impl_.tunnel_ip_.Add();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingStatus::add_tunnel_ip() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _add = _internal_add_tunnel_ip();
  // @@protoc_insertion_point(field_add:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >&
MappingStatus::tunnel_ip() const {
  // @@protoc_insertion_point(field_list:opi_api.network.cloud.v1alpha1.MappingStatus.tunnel_ip)
  return _impl_.tunnel_ip_;
}

// .opi_api.network.opinetcommon.v1alpha1.HwHandle svc_port_map_hw_handle = 4;
inline bool MappingStatus::_internal_has_svc_port_map_hw_handle() const {
  return this != internal_default_instance() && _impl_.svc_port_map_hw_handle_ != nullptr;
}
inline bool MappingStatus::has_svc_port_map_hw_handle() const {
  return _internal_has_svc_port_map_hw_handle();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::_internal_svc_port_map_hw_handle() const {
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle* p = _impl_.svc_port_map_hw_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::HwHandle&>(
      ::opi_api::network::opinetcommon::v1alpha1::_HwHandle_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::svc_port_map_hw_handle() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
  return _internal_svc_port_map_hw_handle();
}
inline void MappingStatus::unsafe_arena_set_allocated_svc_port_map_hw_handle(
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.svc_port_map_hw_handle_);
  }
  _impl_.svc_port_map_hw_handle_ = svc_port_map_hw_handle;
  if (svc_port_map_hw_handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::release_svc_port_map_hw_handle() {
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.svc_port_map_hw_handle_;
  _impl_.svc_port_map_hw_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::unsafe_arena_release_svc_port_map_hw_handle() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.svc_port_map_hw_handle_;
  _impl_.svc_port_map_hw_handle_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::_internal_mutable_svc_port_map_hw_handle() {
  
  if (_impl_.svc_port_map_hw_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(GetArenaForAllocation());
    _impl_.svc_port_map_hw_handle_ = p;
  }
  return _impl_.svc_port_map_hw_handle_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::mutable_svc_port_map_hw_handle() {
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _msg = _internal_mutable_svc_port_map_hw_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
  return _msg;
}
inline void MappingStatus::set_allocated_svc_port_map_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* svc_port_map_hw_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.svc_port_map_hw_handle_);
  }
  if (svc_port_map_hw_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(svc_port_map_hw_handle));
    if (message_arena != submessage_arena) {
      svc_port_map_hw_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, svc_port_map_hw_handle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.svc_port_map_hw_handle_ = svc_port_map_hw_handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.svc_port_map_hw_handle)
}

// .opi_api.network.opinetcommon.v1alpha1.HwHandle vnf_tunnel_hw_handle = 5;
inline bool MappingStatus::_internal_has_vnf_tunnel_hw_handle() const {
  return this != internal_default_instance() && _impl_.vnf_tunnel_hw_handle_ != nullptr;
}
inline bool MappingStatus::has_vnf_tunnel_hw_handle() const {
  return _internal_has_vnf_tunnel_hw_handle();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::_internal_vnf_tunnel_hw_handle() const {
  const ::opi_api::network::opinetcommon::v1alpha1::HwHandle* p = _impl_.vnf_tunnel_hw_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::HwHandle&>(
      ::opi_api::network::opinetcommon::v1alpha1::_HwHandle_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::HwHandle& MappingStatus::vnf_tunnel_hw_handle() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
  return _internal_vnf_tunnel_hw_handle();
}
inline void MappingStatus::unsafe_arena_set_allocated_vnf_tunnel_hw_handle(
    ::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vnf_tunnel_hw_handle_);
  }
  _impl_.vnf_tunnel_hw_handle_ = vnf_tunnel_hw_handle;
  if (vnf_tunnel_hw_handle) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::release_vnf_tunnel_hw_handle() {
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.vnf_tunnel_hw_handle_;
  _impl_.vnf_tunnel_hw_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::unsafe_arena_release_vnf_tunnel_hw_handle() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
  
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* temp = _impl_.vnf_tunnel_hw_handle_;
  _impl_.vnf_tunnel_hw_handle_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::_internal_mutable_vnf_tunnel_hw_handle() {
  
  if (_impl_.vnf_tunnel_hw_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::HwHandle>(GetArenaForAllocation());
    _impl_.vnf_tunnel_hw_handle_ = p;
  }
  return _impl_.vnf_tunnel_hw_handle_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::HwHandle* MappingStatus::mutable_vnf_tunnel_hw_handle() {
  ::opi_api::network::opinetcommon::v1alpha1::HwHandle* _msg = _internal_mutable_vnf_tunnel_hw_handle();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
  return _msg;
}
inline void MappingStatus::set_allocated_vnf_tunnel_hw_handle(::opi_api::network::opinetcommon::v1alpha1::HwHandle* vnf_tunnel_hw_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vnf_tunnel_hw_handle_);
  }
  if (vnf_tunnel_hw_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vnf_tunnel_hw_handle));
    if (message_arena != submessage_arena) {
      vnf_tunnel_hw_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vnf_tunnel_hw_handle, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vnf_tunnel_hw_handle_ = vnf_tunnel_hw_handle;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingStatus.vnf_tunnel_hw_handle)
}

// int32 rewrite_index = 6;
inline void MappingStatus::clear_rewrite_index() {
  _impl_.rewrite_index_ = 0;
}
inline int32_t MappingStatus::_internal_rewrite_index() const {
  return _impl_.rewrite_index_;
}
inline int32_t MappingStatus::rewrite_index() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingStatus.rewrite_index)
  return _internal_rewrite_index();
}
inline void MappingStatus::_internal_set_rewrite_index(int32_t value) {
  
  _impl_.rewrite_index_ = value;
}
inline void MappingStatus::set_rewrite_index(int32_t value) {
  _internal_set_rewrite_index(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingStatus.rewrite_index)
}

// -------------------------------------------------------------------

// L3MappingKey

// string vpc_name_ref = 1;
inline void L3MappingKey::clear_vpc_name_ref() {
  _impl_.vpc_name_ref_.ClearToEmpty();
}
inline const std::string& L3MappingKey::vpc_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_name_ref)
  return _internal_vpc_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L3MappingKey::set_vpc_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vpc_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_name_ref)
}
inline std::string* L3MappingKey::mutable_vpc_name_ref() {
  std::string* _s = _internal_mutable_vpc_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_name_ref)
  return _s;
}
inline const std::string& L3MappingKey::_internal_vpc_name_ref() const {
  return _impl_.vpc_name_ref_.Get();
}
inline void L3MappingKey::_internal_set_vpc_name_ref(const std::string& value) {
  
  _impl_.vpc_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* L3MappingKey::_internal_mutable_vpc_name_ref() {
  
  return _impl_.vpc_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* L3MappingKey::release_vpc_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_name_ref)
  return _impl_.vpc_name_ref_.Release();
}
inline void L3MappingKey::set_allocated_vpc_name_ref(std::string* vpc_name_ref) {
  if (vpc_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.vpc_name_ref_.SetAllocated(vpc_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vpc_name_ref_.IsDefault()) {
    _impl_.vpc_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.vpc_name_ref)
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 2;
inline bool L3MappingKey::_internal_has_ip_address() const {
  return this != internal_default_instance() && _impl_.ip_address_ != nullptr;
}
inline bool L3MappingKey::has_ip_address() const {
  return _internal_has_ip_address();
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& L3MappingKey::_internal_ip_address() const {
  const ::opi_api::network::opinetcommon::v1alpha1::IPAddress* p = _impl_.ip_address_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(
      ::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& L3MappingKey::ip_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
  return _internal_ip_address();
}
inline void L3MappingKey::unsafe_arena_set_allocated_ip_address(
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_address_);
  }
  _impl_.ip_address_ = ip_address;
  if (ip_address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::release_ip_address() {
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.ip_address_;
  _impl_.ip_address_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
  
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.ip_address_;
  _impl_.ip_address_ = nullptr;
  return temp;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::_internal_mutable_ip_address() {
  
  if (_impl_.ip_address_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::network::opinetcommon::v1alpha1::IPAddress>(GetArenaForAllocation());
    _impl_.ip_address_ = p;
  }
  return _impl_.ip_address_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* L3MappingKey::mutable_ip_address() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
  return _msg;
}
inline void L3MappingKey::set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_address_);
  }
  if (ip_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_address));
    if (message_arena != submessage_arena) {
      ip_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip_address, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ip_address_ = ip_address;
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L3MappingKey.ip_address)
}

// -------------------------------------------------------------------

// L2MappingKey

// string subnet_name_ref = 1;
inline void L2MappingKey::clear_subnet_name_ref() {
  _impl_.subnet_name_ref_.ClearToEmpty();
}
inline const std::string& L2MappingKey::subnet_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_name_ref)
  return _internal_subnet_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L2MappingKey::set_subnet_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subnet_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_name_ref)
}
inline std::string* L2MappingKey::mutable_subnet_name_ref() {
  std::string* _s = _internal_mutable_subnet_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_name_ref)
  return _s;
}
inline const std::string& L2MappingKey::_internal_subnet_name_ref() const {
  return _impl_.subnet_name_ref_.Get();
}
inline void L2MappingKey::_internal_set_subnet_name_ref(const std::string& value) {
  
  _impl_.subnet_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* L2MappingKey::_internal_mutable_subnet_name_ref() {
  
  return _impl_.subnet_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* L2MappingKey::release_subnet_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_name_ref)
  return _impl_.subnet_name_ref_.Release();
}
inline void L2MappingKey::set_allocated_subnet_name_ref(std::string* subnet_name_ref) {
  if (subnet_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.subnet_name_ref_.SetAllocated(subnet_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subnet_name_ref_.IsDefault()) {
    _impl_.subnet_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L2MappingKey.subnet_name_ref)
}

// bytes mac_address = 2;
inline void L2MappingKey::clear_mac_address() {
  _impl_.mac_address_.ClearToEmpty();
}
inline const std::string& L2MappingKey::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void L2MappingKey::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_address_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
}
inline std::string* L2MappingKey::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
  return _s;
}
inline const std::string& L2MappingKey::_internal_mac_address() const {
  return _impl_.mac_address_.Get();
}
inline void L2MappingKey::_internal_set_mac_address(const std::string& value) {
  
  _impl_.mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* L2MappingKey::_internal_mutable_mac_address() {
  
  return _impl_.mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* L2MappingKey::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
  return _impl_.mac_address_.Release();
}
inline void L2MappingKey::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  _impl_.mac_address_.SetAllocated(mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_address_.IsDefault()) {
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.L2MappingKey.mac_address)
}

// -------------------------------------------------------------------

// MappingLookupFilter

// bool local = 1;
inline void MappingLookupFilter::clear_local() {
  _impl_.local_ = false;
}
inline bool MappingLookupFilter::_internal_local() const {
  return _impl_.local_;
}
inline bool MappingLookupFilter::local() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.local)
  return _internal_local();
}
inline void MappingLookupFilter::_internal_set_local(bool value) {
  
  _impl_.local_ = value;
}
inline void MappingLookupFilter::set_local(bool value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.local)
}

// .opi_api.network.cloud.v1alpha1.MappingKeyType key_type = 2;
inline void MappingLookupFilter::clear_key_type() {
  _impl_.key_type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MappingKeyType MappingLookupFilter::_internal_key_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MappingKeyType >(_impl_.key_type_);
}
inline ::opi_api::network::cloud::v1alpha1::MappingKeyType MappingLookupFilter::key_type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.key_type)
  return _internal_key_type();
}
inline void MappingLookupFilter::_internal_set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value) {
  
  _impl_.key_type_ = value;
}
inline void MappingLookupFilter::set_key_type(::opi_api::network::cloud::v1alpha1::MappingKeyType value) {
  _internal_set_key_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.key_type)
}

// .opi_api.network.cloud.v1alpha1.MappingType type = 3;
inline void MappingLookupFilter::clear_type() {
  _impl_.type_ = 0;
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingLookupFilter::_internal_type() const {
  return static_cast< ::opi_api::network::cloud::v1alpha1::MappingType >(_impl_.type_);
}
inline ::opi_api::network::cloud::v1alpha1::MappingType MappingLookupFilter::type() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.type)
  return _internal_type();
}
inline void MappingLookupFilter::_internal_set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  
  _impl_.type_ = value;
}
inline void MappingLookupFilter::set_type(::opi_api::network::cloud::v1alpha1::MappingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.type)
}

// .opi_api.network.cloud.v1alpha1.L3MappingKey ip_key = 4;
inline bool MappingLookupFilter::_internal_has_ip_key() const {
  return ip_or_mac_case() == kIpKey;
}
inline bool MappingLookupFilter::has_ip_key() const {
  return _internal_has_ip_key();
}
inline void MappingLookupFilter::set_has_ip_key() {
  _impl_._oneof_case_[0] = kIpKey;
}
inline void MappingLookupFilter::clear_ip_key() {
  if (_internal_has_ip_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ip_or_mac_.ip_key_;
    }
    clear_has_ip_or_mac();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::release_ip_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_ip_or_mac();
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = _impl_.ip_or_mac_.ip_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_or_mac_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingLookupFilter::_internal_ip_key() const {
  return _internal_has_ip_key()
      ? *_impl_.ip_or_mac_.ip_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L3MappingKey&>(::opi_api::network::cloud::v1alpha1::_L3MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L3MappingKey& MappingLookupFilter::ip_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  return _internal_ip_key();
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::unsafe_arena_release_ip_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  if (_internal_has_ip_key()) {
    clear_has_ip_or_mac();
    ::opi_api::network::cloud::v1alpha1::L3MappingKey* temp = _impl_.ip_or_mac_.ip_key_;
    _impl_.ip_or_mac_.ip_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_ip_key(::opi_api::network::cloud::v1alpha1::L3MappingKey* ip_key) {
  clear_ip_or_mac();
  if (ip_key) {
    set_has_ip_key();
    _impl_.ip_or_mac_.ip_key_ = ip_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::_internal_mutable_ip_key() {
  if (!_internal_has_ip_key()) {
    clear_ip_or_mac();
    set_has_ip_key();
    _impl_.ip_or_mac_.ip_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L3MappingKey >(GetArenaForAllocation());
  }
  return _impl_.ip_or_mac_.ip_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L3MappingKey* MappingLookupFilter::mutable_ip_key() {
  ::opi_api::network::cloud::v1alpha1::L3MappingKey* _msg = _internal_mutable_ip_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_key)
  return _msg;
}

// .opi_api.network.cloud.v1alpha1.L2MappingKey mac_key = 5;
inline bool MappingLookupFilter::_internal_has_mac_key() const {
  return ip_or_mac_case() == kMacKey;
}
inline bool MappingLookupFilter::has_mac_key() const {
  return _internal_has_mac_key();
}
inline void MappingLookupFilter::set_has_mac_key() {
  _impl_._oneof_case_[0] = kMacKey;
}
inline void MappingLookupFilter::clear_mac_key() {
  if (_internal_has_mac_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ip_or_mac_.mac_key_;
    }
    clear_has_ip_or_mac();
  }
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::release_mac_key() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_ip_or_mac();
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = _impl_.ip_or_mac_.mac_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_or_mac_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingLookupFilter::_internal_mac_key() const {
  return _internal_has_mac_key()
      ? *_impl_.ip_or_mac_.mac_key_
      : reinterpret_cast< ::opi_api::network::cloud::v1alpha1::L2MappingKey&>(::opi_api::network::cloud::v1alpha1::_L2MappingKey_default_instance_);
}
inline const ::opi_api::network::cloud::v1alpha1::L2MappingKey& MappingLookupFilter::mac_key() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  return _internal_mac_key();
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::unsafe_arena_release_mac_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  if (_internal_has_mac_key()) {
    clear_has_ip_or_mac();
    ::opi_api::network::cloud::v1alpha1::L2MappingKey* temp = _impl_.ip_or_mac_.mac_key_;
    _impl_.ip_or_mac_.mac_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_mac_key(::opi_api::network::cloud::v1alpha1::L2MappingKey* mac_key) {
  clear_ip_or_mac();
  if (mac_key) {
    set_has_mac_key();
    _impl_.ip_or_mac_.mac_key_ = mac_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::_internal_mutable_mac_key() {
  if (!_internal_has_mac_key()) {
    clear_ip_or_mac();
    set_has_mac_key();
    _impl_.ip_or_mac_.mac_key_ = CreateMaybeMessage< ::opi_api::network::cloud::v1alpha1::L2MappingKey >(GetArenaForAllocation());
  }
  return _impl_.ip_or_mac_.mac_key_;
}
inline ::opi_api::network::cloud::v1alpha1::L2MappingKey* MappingLookupFilter::mutable_mac_key() {
  ::opi_api::network::cloud::v1alpha1::L2MappingKey* _msg = _internal_mutable_mac_key();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_key)
  return _msg;
}

// .opi_api.network.opinetcommon.v1alpha1.IPAddress ip_address = 6;
inline bool MappingLookupFilter::_internal_has_ip_address() const {
  return ip_or_mac_case() == kIpAddress;
}
inline bool MappingLookupFilter::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void MappingLookupFilter::set_has_ip_address() {
  _impl_._oneof_case_[0] = kIpAddress;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::release_ip_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  if (_internal_has_ip_address()) {
    clear_has_ip_or_mac();
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.ip_or_mac_.ip_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ip_or_mac_.ip_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingLookupFilter::_internal_ip_address() const {
  return _internal_has_ip_address()
      ? *_impl_.ip_or_mac_.ip_address_
      : reinterpret_cast< ::opi_api::network::opinetcommon::v1alpha1::IPAddress&>(::opi_api::network::opinetcommon::v1alpha1::_IPAddress_default_instance_);
}
inline const ::opi_api::network::opinetcommon::v1alpha1::IPAddress& MappingLookupFilter::ip_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  return _internal_ip_address();
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  if (_internal_has_ip_address()) {
    clear_has_ip_or_mac();
    ::opi_api::network::opinetcommon::v1alpha1::IPAddress* temp = _impl_.ip_or_mac_.ip_address_;
    _impl_.ip_or_mac_.ip_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::unsafe_arena_set_allocated_ip_address(::opi_api::network::opinetcommon::v1alpha1::IPAddress* ip_address) {
  clear_ip_or_mac();
  if (ip_address) {
    set_has_ip_address();
    _impl_.ip_or_mac_.ip_address_ = ip_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::_internal_mutable_ip_address() {
  if (!_internal_has_ip_address()) {
    clear_ip_or_mac();
    set_has_ip_address();
    _impl_.ip_or_mac_.ip_address_ = CreateMaybeMessage< ::opi_api::network::opinetcommon::v1alpha1::IPAddress >(GetArenaForAllocation());
  }
  return _impl_.ip_or_mac_.ip_address_;
}
inline ::opi_api::network::opinetcommon::v1alpha1::IPAddress* MappingLookupFilter::mutable_ip_address() {
  ::opi_api::network::opinetcommon::v1alpha1::IPAddress* _msg = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.ip_address)
  return _msg;
}

// bytes mac_address = 7;
inline bool MappingLookupFilter::_internal_has_mac_address() const {
  return ip_or_mac_case() == kMacAddress;
}
inline bool MappingLookupFilter::has_mac_address() const {
  return _internal_has_mac_address();
}
inline void MappingLookupFilter::set_has_mac_address() {
  _impl_._oneof_case_[0] = kMacAddress;
}
inline void MappingLookupFilter::clear_mac_address() {
  if (_internal_has_mac_address()) {
    _impl_.ip_or_mac_.mac_address_.Destroy();
    clear_has_ip_or_mac();
  }
}
inline const std::string& MappingLookupFilter::mac_address() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline void MappingLookupFilter::set_mac_address(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_mac_address()) {
    clear_ip_or_mac();
    set_has_mac_address();
    _impl_.ip_or_mac_.mac_address_.InitDefault();
  }
  _impl_.ip_or_mac_.mac_address_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
}
inline std::string* MappingLookupFilter::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
  return _s;
}
inline const std::string& MappingLookupFilter::_internal_mac_address() const {
  if (_internal_has_mac_address()) {
    return _impl_.ip_or_mac_.mac_address_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MappingLookupFilter::_internal_set_mac_address(const std::string& value) {
  if (!_internal_has_mac_address()) {
    clear_ip_or_mac();
    set_has_mac_address();
    _impl_.ip_or_mac_.mac_address_.InitDefault();
  }
  _impl_.ip_or_mac_.mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingLookupFilter::_internal_mutable_mac_address() {
  if (!_internal_has_mac_address()) {
    clear_ip_or_mac();
    set_has_mac_address();
    _impl_.ip_or_mac_.mac_address_.InitDefault();
  }
  return _impl_.ip_or_mac_.mac_address_.Mutable(      GetArenaForAllocation());
}
inline std::string* MappingLookupFilter::release_mac_address() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
  if (_internal_has_mac_address()) {
    clear_has_ip_or_mac();
    return _impl_.ip_or_mac_.mac_address_.Release();
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::set_allocated_mac_address(std::string* mac_address) {
  if (has_ip_or_mac()) {
    clear_ip_or_mac();
  }
  if (mac_address != nullptr) {
    set_has_mac_address();
    _impl_.ip_or_mac_.mac_address_.InitAllocated(mac_address, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.mac_address)
}

// string vpc_name_ref = 8;
inline bool MappingLookupFilter::_internal_has_vpc_name_ref() const {
  return ip_or_mac_case() == kVpcNameRef;
}
inline bool MappingLookupFilter::has_vpc_name_ref() const {
  return _internal_has_vpc_name_ref();
}
inline void MappingLookupFilter::set_has_vpc_name_ref() {
  _impl_._oneof_case_[0] = kVpcNameRef;
}
inline void MappingLookupFilter::clear_vpc_name_ref() {
  if (_internal_has_vpc_name_ref()) {
    _impl_.ip_or_mac_.vpc_name_ref_.Destroy();
    clear_has_ip_or_mac();
  }
}
inline const std::string& MappingLookupFilter::vpc_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_name_ref)
  return _internal_vpc_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline void MappingLookupFilter::set_vpc_name_ref(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_vpc_name_ref()) {
    clear_ip_or_mac();
    set_has_vpc_name_ref();
    _impl_.ip_or_mac_.vpc_name_ref_.InitDefault();
  }
  _impl_.ip_or_mac_.vpc_name_ref_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_name_ref)
}
inline std::string* MappingLookupFilter::mutable_vpc_name_ref() {
  std::string* _s = _internal_mutable_vpc_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_name_ref)
  return _s;
}
inline const std::string& MappingLookupFilter::_internal_vpc_name_ref() const {
  if (_internal_has_vpc_name_ref()) {
    return _impl_.ip_or_mac_.vpc_name_ref_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void MappingLookupFilter::_internal_set_vpc_name_ref(const std::string& value) {
  if (!_internal_has_vpc_name_ref()) {
    clear_ip_or_mac();
    set_has_vpc_name_ref();
    _impl_.ip_or_mac_.vpc_name_ref_.InitDefault();
  }
  _impl_.ip_or_mac_.vpc_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* MappingLookupFilter::_internal_mutable_vpc_name_ref() {
  if (!_internal_has_vpc_name_ref()) {
    clear_ip_or_mac();
    set_has_vpc_name_ref();
    _impl_.ip_or_mac_.vpc_name_ref_.InitDefault();
  }
  return _impl_.ip_or_mac_.vpc_name_ref_.Mutable(      GetArenaForAllocation());
}
inline std::string* MappingLookupFilter::release_vpc_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_name_ref)
  if (_internal_has_vpc_name_ref()) {
    clear_has_ip_or_mac();
    return _impl_.ip_or_mac_.vpc_name_ref_.Release();
  } else {
    return nullptr;
  }
}
inline void MappingLookupFilter::set_allocated_vpc_name_ref(std::string* vpc_name_ref) {
  if (has_ip_or_mac()) {
    clear_ip_or_mac();
  }
  if (vpc_name_ref != nullptr) {
    set_has_vpc_name_ref();
    _impl_.ip_or_mac_.vpc_name_ref_.InitAllocated(vpc_name_ref, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:opi_api.network.cloud.v1alpha1.MappingLookupFilter.vpc_name_ref)
}

inline bool MappingLookupFilter::has_ip_or_mac() const {
  return ip_or_mac_case() != IP_OR_MAC_NOT_SET;
}
inline void MappingLookupFilter::clear_has_ip_or_mac() {
  _impl_._oneof_case_[0] = IP_OR_MAC_NOT_SET;
}
inline MappingLookupFilter::IpOrMacCase MappingLookupFilter::ip_or_mac_case() const {
  return MappingLookupFilter::IpOrMacCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha1
}  // namespace cloud
}  // namespace network
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::MappingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::MappingType>() {
  return ::opi_api::network::cloud::v1alpha1::MappingType_descriptor();
}
template <> struct is_proto_enum< ::opi_api::network::cloud::v1alpha1::MappingKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::network::cloud::v1alpha1::MappingKeyType>() {
  return ::opi_api::network::cloud::v1alpha1::MappingKeyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mapping_2eproto
