// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "opicommon.pb.h"
#include "object_key.pb.h"
#include "uuid.pb.h"
#include "google/api/client.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/field_mask.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frontend_5fnvme_5fpcie_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frontend_5fnvme_5fpcie_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class CreateNVMeControllerRequest;
struct CreateNVMeControllerRequestDefaultTypeInternal;
extern CreateNVMeControllerRequestDefaultTypeInternal _CreateNVMeControllerRequest_default_instance_;
class CreateNVMeNamespaceRequest;
struct CreateNVMeNamespaceRequestDefaultTypeInternal;
extern CreateNVMeNamespaceRequestDefaultTypeInternal _CreateNVMeNamespaceRequest_default_instance_;
class CreateNVMeSubsystemRequest;
struct CreateNVMeSubsystemRequestDefaultTypeInternal;
extern CreateNVMeSubsystemRequestDefaultTypeInternal _CreateNVMeSubsystemRequest_default_instance_;
class DeleteNVMeControllerRequest;
struct DeleteNVMeControllerRequestDefaultTypeInternal;
extern DeleteNVMeControllerRequestDefaultTypeInternal _DeleteNVMeControllerRequest_default_instance_;
class DeleteNVMeNamespaceRequest;
struct DeleteNVMeNamespaceRequestDefaultTypeInternal;
extern DeleteNVMeNamespaceRequestDefaultTypeInternal _DeleteNVMeNamespaceRequest_default_instance_;
class DeleteNVMeSubsystemRequest;
struct DeleteNVMeSubsystemRequestDefaultTypeInternal;
extern DeleteNVMeSubsystemRequestDefaultTypeInternal _DeleteNVMeSubsystemRequest_default_instance_;
class GetNVMeControllerRequest;
struct GetNVMeControllerRequestDefaultTypeInternal;
extern GetNVMeControllerRequestDefaultTypeInternal _GetNVMeControllerRequest_default_instance_;
class GetNVMeNamespaceRequest;
struct GetNVMeNamespaceRequestDefaultTypeInternal;
extern GetNVMeNamespaceRequestDefaultTypeInternal _GetNVMeNamespaceRequest_default_instance_;
class GetNVMeSubsystemRequest;
struct GetNVMeSubsystemRequestDefaultTypeInternal;
extern GetNVMeSubsystemRequestDefaultTypeInternal _GetNVMeSubsystemRequest_default_instance_;
class ListNVMeControllersRequest;
struct ListNVMeControllersRequestDefaultTypeInternal;
extern ListNVMeControllersRequestDefaultTypeInternal _ListNVMeControllersRequest_default_instance_;
class ListNVMeControllersResponse;
struct ListNVMeControllersResponseDefaultTypeInternal;
extern ListNVMeControllersResponseDefaultTypeInternal _ListNVMeControllersResponse_default_instance_;
class ListNVMeNamespacesRequest;
struct ListNVMeNamespacesRequestDefaultTypeInternal;
extern ListNVMeNamespacesRequestDefaultTypeInternal _ListNVMeNamespacesRequest_default_instance_;
class ListNVMeNamespacesResponse;
struct ListNVMeNamespacesResponseDefaultTypeInternal;
extern ListNVMeNamespacesResponseDefaultTypeInternal _ListNVMeNamespacesResponse_default_instance_;
class ListNVMeSubsystemsRequest;
struct ListNVMeSubsystemsRequestDefaultTypeInternal;
extern ListNVMeSubsystemsRequestDefaultTypeInternal _ListNVMeSubsystemsRequest_default_instance_;
class ListNVMeSubsystemsResponse;
struct ListNVMeSubsystemsResponseDefaultTypeInternal;
extern ListNVMeSubsystemsResponseDefaultTypeInternal _ListNVMeSubsystemsResponse_default_instance_;
class NVMeController;
struct NVMeControllerDefaultTypeInternal;
extern NVMeControllerDefaultTypeInternal _NVMeController_default_instance_;
class NVMeControllerSpec;
struct NVMeControllerSpecDefaultTypeInternal;
extern NVMeControllerSpecDefaultTypeInternal _NVMeControllerSpec_default_instance_;
class NVMeControllerStatsRequest;
struct NVMeControllerStatsRequestDefaultTypeInternal;
extern NVMeControllerStatsRequestDefaultTypeInternal _NVMeControllerStatsRequest_default_instance_;
class NVMeControllerStatsResponse;
struct NVMeControllerStatsResponseDefaultTypeInternal;
extern NVMeControllerStatsResponseDefaultTypeInternal _NVMeControllerStatsResponse_default_instance_;
class NVMeControllerStatus;
struct NVMeControllerStatusDefaultTypeInternal;
extern NVMeControllerStatusDefaultTypeInternal _NVMeControllerStatus_default_instance_;
class NVMeNamespace;
struct NVMeNamespaceDefaultTypeInternal;
extern NVMeNamespaceDefaultTypeInternal _NVMeNamespace_default_instance_;
class NVMeNamespaceSpec;
struct NVMeNamespaceSpecDefaultTypeInternal;
extern NVMeNamespaceSpecDefaultTypeInternal _NVMeNamespaceSpec_default_instance_;
class NVMeNamespaceStatsRequest;
struct NVMeNamespaceStatsRequestDefaultTypeInternal;
extern NVMeNamespaceStatsRequestDefaultTypeInternal _NVMeNamespaceStatsRequest_default_instance_;
class NVMeNamespaceStatsResponse;
struct NVMeNamespaceStatsResponseDefaultTypeInternal;
extern NVMeNamespaceStatsResponseDefaultTypeInternal _NVMeNamespaceStatsResponse_default_instance_;
class NVMeNamespaceStatus;
struct NVMeNamespaceStatusDefaultTypeInternal;
extern NVMeNamespaceStatusDefaultTypeInternal _NVMeNamespaceStatus_default_instance_;
class NVMeSubsystem;
struct NVMeSubsystemDefaultTypeInternal;
extern NVMeSubsystemDefaultTypeInternal _NVMeSubsystem_default_instance_;
class NVMeSubsystemSpec;
struct NVMeSubsystemSpecDefaultTypeInternal;
extern NVMeSubsystemSpecDefaultTypeInternal _NVMeSubsystemSpec_default_instance_;
class NVMeSubsystemStatsRequest;
struct NVMeSubsystemStatsRequestDefaultTypeInternal;
extern NVMeSubsystemStatsRequestDefaultTypeInternal _NVMeSubsystemStatsRequest_default_instance_;
class NVMeSubsystemStatsResponse;
struct NVMeSubsystemStatsResponseDefaultTypeInternal;
extern NVMeSubsystemStatsResponseDefaultTypeInternal _NVMeSubsystemStatsResponse_default_instance_;
class NVMeSubsystemStatus;
struct NVMeSubsystemStatusDefaultTypeInternal;
extern NVMeSubsystemStatusDefaultTypeInternal _NVMeSubsystemStatus_default_instance_;
class UpdateNVMeControllerRequest;
struct UpdateNVMeControllerRequestDefaultTypeInternal;
extern UpdateNVMeControllerRequestDefaultTypeInternal _UpdateNVMeControllerRequest_default_instance_;
class UpdateNVMeNamespaceRequest;
struct UpdateNVMeNamespaceRequestDefaultTypeInternal;
extern UpdateNVMeNamespaceRequestDefaultTypeInternal _UpdateNVMeNamespaceRequest_default_instance_;
class UpdateNVMeSubsystemRequest;
struct UpdateNVMeSubsystemRequestDefaultTypeInternal;
extern UpdateNVMeSubsystemRequestDefaultTypeInternal _UpdateNVMeSubsystemRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::CreateNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNVMeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeControllersRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeControllersRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeControllersResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeControllersResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeNamespacesRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeNamespacesRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeNamespacesResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeNamespacesResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeSubsystemsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeSubsystemsRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNVMeSubsystemsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNVMeSubsystemsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeController* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerSpec>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeControllerStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatus>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespace* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceSpec>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeNamespaceStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatus>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystem* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemSpec>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatsRequest>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatsResponse>(Arena*);
template<> ::opi_api::storage::v1::NVMeSubsystemStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatus>(Arena*);
template<> ::opi_api::storage::v1::UpdateNVMeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNVMeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNVMeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNVMeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNVMeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNVMeSubsystemRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

enum NVMeNamespacePciState : int {
  NV_ME_NAMESPACE_PCI_STATE_UNSPECIFIED = 0,
  NVME_NAMESPACE_PCI_STATE_DISABLED = 1,
  NVME_NAMESPACE_PCI_STATE_ENABLED = 2,
  NVME_NAMESPACE_PCI_STATE_DELETING = 3,
  NVMeNamespacePciState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NVMeNamespacePciState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NVMeNamespacePciState_IsValid(int value);
constexpr NVMeNamespacePciState NVMeNamespacePciState_MIN = NV_ME_NAMESPACE_PCI_STATE_UNSPECIFIED;
constexpr NVMeNamespacePciState NVMeNamespacePciState_MAX = NVME_NAMESPACE_PCI_STATE_DELETING;
constexpr int NVMeNamespacePciState_ARRAYSIZE = NVMeNamespacePciState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciState_descriptor();
template<typename T>
inline const std::string& NVMeNamespacePciState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NVMeNamespacePciState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NVMeNamespacePciState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NVMeNamespacePciState_descriptor(), enum_t_value);
}
inline bool NVMeNamespacePciState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NVMeNamespacePciState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NVMeNamespacePciState>(
    NVMeNamespacePciState_descriptor(), name, value);
}
enum NVMeNamespacePciOperState : int {
  NV_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED = 0,
  NVME_NAMESPACE_PCI_OPER_STATE_ONLINE = 1,
  NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE = 2,
  NVMeNamespacePciOperState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NVMeNamespacePciOperState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NVMeNamespacePciOperState_IsValid(int value);
constexpr NVMeNamespacePciOperState NVMeNamespacePciOperState_MIN = NV_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED;
constexpr NVMeNamespacePciOperState NVMeNamespacePciOperState_MAX = NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE;
constexpr int NVMeNamespacePciOperState_ARRAYSIZE = NVMeNamespacePciOperState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NVMeNamespacePciOperState_descriptor();
template<typename T>
inline const std::string& NVMeNamespacePciOperState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NVMeNamespacePciOperState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NVMeNamespacePciOperState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NVMeNamespacePciOperState_descriptor(), enum_t_value);
}
inline bool NVMeNamespacePciOperState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NVMeNamespacePciOperState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NVMeNamespacePciOperState>(
    NVMeNamespacePciOperState_descriptor(), name, value);
}
// ===================================================================

class NVMeSubsystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystem) */ {
 public:
  inline NVMeSubsystem() : NVMeSubsystem(nullptr) {}
  ~NVMeSubsystem() override;
  explicit constexpr NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystem(const NVMeSubsystem& from);
  NVMeSubsystem(NVMeSubsystem&& from) noexcept
    : NVMeSubsystem() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystem& operator=(const NVMeSubsystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystem& operator=(NVMeSubsystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystem* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystem*>(
               &_NVMeSubsystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NVMeSubsystem& a, NVMeSubsystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystem";
  }
  protected:
  explicit NVMeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NVMeSubsystemSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystemSpec* release_spec();
  ::opi_api::storage::v1::NVMeSubsystemSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NVMeSubsystemSpec* spec);
  private:
  const ::opi_api::storage::v1::NVMeSubsystemSpec& _internal_spec() const;
  ::opi_api::storage::v1::NVMeSubsystemSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NVMeSubsystemSpec* spec);
  ::opi_api::storage::v1::NVMeSubsystemSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NVMeSubsystemStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystemStatus* release_status();
  ::opi_api::storage::v1::NVMeSubsystemStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NVMeSubsystemStatus* status);
  private:
  const ::opi_api::storage::v1::NVMeSubsystemStatus& _internal_status() const;
  ::opi_api::storage::v1::NVMeSubsystemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NVMeSubsystemStatus* status);
  ::opi_api::storage::v1::NVMeSubsystemStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystemSpec* spec_;
  ::opi_api::storage::v1::NVMeSubsystemStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemSpec) */ {
 public:
  inline NVMeSubsystemSpec() : NVMeSubsystemSpec(nullptr) {}
  ~NVMeSubsystemSpec() override;
  explicit constexpr NVMeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemSpec(const NVMeSubsystemSpec& from);
  NVMeSubsystemSpec(NVMeSubsystemSpec&& from) noexcept
    : NVMeSubsystemSpec() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemSpec& operator=(const NVMeSubsystemSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemSpec& operator=(NVMeSubsystemSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemSpec* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemSpec*>(
               &_NVMeSubsystemSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NVMeSubsystemSpec& a, NVMeSubsystemSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemSpec";
  }
  protected:
  explicit NVMeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNqnFieldNumber = 2,
    kSerialNumberFieldNumber = 3,
    kModelNumberFieldNumber = 4,
    kIdFieldNumber = 1,
    kMaxNamespacesFieldNumber = 5,
  };
  // string nqn = 2;
  void clear_nqn();
  const std::string& nqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nqn();
  PROTOBUF_NODISCARD std::string* release_nqn();
  void set_allocated_nqn(std::string* nqn);
  private:
  const std::string& _internal_nqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nqn(const std::string& value);
  std::string* _internal_mutable_nqn();
  public:

  // string serial_number = 3;
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string model_number = 4;
  void clear_model_number();
  const std::string& model_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_number();
  PROTOBUF_NODISCARD std::string* release_model_number();
  void set_allocated_model_number(std::string* model_number);
  private:
  const std::string& _internal_model_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_number(const std::string& value);
  std::string* _internal_mutable_model_number();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // int64 max_namespaces = 5;
  void clear_max_namespaces();
  int64_t max_namespaces() const;
  void set_max_namespaces(int64_t value);
  private:
  int64_t _internal_max_namespaces() const;
  void _internal_set_max_namespaces(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nqn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_number_;
  ::opi_api::common::v1::ObjectKey* id_;
  int64_t max_namespaces_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatus) */ {
 public:
  inline NVMeSubsystemStatus() : NVMeSubsystemStatus(nullptr) {}
  ~NVMeSubsystemStatus() override;
  explicit constexpr NVMeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatus(const NVMeSubsystemStatus& from);
  NVMeSubsystemStatus(NVMeSubsystemStatus&& from) noexcept
    : NVMeSubsystemStatus() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatus& operator=(const NVMeSubsystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatus& operator=(NVMeSubsystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatus* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatus*>(
               &_NVMeSubsystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NVMeSubsystemStatus& a, NVMeSubsystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatus";
  }
  protected:
  explicit NVMeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareRevisionFieldNumber = 1,
    kFruGuidFieldNumber = 2,
  };
  // string firmware_revision = 1;
  void clear_firmware_revision();
  const std::string& firmware_revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_revision();
  PROTOBUF_NODISCARD std::string* release_firmware_revision();
  void set_allocated_firmware_revision(std::string* firmware_revision);
  private:
  const std::string& _internal_firmware_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_revision(const std::string& value);
  std::string* _internal_mutable_firmware_revision();
  public:

  // bytes fru_guid = 2;
  void clear_fru_guid();
  const std::string& fru_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fru_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fru_guid();
  PROTOBUF_NODISCARD std::string* release_fru_guid();
  void set_allocated_fru_guid(std::string* fru_guid);
  private:
  const std::string& _internal_fru_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fru_guid(const std::string& value);
  std::string* _internal_mutable_fru_guid();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fru_guid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeController) */ {
 public:
  inline NVMeController() : NVMeController(nullptr) {}
  ~NVMeController() override;
  explicit constexpr NVMeController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeController(const NVMeController& from);
  NVMeController(NVMeController&& from) noexcept
    : NVMeController() {
    *this = ::std::move(from);
  }

  inline NVMeController& operator=(const NVMeController& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeController& operator=(NVMeController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeController& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeController* internal_default_instance() {
    return reinterpret_cast<const NVMeController*>(
               &_NVMeController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NVMeController& a, NVMeController& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeController& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeController";
  }
  protected:
  explicit NVMeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeControllerSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NVMeControllerSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeControllerSpec* release_spec();
  ::opi_api::storage::v1::NVMeControllerSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NVMeControllerSpec* spec);
  private:
  const ::opi_api::storage::v1::NVMeControllerSpec& _internal_spec() const;
  ::opi_api::storage::v1::NVMeControllerSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NVMeControllerSpec* spec);
  ::opi_api::storage::v1::NVMeControllerSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NVMeControllerStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NVMeControllerStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeControllerStatus* release_status();
  ::opi_api::storage::v1::NVMeControllerStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NVMeControllerStatus* status);
  private:
  const ::opi_api::storage::v1::NVMeControllerStatus& _internal_status() const;
  ::opi_api::storage::v1::NVMeControllerStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NVMeControllerStatus* status);
  ::opi_api::storage::v1::NVMeControllerStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeControllerSpec* spec_;
  ::opi_api::storage::v1::NVMeControllerStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerSpec) */ {
 public:
  inline NVMeControllerSpec() : NVMeControllerSpec(nullptr) {}
  ~NVMeControllerSpec() override;
  explicit constexpr NVMeControllerSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerSpec(const NVMeControllerSpec& from);
  NVMeControllerSpec(NVMeControllerSpec&& from) noexcept
    : NVMeControllerSpec() {
    *this = ::std::move(from);
  }

  inline NVMeControllerSpec& operator=(const NVMeControllerSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerSpec& operator=(NVMeControllerSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerSpec* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerSpec*>(
               &_NVMeControllerSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NVMeControllerSpec& a, NVMeControllerSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerSpec";
  }
  protected:
  explicit NVMeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSubsystemIdFieldNumber = 3,
    kPcieIdFieldNumber = 4,
    kNvmeControllerIdFieldNumber = 2,
    kMaxNsqFieldNumber = 5,
    kMaxNcqFieldNumber = 6,
    kSqesFieldNumber = 7,
    kCqesFieldNumber = 8,
    kMaxNamespacesFieldNumber = 9,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subsystem_id = 3;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.storage.v1.PciEndpoint pcie_id = 4;
  bool has_pcie_id() const;
  private:
  bool _internal_has_pcie_id() const;
  public:
  void clear_pcie_id();
  const ::opi_api::storage::v1::PciEndpoint& pcie_id() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::PciEndpoint* release_pcie_id();
  ::opi_api::storage::v1::PciEndpoint* mutable_pcie_id();
  void set_allocated_pcie_id(::opi_api::storage::v1::PciEndpoint* pcie_id);
  private:
  const ::opi_api::storage::v1::PciEndpoint& _internal_pcie_id() const;
  ::opi_api::storage::v1::PciEndpoint* _internal_mutable_pcie_id();
  public:
  void unsafe_arena_set_allocated_pcie_id(
      ::opi_api::storage::v1::PciEndpoint* pcie_id);
  ::opi_api::storage::v1::PciEndpoint* unsafe_arena_release_pcie_id();

  // int32 nvme_controller_id = 2;
  void clear_nvme_controller_id();
  int32_t nvme_controller_id() const;
  void set_nvme_controller_id(int32_t value);
  private:
  int32_t _internal_nvme_controller_id() const;
  void _internal_set_nvme_controller_id(int32_t value);
  public:

  // int32 max_nsq = 5;
  void clear_max_nsq();
  int32_t max_nsq() const;
  void set_max_nsq(int32_t value);
  private:
  int32_t _internal_max_nsq() const;
  void _internal_set_max_nsq(int32_t value);
  public:

  // int32 max_ncq = 6;
  void clear_max_ncq();
  int32_t max_ncq() const;
  void set_max_ncq(int32_t value);
  private:
  int32_t _internal_max_ncq() const;
  void _internal_set_max_ncq(int32_t value);
  public:

  // int32 sqes = 7;
  void clear_sqes();
  int32_t sqes() const;
  void set_sqes(int32_t value);
  private:
  int32_t _internal_sqes() const;
  void _internal_set_sqes(int32_t value);
  public:

  // int32 cqes = 8;
  void clear_cqes();
  int32_t cqes() const;
  void set_cqes(int32_t value);
  private:
  int32_t _internal_cqes() const;
  void _internal_set_cqes(int32_t value);
  public:

  // int32 max_namespaces = 9;
  void clear_max_namespaces();
  int32_t max_namespaces() const;
  void set_max_namespaces(int32_t value);
  private:
  int32_t _internal_max_namespaces() const;
  void _internal_set_max_namespaces(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::storage::v1::PciEndpoint* pcie_id_;
  int32_t nvme_controller_id_;
  int32_t max_nsq_;
  int32_t max_ncq_;
  int32_t sqes_;
  int32_t cqes_;
  int32_t max_namespaces_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatus) */ {
 public:
  inline NVMeControllerStatus() : NVMeControllerStatus(nullptr) {}
  ~NVMeControllerStatus() override;
  explicit constexpr NVMeControllerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatus(const NVMeControllerStatus& from);
  NVMeControllerStatus(NVMeControllerStatus&& from) noexcept
    : NVMeControllerStatus() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatus& operator=(const NVMeControllerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatus& operator=(NVMeControllerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatus* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatus*>(
               &_NVMeControllerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NVMeControllerStatus& a, NVMeControllerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatus";
  }
  protected:
  explicit NVMeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveFieldNumber = 1,
  };
  // bool active = 1;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespace) */ {
 public:
  inline NVMeNamespace() : NVMeNamespace(nullptr) {}
  ~NVMeNamespace() override;
  explicit constexpr NVMeNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespace(const NVMeNamespace& from);
  NVMeNamespace(NVMeNamespace&& from) noexcept
    : NVMeNamespace() {
    *this = ::std::move(from);
  }

  inline NVMeNamespace& operator=(const NVMeNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespace& operator=(NVMeNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespace* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespace*>(
               &_NVMeNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NVMeNamespace& a, NVMeNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespace";
  }
  protected:
  explicit NVMeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NVMeNamespaceSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespaceSpec* release_spec();
  ::opi_api::storage::v1::NVMeNamespaceSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NVMeNamespaceSpec* spec);
  private:
  const ::opi_api::storage::v1::NVMeNamespaceSpec& _internal_spec() const;
  ::opi_api::storage::v1::NVMeNamespaceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NVMeNamespaceSpec* spec);
  ::opi_api::storage::v1::NVMeNamespaceSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NVMeNamespaceStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespaceStatus* release_status();
  ::opi_api::storage::v1::NVMeNamespaceStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NVMeNamespaceStatus* status);
  private:
  const ::opi_api::storage::v1::NVMeNamespaceStatus& _internal_status() const;
  ::opi_api::storage::v1::NVMeNamespaceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NVMeNamespaceStatus* status);
  ::opi_api::storage::v1::NVMeNamespaceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespaceSpec* spec_;
  ::opi_api::storage::v1::NVMeNamespaceStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceSpec) */ {
 public:
  inline NVMeNamespaceSpec() : NVMeNamespaceSpec(nullptr) {}
  ~NVMeNamespaceSpec() override;
  explicit constexpr NVMeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceSpec(const NVMeNamespaceSpec& from);
  NVMeNamespaceSpec(NVMeNamespaceSpec&& from) noexcept
    : NVMeNamespaceSpec() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceSpec& operator=(const NVMeNamespaceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceSpec& operator=(NVMeNamespaceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceSpec* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceSpec*>(
               &_NVMeNamespaceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NVMeNamespaceSpec& a, NVMeNamespaceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceSpec";
  }
  protected:
  explicit NVMeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNguidFieldNumber = 7,
    kIdFieldNumber = 1,
    kSubsystemIdFieldNumber = 2,
    kUuidFieldNumber = 9,
    kVolumeIdFieldNumber = 10,
    kEui64FieldNumber = 8,
    kHostNsidFieldNumber = 4,
  };
  // string nguid = 7;
  void clear_nguid();
  const std::string& nguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nguid();
  PROTOBUF_NODISCARD std::string* release_nguid();
  void set_allocated_nguid(std::string* nguid);
  private:
  const std::string& _internal_nguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nguid(const std::string& value);
  std::string* _internal_mutable_nguid();
  public:

  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.common.v1.ObjectKey subsystem_id = 2;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // .opi_api.common.v1.Uuid uuid = 9;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::opi_api::common::v1::Uuid& uuid() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::Uuid* release_uuid();
  ::opi_api::common::v1::Uuid* mutable_uuid();
  void set_allocated_uuid(::opi_api::common::v1::Uuid* uuid);
  private:
  const ::opi_api::common::v1::Uuid& _internal_uuid() const;
  ::opi_api::common::v1::Uuid* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::opi_api::common::v1::Uuid* uuid);
  ::opi_api::common::v1::Uuid* unsafe_arena_release_uuid();

  // .opi_api.common.v1.ObjectKey volume_id = 10;
  bool has_volume_id() const;
  private:
  bool _internal_has_volume_id() const;
  public:
  void clear_volume_id();
  const ::opi_api::common::v1::ObjectKey& volume_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_volume_id();
  ::opi_api::common::v1::ObjectKey* mutable_volume_id();
  void set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_volume_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_volume_id();
  public:
  void unsafe_arena_set_allocated_volume_id(
      ::opi_api::common::v1::ObjectKey* volume_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_volume_id();

  // int64 eui64 = 8;
  void clear_eui64();
  int64_t eui64() const;
  void set_eui64(int64_t value);
  private:
  int64_t _internal_eui64() const;
  void _internal_set_eui64(int64_t value);
  public:

  // int32 host_nsid = 4;
  void clear_host_nsid();
  int32_t host_nsid() const;
  void set_host_nsid(int32_t value);
  private:
  int32_t _internal_host_nsid() const;
  void _internal_set_host_nsid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nguid_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  ::opi_api::common::v1::Uuid* uuid_;
  ::opi_api::common::v1::ObjectKey* volume_id_;
  int64_t eui64_;
  int32_t host_nsid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatus) */ {
 public:
  inline NVMeNamespaceStatus() : NVMeNamespaceStatus(nullptr) {}
  ~NVMeNamespaceStatus() override;
  explicit constexpr NVMeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatus(const NVMeNamespaceStatus& from);
  NVMeNamespaceStatus(NVMeNamespaceStatus&& from) noexcept
    : NVMeNamespaceStatus() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatus& operator=(const NVMeNamespaceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatus& operator=(NVMeNamespaceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatus* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatus*>(
               &_NVMeNamespaceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NVMeNamespaceStatus& a, NVMeNamespaceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatus";
  }
  protected:
  explicit NVMeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPciStateFieldNumber = 1,
    kPciOperStateFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
  void clear_pci_state();
  ::opi_api::storage::v1::NVMeNamespacePciState pci_state() const;
  void set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value);
  private:
  ::opi_api::storage::v1::NVMeNamespacePciState _internal_pci_state() const;
  void _internal_set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value);
  public:

  // .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
  void clear_pci_oper_state();
  ::opi_api::storage::v1::NVMeNamespacePciOperState pci_oper_state() const;
  void set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value);
  private:
  ::opi_api::storage::v1::NVMeNamespacePciOperState _internal_pci_oper_state() const;
  void _internal_set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int pci_state_;
  int pci_oper_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class CreateNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNVMeSubsystemRequest) */ {
 public:
  inline CreateNVMeSubsystemRequest() : CreateNVMeSubsystemRequest(nullptr) {}
  ~CreateNVMeSubsystemRequest() override;
  explicit constexpr CreateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNVMeSubsystemRequest(const CreateNVMeSubsystemRequest& from);
  CreateNVMeSubsystemRequest(CreateNVMeSubsystemRequest&& from) noexcept
    : CreateNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline CreateNVMeSubsystemRequest& operator=(const CreateNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNVMeSubsystemRequest& operator=(CreateNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNVMeSubsystemRequest*>(
               &_CreateNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateNVMeSubsystemRequest& a, CreateNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNVMeSubsystemRequest";
  }
  protected:
  explicit CreateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kNvMeSubsystemIdFieldNumber = 3,
    kNvMeSubsystemFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string nv_me_subsystem_id = 3;
  void clear_nv_me_subsystem_id();
  const std::string& nv_me_subsystem_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nv_me_subsystem_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nv_me_subsystem_id();
  PROTOBUF_NODISCARD std::string* release_nv_me_subsystem_id();
  void set_allocated_nv_me_subsystem_id(std::string* nv_me_subsystem_id);
  private:
  const std::string& _internal_nv_me_subsystem_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nv_me_subsystem_id(const std::string& value);
  std::string* _internal_mutable_nv_me_subsystem_id();
  public:

  // .opi_api.storage.v1.NVMeSubsystem nv_me_subsystem = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_nv_me_subsystem() const;
  private:
  bool _internal_has_nv_me_subsystem() const;
  public:
  void clear_nv_me_subsystem();
  const ::opi_api::storage::v1::NVMeSubsystem& nv_me_subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystem* release_nv_me_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_nv_me_subsystem();
  void set_allocated_nv_me_subsystem(::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem);
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_nv_me_subsystem() const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_mutable_nv_me_subsystem();
  public:
  void unsafe_arena_set_allocated_nv_me_subsystem(
      ::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem);
  ::opi_api::storage::v1::NVMeSubsystem* unsafe_arena_release_nv_me_subsystem();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nv_me_subsystem_id_;
  ::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class DeleteNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNVMeSubsystemRequest) */ {
 public:
  inline DeleteNVMeSubsystemRequest() : DeleteNVMeSubsystemRequest(nullptr) {}
  ~DeleteNVMeSubsystemRequest() override;
  explicit constexpr DeleteNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNVMeSubsystemRequest(const DeleteNVMeSubsystemRequest& from);
  DeleteNVMeSubsystemRequest(DeleteNVMeSubsystemRequest&& from) noexcept
    : DeleteNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNVMeSubsystemRequest& operator=(const DeleteNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNVMeSubsystemRequest& operator=(DeleteNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNVMeSubsystemRequest*>(
               &_DeleteNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteNVMeSubsystemRequest& a, DeleteNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNVMeSubsystemRequest";
  }
  protected:
  explicit DeleteNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class UpdateNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNVMeSubsystemRequest) */ {
 public:
  inline UpdateNVMeSubsystemRequest() : UpdateNVMeSubsystemRequest(nullptr) {}
  ~UpdateNVMeSubsystemRequest() override;
  explicit constexpr UpdateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNVMeSubsystemRequest(const UpdateNVMeSubsystemRequest& from);
  UpdateNVMeSubsystemRequest(UpdateNVMeSubsystemRequest&& from) noexcept
    : UpdateNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNVMeSubsystemRequest& operator=(const UpdateNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNVMeSubsystemRequest& operator=(UpdateNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNVMeSubsystemRequest*>(
               &_UpdateNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateNVMeSubsystemRequest& a, UpdateNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNVMeSubsystemRequest";
  }
  protected:
  explicit UpdateNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvMeSubsystemFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeSubsystem nv_me_subsystem = 1;
  bool has_nv_me_subsystem() const;
  private:
  bool _internal_has_nv_me_subsystem() const;
  public:
  void clear_nv_me_subsystem();
  const ::opi_api::storage::v1::NVMeSubsystem& nv_me_subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeSubsystem* release_nv_me_subsystem();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_nv_me_subsystem();
  void set_allocated_nv_me_subsystem(::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem);
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_nv_me_subsystem() const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_mutable_nv_me_subsystem();
  public:
  void unsafe_arena_set_allocated_nv_me_subsystem(
      ::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem);
  ::opi_api::storage::v1::NVMeSubsystem* unsafe_arena_release_nv_me_subsystem();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem_;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeSubsystemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeSubsystemsRequest) */ {
 public:
  inline ListNVMeSubsystemsRequest() : ListNVMeSubsystemsRequest(nullptr) {}
  ~ListNVMeSubsystemsRequest() override;
  explicit constexpr ListNVMeSubsystemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeSubsystemsRequest(const ListNVMeSubsystemsRequest& from);
  ListNVMeSubsystemsRequest(ListNVMeSubsystemsRequest&& from) noexcept
    : ListNVMeSubsystemsRequest() {
    *this = ::std::move(from);
  }

  inline ListNVMeSubsystemsRequest& operator=(const ListNVMeSubsystemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeSubsystemsRequest& operator=(ListNVMeSubsystemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeSubsystemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeSubsystemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListNVMeSubsystemsRequest*>(
               &_ListNVMeSubsystemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListNVMeSubsystemsRequest& a, ListNVMeSubsystemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeSubsystemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeSubsystemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeSubsystemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeSubsystemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeSubsystemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeSubsystemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeSubsystemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeSubsystemsRequest";
  }
  protected:
  explicit ListNVMeSubsystemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeSubsystemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeSubsystemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeSubsystemsResponse) */ {
 public:
  inline ListNVMeSubsystemsResponse() : ListNVMeSubsystemsResponse(nullptr) {}
  ~ListNVMeSubsystemsResponse() override;
  explicit constexpr ListNVMeSubsystemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeSubsystemsResponse(const ListNVMeSubsystemsResponse& from);
  ListNVMeSubsystemsResponse(ListNVMeSubsystemsResponse&& from) noexcept
    : ListNVMeSubsystemsResponse() {
    *this = ::std::move(from);
  }

  inline ListNVMeSubsystemsResponse& operator=(const ListNVMeSubsystemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeSubsystemsResponse& operator=(ListNVMeSubsystemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeSubsystemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeSubsystemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListNVMeSubsystemsResponse*>(
               &_ListNVMeSubsystemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListNVMeSubsystemsResponse& a, ListNVMeSubsystemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeSubsystemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeSubsystemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeSubsystemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeSubsystemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeSubsystemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeSubsystemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeSubsystemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeSubsystemsResponse";
  }
  protected:
  explicit ListNVMeSubsystemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvMeSubsystemsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NVMeSubsystem nv_me_subsystems = 1;
  int nv_me_subsystems_size() const;
  private:
  int _internal_nv_me_subsystems_size() const;
  public:
  void clear_nv_me_subsystems();
  ::opi_api::storage::v1::NVMeSubsystem* mutable_nv_me_subsystems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >*
      mutable_nv_me_subsystems();
  private:
  const ::opi_api::storage::v1::NVMeSubsystem& _internal_nv_me_subsystems(int index) const;
  ::opi_api::storage::v1::NVMeSubsystem* _internal_add_nv_me_subsystems();
  public:
  const ::opi_api::storage::v1::NVMeSubsystem& nv_me_subsystems(int index) const;
  ::opi_api::storage::v1::NVMeSubsystem* add_nv_me_subsystems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >&
      nv_me_subsystems() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeSubsystemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem > nv_me_subsystems_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class GetNVMeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNVMeSubsystemRequest) */ {
 public:
  inline GetNVMeSubsystemRequest() : GetNVMeSubsystemRequest(nullptr) {}
  ~GetNVMeSubsystemRequest() override;
  explicit constexpr GetNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNVMeSubsystemRequest(const GetNVMeSubsystemRequest& from);
  GetNVMeSubsystemRequest(GetNVMeSubsystemRequest&& from) noexcept
    : GetNVMeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline GetNVMeSubsystemRequest& operator=(const GetNVMeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNVMeSubsystemRequest& operator=(GetNVMeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNVMeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNVMeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const GetNVMeSubsystemRequest*>(
               &_GetNVMeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetNVMeSubsystemRequest& a, GetNVMeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNVMeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNVMeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNVMeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNVMeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNVMeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNVMeSubsystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNVMeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNVMeSubsystemRequest";
  }
  protected:
  explicit GetNVMeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNVMeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatsRequest) */ {
 public:
  inline NVMeSubsystemStatsRequest() : NVMeSubsystemStatsRequest(nullptr) {}
  ~NVMeSubsystemStatsRequest() override;
  explicit constexpr NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatsRequest(const NVMeSubsystemStatsRequest& from);
  NVMeSubsystemStatsRequest(NVMeSubsystemStatsRequest&& from) noexcept
    : NVMeSubsystemStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatsRequest& operator=(const NVMeSubsystemStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatsRequest& operator=(NVMeSubsystemStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatsRequest*>(
               &_NVMeSubsystemStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(NVMeSubsystemStatsRequest& a, NVMeSubsystemStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatsRequest";
  }
  protected:
  explicit NVMeSubsystemStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubsystemIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey subsystem_id = 1;
  bool has_subsystem_id() const;
  private:
  bool _internal_has_subsystem_id() const;
  public:
  void clear_subsystem_id();
  const ::opi_api::common::v1::ObjectKey& subsystem_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_subsystem_id();
  ::opi_api::common::v1::ObjectKey* mutable_subsystem_id();
  void set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_subsystem_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_subsystem_id();
  public:
  void unsafe_arena_set_allocated_subsystem_id(
      ::opi_api::common::v1::ObjectKey* subsystem_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_subsystem_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* subsystem_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeSubsystemStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeSubsystemStatsResponse) */ {
 public:
  inline NVMeSubsystemStatsResponse() : NVMeSubsystemStatsResponse(nullptr) {}
  ~NVMeSubsystemStatsResponse() override;
  explicit constexpr NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeSubsystemStatsResponse(const NVMeSubsystemStatsResponse& from);
  NVMeSubsystemStatsResponse(NVMeSubsystemStatsResponse&& from) noexcept
    : NVMeSubsystemStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeSubsystemStatsResponse& operator=(const NVMeSubsystemStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeSubsystemStatsResponse& operator=(NVMeSubsystemStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeSubsystemStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeSubsystemStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeSubsystemStatsResponse*>(
               &_NVMeSubsystemStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NVMeSubsystemStatsResponse& a, NVMeSubsystemStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeSubsystemStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeSubsystemStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeSubsystemStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeSubsystemStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeSubsystemStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeSubsystemStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeSubsystemStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeSubsystemStatsResponse";
  }
  protected:
  explicit NVMeSubsystemStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeSubsystemStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::VolumeStats* stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class CreateNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNVMeControllerRequest) */ {
 public:
  inline CreateNVMeControllerRequest() : CreateNVMeControllerRequest(nullptr) {}
  ~CreateNVMeControllerRequest() override;
  explicit constexpr CreateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNVMeControllerRequest(const CreateNVMeControllerRequest& from);
  CreateNVMeControllerRequest(CreateNVMeControllerRequest&& from) noexcept
    : CreateNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline CreateNVMeControllerRequest& operator=(const CreateNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNVMeControllerRequest& operator=(CreateNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNVMeControllerRequest*>(
               &_CreateNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateNVMeControllerRequest& a, CreateNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNVMeControllerRequest";
  }
  protected:
  explicit CreateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kNvMeControllerIdFieldNumber = 3,
    kNvMeControllerFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string nv_me_controller_id = 3;
  void clear_nv_me_controller_id();
  const std::string& nv_me_controller_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nv_me_controller_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nv_me_controller_id();
  PROTOBUF_NODISCARD std::string* release_nv_me_controller_id();
  void set_allocated_nv_me_controller_id(std::string* nv_me_controller_id);
  private:
  const std::string& _internal_nv_me_controller_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nv_me_controller_id(const std::string& value);
  std::string* _internal_mutable_nv_me_controller_id();
  public:

  // .opi_api.storage.v1.NVMeController nv_me_controller = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_nv_me_controller() const;
  private:
  bool _internal_has_nv_me_controller() const;
  public:
  void clear_nv_me_controller();
  const ::opi_api::storage::v1::NVMeController& nv_me_controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeController* release_nv_me_controller();
  ::opi_api::storage::v1::NVMeController* mutable_nv_me_controller();
  void set_allocated_nv_me_controller(::opi_api::storage::v1::NVMeController* nv_me_controller);
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_nv_me_controller() const;
  ::opi_api::storage::v1::NVMeController* _internal_mutable_nv_me_controller();
  public:
  void unsafe_arena_set_allocated_nv_me_controller(
      ::opi_api::storage::v1::NVMeController* nv_me_controller);
  ::opi_api::storage::v1::NVMeController* unsafe_arena_release_nv_me_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nv_me_controller_id_;
  ::opi_api::storage::v1::NVMeController* nv_me_controller_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class DeleteNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNVMeControllerRequest) */ {
 public:
  inline DeleteNVMeControllerRequest() : DeleteNVMeControllerRequest(nullptr) {}
  ~DeleteNVMeControllerRequest() override;
  explicit constexpr DeleteNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNVMeControllerRequest(const DeleteNVMeControllerRequest& from);
  DeleteNVMeControllerRequest(DeleteNVMeControllerRequest&& from) noexcept
    : DeleteNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNVMeControllerRequest& operator=(const DeleteNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNVMeControllerRequest& operator=(DeleteNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNVMeControllerRequest*>(
               &_DeleteNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteNVMeControllerRequest& a, DeleteNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNVMeControllerRequest";
  }
  protected:
  explicit DeleteNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class UpdateNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNVMeControllerRequest) */ {
 public:
  inline UpdateNVMeControllerRequest() : UpdateNVMeControllerRequest(nullptr) {}
  ~UpdateNVMeControllerRequest() override;
  explicit constexpr UpdateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNVMeControllerRequest(const UpdateNVMeControllerRequest& from);
  UpdateNVMeControllerRequest(UpdateNVMeControllerRequest&& from) noexcept
    : UpdateNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNVMeControllerRequest& operator=(const UpdateNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNVMeControllerRequest& operator=(UpdateNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNVMeControllerRequest*>(
               &_UpdateNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateNVMeControllerRequest& a, UpdateNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNVMeControllerRequest";
  }
  protected:
  explicit UpdateNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvMeControllerFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeController nv_me_controller = 1;
  bool has_nv_me_controller() const;
  private:
  bool _internal_has_nv_me_controller() const;
  public:
  void clear_nv_me_controller();
  const ::opi_api::storage::v1::NVMeController& nv_me_controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeController* release_nv_me_controller();
  ::opi_api::storage::v1::NVMeController* mutable_nv_me_controller();
  void set_allocated_nv_me_controller(::opi_api::storage::v1::NVMeController* nv_me_controller);
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_nv_me_controller() const;
  ::opi_api::storage::v1::NVMeController* _internal_mutable_nv_me_controller();
  public:
  void unsafe_arena_set_allocated_nv_me_controller(
      ::opi_api::storage::v1::NVMeController* nv_me_controller);
  ::opi_api::storage::v1::NVMeController* unsafe_arena_release_nv_me_controller();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeController* nv_me_controller_;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeControllersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeControllersRequest) */ {
 public:
  inline ListNVMeControllersRequest() : ListNVMeControllersRequest(nullptr) {}
  ~ListNVMeControllersRequest() override;
  explicit constexpr ListNVMeControllersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeControllersRequest(const ListNVMeControllersRequest& from);
  ListNVMeControllersRequest(ListNVMeControllersRequest&& from) noexcept
    : ListNVMeControllersRequest() {
    *this = ::std::move(from);
  }

  inline ListNVMeControllersRequest& operator=(const ListNVMeControllersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeControllersRequest& operator=(ListNVMeControllersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeControllersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeControllersRequest* internal_default_instance() {
    return reinterpret_cast<const ListNVMeControllersRequest*>(
               &_ListNVMeControllersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListNVMeControllersRequest& a, ListNVMeControllersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeControllersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeControllersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeControllersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeControllersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeControllersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeControllersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeControllersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeControllersRequest";
  }
  protected:
  explicit ListNVMeControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeControllersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeControllersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeControllersResponse) */ {
 public:
  inline ListNVMeControllersResponse() : ListNVMeControllersResponse(nullptr) {}
  ~ListNVMeControllersResponse() override;
  explicit constexpr ListNVMeControllersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeControllersResponse(const ListNVMeControllersResponse& from);
  ListNVMeControllersResponse(ListNVMeControllersResponse&& from) noexcept
    : ListNVMeControllersResponse() {
    *this = ::std::move(from);
  }

  inline ListNVMeControllersResponse& operator=(const ListNVMeControllersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeControllersResponse& operator=(ListNVMeControllersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeControllersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeControllersResponse* internal_default_instance() {
    return reinterpret_cast<const ListNVMeControllersResponse*>(
               &_ListNVMeControllersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListNVMeControllersResponse& a, ListNVMeControllersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeControllersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeControllersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeControllersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeControllersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeControllersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeControllersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeControllersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeControllersResponse";
  }
  protected:
  explicit ListNVMeControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvMeControllersFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NVMeController nv_me_controllers = 1;
  int nv_me_controllers_size() const;
  private:
  int _internal_nv_me_controllers_size() const;
  public:
  void clear_nv_me_controllers();
  ::opi_api::storage::v1::NVMeController* mutable_nv_me_controllers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >*
      mutable_nv_me_controllers();
  private:
  const ::opi_api::storage::v1::NVMeController& _internal_nv_me_controllers(int index) const;
  ::opi_api::storage::v1::NVMeController* _internal_add_nv_me_controllers();
  public:
  const ::opi_api::storage::v1::NVMeController& nv_me_controllers(int index) const;
  ::opi_api::storage::v1::NVMeController* add_nv_me_controllers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >&
      nv_me_controllers() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeControllersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController > nv_me_controllers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class GetNVMeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNVMeControllerRequest) */ {
 public:
  inline GetNVMeControllerRequest() : GetNVMeControllerRequest(nullptr) {}
  ~GetNVMeControllerRequest() override;
  explicit constexpr GetNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNVMeControllerRequest(const GetNVMeControllerRequest& from);
  GetNVMeControllerRequest(GetNVMeControllerRequest&& from) noexcept
    : GetNVMeControllerRequest() {
    *this = ::std::move(from);
  }

  inline GetNVMeControllerRequest& operator=(const GetNVMeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNVMeControllerRequest& operator=(GetNVMeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNVMeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNVMeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const GetNVMeControllerRequest*>(
               &_GetNVMeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetNVMeControllerRequest& a, GetNVMeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNVMeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNVMeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNVMeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNVMeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNVMeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNVMeControllerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNVMeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNVMeControllerRequest";
  }
  protected:
  explicit GetNVMeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNVMeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatsRequest) */ {
 public:
  inline NVMeControllerStatsRequest() : NVMeControllerStatsRequest(nullptr) {}
  ~NVMeControllerStatsRequest() override;
  explicit constexpr NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatsRequest(const NVMeControllerStatsRequest& from);
  NVMeControllerStatsRequest(NVMeControllerStatsRequest&& from) noexcept
    : NVMeControllerStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatsRequest& operator=(const NVMeControllerStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatsRequest& operator=(NVMeControllerStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatsRequest*>(
               &_NVMeControllerStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NVMeControllerStatsRequest& a, NVMeControllerStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatsRequest";
  }
  protected:
  explicit NVMeControllerStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeControllerStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeControllerStatsResponse) */ {
 public:
  inline NVMeControllerStatsResponse() : NVMeControllerStatsResponse(nullptr) {}
  ~NVMeControllerStatsResponse() override;
  explicit constexpr NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeControllerStatsResponse(const NVMeControllerStatsResponse& from);
  NVMeControllerStatsResponse(NVMeControllerStatsResponse&& from) noexcept
    : NVMeControllerStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeControllerStatsResponse& operator=(const NVMeControllerStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeControllerStatsResponse& operator=(NVMeControllerStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeControllerStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeControllerStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeControllerStatsResponse*>(
               &_NVMeControllerStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(NVMeControllerStatsResponse& a, NVMeControllerStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeControllerStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeControllerStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeControllerStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeControllerStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeControllerStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeControllerStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeControllerStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeControllerStatsResponse";
  }
  protected:
  explicit NVMeControllerStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatsFieldNumber = 2,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.storage.v1.VolumeStats stats = 2;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeControllerStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::storage::v1::VolumeStats* stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class CreateNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNVMeNamespaceRequest) */ {
 public:
  inline CreateNVMeNamespaceRequest() : CreateNVMeNamespaceRequest(nullptr) {}
  ~CreateNVMeNamespaceRequest() override;
  explicit constexpr CreateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNVMeNamespaceRequest(const CreateNVMeNamespaceRequest& from);
  CreateNVMeNamespaceRequest(CreateNVMeNamespaceRequest&& from) noexcept
    : CreateNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline CreateNVMeNamespaceRequest& operator=(const CreateNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNVMeNamespaceRequest& operator=(CreateNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNVMeNamespaceRequest*>(
               &_CreateNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateNVMeNamespaceRequest& a, CreateNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNVMeNamespaceRequest";
  }
  protected:
  explicit CreateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kNvMeNamespaceIdFieldNumber = 3,
    kNvMeNamespaceFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string nv_me_namespace_id = 3;
  void clear_nv_me_namespace_id();
  const std::string& nv_me_namespace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nv_me_namespace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nv_me_namespace_id();
  PROTOBUF_NODISCARD std::string* release_nv_me_namespace_id();
  void set_allocated_nv_me_namespace_id(std::string* nv_me_namespace_id);
  private:
  const std::string& _internal_nv_me_namespace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nv_me_namespace_id(const std::string& value);
  std::string* _internal_mutable_nv_me_namespace_id();
  public:

  // .opi_api.storage.v1.NVMeNamespace nv_me_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_nv_me_namespace() const;
  private:
  bool _internal_has_nv_me_namespace() const;
  public:
  void clear_nv_me_namespace();
  const ::opi_api::storage::v1::NVMeNamespace& nv_me_namespace() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespace* release_nv_me_namespace();
  ::opi_api::storage::v1::NVMeNamespace* mutable_nv_me_namespace();
  void set_allocated_nv_me_namespace(::opi_api::storage::v1::NVMeNamespace* nv_me_namespace);
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_nv_me_namespace() const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_mutable_nv_me_namespace();
  public:
  void unsafe_arena_set_allocated_nv_me_namespace(
      ::opi_api::storage::v1::NVMeNamespace* nv_me_namespace);
  ::opi_api::storage::v1::NVMeNamespace* unsafe_arena_release_nv_me_namespace();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nv_me_namespace_id_;
  ::opi_api::storage::v1::NVMeNamespace* nv_me_namespace_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class DeleteNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNVMeNamespaceRequest) */ {
 public:
  inline DeleteNVMeNamespaceRequest() : DeleteNVMeNamespaceRequest(nullptr) {}
  ~DeleteNVMeNamespaceRequest() override;
  explicit constexpr DeleteNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNVMeNamespaceRequest(const DeleteNVMeNamespaceRequest& from);
  DeleteNVMeNamespaceRequest(DeleteNVMeNamespaceRequest&& from) noexcept
    : DeleteNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNVMeNamespaceRequest& operator=(const DeleteNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNVMeNamespaceRequest& operator=(DeleteNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNVMeNamespaceRequest*>(
               &_DeleteNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DeleteNVMeNamespaceRequest& a, DeleteNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNVMeNamespaceRequest";
  }
  protected:
  explicit DeleteNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class UpdateNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNVMeNamespaceRequest) */ {
 public:
  inline UpdateNVMeNamespaceRequest() : UpdateNVMeNamespaceRequest(nullptr) {}
  ~UpdateNVMeNamespaceRequest() override;
  explicit constexpr UpdateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNVMeNamespaceRequest(const UpdateNVMeNamespaceRequest& from);
  UpdateNVMeNamespaceRequest(UpdateNVMeNamespaceRequest&& from) noexcept
    : UpdateNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNVMeNamespaceRequest& operator=(const UpdateNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNVMeNamespaceRequest& operator=(UpdateNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNVMeNamespaceRequest*>(
               &_UpdateNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateNVMeNamespaceRequest& a, UpdateNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNVMeNamespaceRequest";
  }
  protected:
  explicit UpdateNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvMeNamespaceFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .opi_api.storage.v1.NVMeNamespace nv_me_namespace = 1;
  bool has_nv_me_namespace() const;
  private:
  bool _internal_has_nv_me_namespace() const;
  public:
  void clear_nv_me_namespace();
  const ::opi_api::storage::v1::NVMeNamespace& nv_me_namespace() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NVMeNamespace* release_nv_me_namespace();
  ::opi_api::storage::v1::NVMeNamespace* mutable_nv_me_namespace();
  void set_allocated_nv_me_namespace(::opi_api::storage::v1::NVMeNamespace* nv_me_namespace);
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_nv_me_namespace() const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_mutable_nv_me_namespace();
  public:
  void unsafe_arena_set_allocated_nv_me_namespace(
      ::opi_api::storage::v1::NVMeNamespace* nv_me_namespace);
  ::opi_api::storage::v1::NVMeNamespace* unsafe_arena_release_nv_me_namespace();

  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::storage::v1::NVMeNamespace* nv_me_namespace_;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeNamespacesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeNamespacesRequest) */ {
 public:
  inline ListNVMeNamespacesRequest() : ListNVMeNamespacesRequest(nullptr) {}
  ~ListNVMeNamespacesRequest() override;
  explicit constexpr ListNVMeNamespacesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeNamespacesRequest(const ListNVMeNamespacesRequest& from);
  ListNVMeNamespacesRequest(ListNVMeNamespacesRequest&& from) noexcept
    : ListNVMeNamespacesRequest() {
    *this = ::std::move(from);
  }

  inline ListNVMeNamespacesRequest& operator=(const ListNVMeNamespacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeNamespacesRequest& operator=(ListNVMeNamespacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeNamespacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeNamespacesRequest* internal_default_instance() {
    return reinterpret_cast<const ListNVMeNamespacesRequest*>(
               &_ListNVMeNamespacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListNVMeNamespacesRequest& a, ListNVMeNamespacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeNamespacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeNamespacesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeNamespacesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeNamespacesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeNamespacesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeNamespacesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeNamespacesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeNamespacesRequest";
  }
  protected:
  explicit ListNVMeNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3;
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2;
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeNamespacesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
  int32_t page_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class ListNVMeNamespacesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNVMeNamespacesResponse) */ {
 public:
  inline ListNVMeNamespacesResponse() : ListNVMeNamespacesResponse(nullptr) {}
  ~ListNVMeNamespacesResponse() override;
  explicit constexpr ListNVMeNamespacesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNVMeNamespacesResponse(const ListNVMeNamespacesResponse& from);
  ListNVMeNamespacesResponse(ListNVMeNamespacesResponse&& from) noexcept
    : ListNVMeNamespacesResponse() {
    *this = ::std::move(from);
  }

  inline ListNVMeNamespacesResponse& operator=(const ListNVMeNamespacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNVMeNamespacesResponse& operator=(ListNVMeNamespacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNVMeNamespacesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNVMeNamespacesResponse* internal_default_instance() {
    return reinterpret_cast<const ListNVMeNamespacesResponse*>(
               &_ListNVMeNamespacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ListNVMeNamespacesResponse& a, ListNVMeNamespacesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNVMeNamespacesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNVMeNamespacesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNVMeNamespacesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNVMeNamespacesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNVMeNamespacesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNVMeNamespacesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNVMeNamespacesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNVMeNamespacesResponse";
  }
  protected:
  explicit ListNVMeNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvMeNamespacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NVMeNamespace nv_me_namespaces = 1;
  int nv_me_namespaces_size() const;
  private:
  int _internal_nv_me_namespaces_size() const;
  public:
  void clear_nv_me_namespaces();
  ::opi_api::storage::v1::NVMeNamespace* mutable_nv_me_namespaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >*
      mutable_nv_me_namespaces();
  private:
  const ::opi_api::storage::v1::NVMeNamespace& _internal_nv_me_namespaces(int index) const;
  ::opi_api::storage::v1::NVMeNamespace* _internal_add_nv_me_namespaces();
  public:
  const ::opi_api::storage::v1::NVMeNamespace& nv_me_namespaces(int index) const;
  ::opi_api::storage::v1::NVMeNamespace* add_nv_me_namespaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >&
      nv_me_namespaces() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNVMeNamespacesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace > nv_me_namespaces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class GetNVMeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNVMeNamespaceRequest) */ {
 public:
  inline GetNVMeNamespaceRequest() : GetNVMeNamespaceRequest(nullptr) {}
  ~GetNVMeNamespaceRequest() override;
  explicit constexpr GetNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNVMeNamespaceRequest(const GetNVMeNamespaceRequest& from);
  GetNVMeNamespaceRequest(GetNVMeNamespaceRequest&& from) noexcept
    : GetNVMeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline GetNVMeNamespaceRequest& operator=(const GetNVMeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNVMeNamespaceRequest& operator=(GetNVMeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNVMeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNVMeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetNVMeNamespaceRequest*>(
               &_GetNVMeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetNVMeNamespaceRequest& a, GetNVMeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNVMeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNVMeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNVMeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNVMeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNVMeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNVMeNamespaceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNVMeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNVMeNamespaceRequest";
  }
  protected:
  explicit GetNVMeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNVMeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatsRequest) */ {
 public:
  inline NVMeNamespaceStatsRequest() : NVMeNamespaceStatsRequest(nullptr) {}
  ~NVMeNamespaceStatsRequest() override;
  explicit constexpr NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatsRequest(const NVMeNamespaceStatsRequest& from);
  NVMeNamespaceStatsRequest(NVMeNamespaceStatsRequest&& from) noexcept
    : NVMeNamespaceStatsRequest() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatsRequest& operator=(const NVMeNamespaceStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatsRequest& operator=(NVMeNamespaceStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatsRequest*>(
               &_NVMeNamespaceStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NVMeNamespaceStatsRequest& a, NVMeNamespaceStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatsRequest";
  }
  protected:
  explicit NVMeNamespaceStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceIdFieldNumber = 1,
  };
  // .opi_api.common.v1.ObjectKey namespace_id = 1;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  const ::opi_api::common::v1::ObjectKey& namespace_id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_namespace_id();
  ::opi_api::common::v1::ObjectKey* mutable_namespace_id();
  void set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_namespace_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_namespace_id();
  public:
  void unsafe_arena_set_allocated_namespace_id(
      ::opi_api::common::v1::ObjectKey* namespace_id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_namespace_id();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* namespace_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// -------------------------------------------------------------------

class NVMeNamespaceStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NVMeNamespaceStatsResponse) */ {
 public:
  inline NVMeNamespaceStatsResponse() : NVMeNamespaceStatsResponse(nullptr) {}
  ~NVMeNamespaceStatsResponse() override;
  explicit constexpr NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NVMeNamespaceStatsResponse(const NVMeNamespaceStatsResponse& from);
  NVMeNamespaceStatsResponse(NVMeNamespaceStatsResponse&& from) noexcept
    : NVMeNamespaceStatsResponse() {
    *this = ::std::move(from);
  }

  inline NVMeNamespaceStatsResponse& operator=(const NVMeNamespaceStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NVMeNamespaceStatsResponse& operator=(NVMeNamespaceStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NVMeNamespaceStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NVMeNamespaceStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NVMeNamespaceStatsResponse*>(
               &_NVMeNamespaceStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(NVMeNamespaceStatsResponse& a, NVMeNamespaceStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NVMeNamespaceStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NVMeNamespaceStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NVMeNamespaceStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NVMeNamespaceStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NVMeNamespaceStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NVMeNamespaceStatsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NVMeNamespaceStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NVMeNamespaceStatsResponse";
  }
  protected:
  explicit NVMeNamespaceStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatsFieldNumber = 2,
  };
  // .opi_api.common.v1.ObjectKey id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::opi_api::common::v1::ObjectKey& id() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::ObjectKey* release_id();
  ::opi_api::common::v1::ObjectKey* mutable_id();
  void set_allocated_id(::opi_api::common::v1::ObjectKey* id);
  private:
  const ::opi_api::common::v1::ObjectKey& _internal_id() const;
  ::opi_api::common::v1::ObjectKey* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::opi_api::common::v1::ObjectKey* id);
  ::opi_api::common::v1::ObjectKey* unsafe_arena_release_id();

  // .opi_api.storage.v1.VolumeStats stats = 2;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NVMeNamespaceStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::opi_api::common::v1::ObjectKey* id_;
  ::opi_api::storage::v1::VolumeStats* stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_frontend_5fnvme_5fpcie_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NVMeSubsystem

// .opi_api.storage.v1.NVMeSubsystemSpec spec = 1;
inline bool NVMeSubsystem::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NVMeSubsystem::has_spec() const {
  return _internal_has_spec();
}
inline void NVMeSubsystem::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystemSpec& NVMeSubsystem::_internal_spec() const {
  const ::opi_api::storage::v1::NVMeSubsystemSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystemSpec&>(
      ::opi_api::storage::v1::_NVMeSubsystemSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystemSpec& NVMeSubsystem::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.spec)
  return _internal_spec();
}
inline void NVMeSubsystem::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NVMeSubsystemSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystem.spec)
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::release_spec() {
  
  ::opi_api::storage::v1::NVMeSubsystemSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.spec)
  
  ::opi_api::storage::v1::NVMeSubsystemSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::storage::v1::NVMeSubsystemSpec* NVMeSubsystem::mutable_spec() {
  ::opi_api::storage::v1::NVMeSubsystemSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.spec)
  return _msg;
}
inline void NVMeSubsystem::set_allocated_spec(::opi_api::storage::v1::NVMeSubsystemSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystemSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.spec)
}

// .opi_api.storage.v1.NVMeSubsystemStatus status = 2;
inline bool NVMeSubsystem::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NVMeSubsystem::has_status() const {
  return _internal_has_status();
}
inline void NVMeSubsystem::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystemStatus& NVMeSubsystem::_internal_status() const {
  const ::opi_api::storage::v1::NVMeSubsystemStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystemStatus&>(
      ::opi_api::storage::v1::_NVMeSubsystemStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystemStatus& NVMeSubsystem::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystem.status)
  return _internal_status();
}
inline void NVMeSubsystem::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NVMeSubsystemStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystem.status)
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::release_status() {
  
  ::opi_api::storage::v1::NVMeSubsystemStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystem.status)
  
  ::opi_api::storage::v1::NVMeSubsystemStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystemStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::storage::v1::NVMeSubsystemStatus* NVMeSubsystem::mutable_status() {
  ::opi_api::storage::v1::NVMeSubsystemStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystem.status)
  return _msg;
}
inline void NVMeSubsystem::set_allocated_status(::opi_api::storage::v1::NVMeSubsystemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystemStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystem.status)
}

// -------------------------------------------------------------------

// NVMeSubsystemSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeSubsystemSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeSubsystemSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.id)
  return _internal_id();
}
inline void NVMeSubsystemSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.id)
  return _msg;
}
inline void NVMeSubsystemSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.id)
}

// string nqn = 2;
inline void NVMeSubsystemSpec::clear_nqn() {
  nqn_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemSpec::nqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
  return _internal_nqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemSpec::set_nqn(ArgT0&& arg0, ArgT... args) {
 
 nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
}
inline std::string* NVMeSubsystemSpec::mutable_nqn() {
  std::string* _s = _internal_mutable_nqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
  return _s;
}
inline const std::string& NVMeSubsystemSpec::_internal_nqn() const {
  return nqn_.Get();
}
inline void NVMeSubsystemSpec::_internal_set_nqn(const std::string& value) {
  
  nqn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::_internal_mutable_nqn() {
  
  return nqn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::release_nqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
  return nqn_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemSpec::set_allocated_nqn(std::string* nqn) {
  if (nqn != nullptr) {
    
  } else {
    
  }
  nqn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nqn,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nqn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nqn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.nqn)
}

// string serial_number = 3;
inline void NVMeSubsystemSpec::clear_serial_number() {
  serial_number_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemSpec::serial_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemSpec::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
}
inline std::string* NVMeSubsystemSpec::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
  return _s;
}
inline const std::string& NVMeSubsystemSpec::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void NVMeSubsystemSpec::_internal_set_serial_number(const std::string& value) {
  
  serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::_internal_mutable_serial_number() {
  
  return serial_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::release_serial_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
  return serial_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemSpec::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  serial_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.serial_number)
}

// string model_number = 4;
inline void NVMeSubsystemSpec::clear_model_number() {
  model_number_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemSpec::model_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
  return _internal_model_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemSpec::set_model_number(ArgT0&& arg0, ArgT... args) {
 
 model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
}
inline std::string* NVMeSubsystemSpec::mutable_model_number() {
  std::string* _s = _internal_mutable_model_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
  return _s;
}
inline const std::string& NVMeSubsystemSpec::_internal_model_number() const {
  return model_number_.Get();
}
inline void NVMeSubsystemSpec::_internal_set_model_number(const std::string& value) {
  
  model_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::_internal_mutable_model_number() {
  
  return model_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemSpec::release_model_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
  return model_number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemSpec::set_allocated_model_number(std::string* model_number) {
  if (model_number != nullptr) {
    
  } else {
    
  }
  model_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemSpec.model_number)
}

// int64 max_namespaces = 5;
inline void NVMeSubsystemSpec::clear_max_namespaces() {
  max_namespaces_ = int64_t{0};
}
inline int64_t NVMeSubsystemSpec::_internal_max_namespaces() const {
  return max_namespaces_;
}
inline int64_t NVMeSubsystemSpec::max_namespaces() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemSpec.max_namespaces)
  return _internal_max_namespaces();
}
inline void NVMeSubsystemSpec::_internal_set_max_namespaces(int64_t value) {
  
  max_namespaces_ = value;
}
inline void NVMeSubsystemSpec::set_max_namespaces(int64_t value) {
  _internal_set_max_namespaces(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemSpec.max_namespaces)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatus

// string firmware_revision = 1;
inline void NVMeSubsystemStatus::clear_firmware_revision() {
  firmware_revision_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemStatus::firmware_revision() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
  return _internal_firmware_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemStatus::set_firmware_revision(ArgT0&& arg0, ArgT... args) {
 
 firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
}
inline std::string* NVMeSubsystemStatus::mutable_firmware_revision() {
  std::string* _s = _internal_mutable_firmware_revision();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
  return _s;
}
inline const std::string& NVMeSubsystemStatus::_internal_firmware_revision() const {
  return firmware_revision_.Get();
}
inline void NVMeSubsystemStatus::_internal_set_firmware_revision(const std::string& value) {
  
  firmware_revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::_internal_mutable_firmware_revision() {
  
  return firmware_revision_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
  return firmware_revision_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemStatus::set_allocated_firmware_revision(std::string* firmware_revision) {
  if (firmware_revision != nullptr) {
    
  } else {
    
  }
  firmware_revision_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), firmware_revision,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (firmware_revision_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    firmware_revision_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatus.firmware_revision)
}

// bytes fru_guid = 2;
inline void NVMeSubsystemStatus::clear_fru_guid() {
  fru_guid_.ClearToEmpty();
}
inline const std::string& NVMeSubsystemStatus::fru_guid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
  return _internal_fru_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeSubsystemStatus::set_fru_guid(ArgT0&& arg0, ArgT... args) {
 
 fru_guid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
}
inline std::string* NVMeSubsystemStatus::mutable_fru_guid() {
  std::string* _s = _internal_mutable_fru_guid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
  return _s;
}
inline const std::string& NVMeSubsystemStatus::_internal_fru_guid() const {
  return fru_guid_.Get();
}
inline void NVMeSubsystemStatus::_internal_set_fru_guid(const std::string& value) {
  
  fru_guid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::_internal_mutable_fru_guid() {
  
  return fru_guid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeSubsystemStatus::release_fru_guid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
  return fru_guid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeSubsystemStatus::set_allocated_fru_guid(std::string* fru_guid) {
  if (fru_guid != nullptr) {
    
  } else {
    
  }
  fru_guid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fru_guid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fru_guid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fru_guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatus.fru_guid)
}

// -------------------------------------------------------------------

// NVMeController

// .opi_api.storage.v1.NVMeControllerSpec spec = 1;
inline bool NVMeController::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NVMeController::has_spec() const {
  return _internal_has_spec();
}
inline void NVMeController::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeControllerSpec& NVMeController::_internal_spec() const {
  const ::opi_api::storage::v1::NVMeControllerSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeControllerSpec&>(
      ::opi_api::storage::v1::_NVMeControllerSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeControllerSpec& NVMeController::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.spec)
  return _internal_spec();
}
inline void NVMeController::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NVMeControllerSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.spec)
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::release_spec() {
  
  ::opi_api::storage::v1::NVMeControllerSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.spec)
  
  ::opi_api::storage::v1::NVMeControllerSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::storage::v1::NVMeControllerSpec* NVMeController::mutable_spec() {
  ::opi_api::storage::v1::NVMeControllerSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.spec)
  return _msg;
}
inline void NVMeController::set_allocated_spec(::opi_api::storage::v1::NVMeControllerSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeControllerSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.spec)
}

// .opi_api.storage.v1.NVMeControllerStatus status = 2;
inline bool NVMeController::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NVMeController::has_status() const {
  return _internal_has_status();
}
inline void NVMeController::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeControllerStatus& NVMeController::_internal_status() const {
  const ::opi_api::storage::v1::NVMeControllerStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeControllerStatus&>(
      ::opi_api::storage::v1::_NVMeControllerStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeControllerStatus& NVMeController::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeController.status)
  return _internal_status();
}
inline void NVMeController::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NVMeControllerStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeController.status)
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::release_status() {
  
  ::opi_api::storage::v1::NVMeControllerStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeController.status)
  
  ::opi_api::storage::v1::NVMeControllerStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeControllerStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::storage::v1::NVMeControllerStatus* NVMeController::mutable_status() {
  ::opi_api::storage::v1::NVMeControllerStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeController.status)
  return _msg;
}
inline void NVMeController::set_allocated_status(::opi_api::storage::v1::NVMeControllerStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeControllerStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeController.status)
}

// -------------------------------------------------------------------

// NVMeControllerSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.id)
  return _internal_id();
}
inline void NVMeControllerSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerSpec.id)
  return _msg;
}
inline void NVMeControllerSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerSpec.id)
}

// int32 nvme_controller_id = 2;
inline void NVMeControllerSpec::clear_nvme_controller_id() {
  nvme_controller_id_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_nvme_controller_id() const {
  return nvme_controller_id_;
}
inline int32_t NVMeControllerSpec::nvme_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.nvme_controller_id)
  return _internal_nvme_controller_id();
}
inline void NVMeControllerSpec::_internal_set_nvme_controller_id(int32_t value) {
  
  nvme_controller_id_ = value;
}
inline void NVMeControllerSpec::set_nvme_controller_id(int32_t value) {
  _internal_set_nvme_controller_id(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.nvme_controller_id)
}

// .opi_api.common.v1.ObjectKey subsystem_id = 3;
inline bool NVMeControllerSpec::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeControllerSpec::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerSpec::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeControllerSpec::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerSpec::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
  return _msg;
}
inline void NVMeControllerSpec::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerSpec.subsystem_id)
}

// .opi_api.storage.v1.PciEndpoint pcie_id = 4;
inline bool NVMeControllerSpec::_internal_has_pcie_id() const {
  return this != internal_default_instance() && pcie_id_ != nullptr;
}
inline bool NVMeControllerSpec::has_pcie_id() const {
  return _internal_has_pcie_id();
}
inline const ::opi_api::storage::v1::PciEndpoint& NVMeControllerSpec::_internal_pcie_id() const {
  const ::opi_api::storage::v1::PciEndpoint* p = pcie_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::PciEndpoint&>(
      ::opi_api::storage::v1::_PciEndpoint_default_instance_);
}
inline const ::opi_api::storage::v1::PciEndpoint& NVMeControllerSpec::pcie_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
  return _internal_pcie_id();
}
inline void NVMeControllerSpec::unsafe_arena_set_allocated_pcie_id(
    ::opi_api::storage::v1::PciEndpoint* pcie_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id_);
  }
  pcie_id_ = pcie_id;
  if (pcie_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::release_pcie_id() {
  
  ::opi_api::storage::v1::PciEndpoint* temp = pcie_id_;
  pcie_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::unsafe_arena_release_pcie_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
  
  ::opi_api::storage::v1::PciEndpoint* temp = pcie_id_;
  pcie_id_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::_internal_mutable_pcie_id() {
  
  if (pcie_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::PciEndpoint>(GetArenaForAllocation());
    pcie_id_ = p;
  }
  return pcie_id_;
}
inline ::opi_api::storage::v1::PciEndpoint* NVMeControllerSpec::mutable_pcie_id() {
  ::opi_api::storage::v1::PciEndpoint* _msg = _internal_mutable_pcie_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
  return _msg;
}
inline void NVMeControllerSpec::set_allocated_pcie_id(::opi_api::storage::v1::PciEndpoint* pcie_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id_);
  }
  if (pcie_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pcie_id));
    if (message_arena != submessage_arena) {
      pcie_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pcie_id, submessage_arena);
    }
    
  } else {
    
  }
  pcie_id_ = pcie_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerSpec.pcie_id)
}

// int32 max_nsq = 5;
inline void NVMeControllerSpec::clear_max_nsq() {
  max_nsq_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_max_nsq() const {
  return max_nsq_;
}
inline int32_t NVMeControllerSpec::max_nsq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.max_nsq)
  return _internal_max_nsq();
}
inline void NVMeControllerSpec::_internal_set_max_nsq(int32_t value) {
  
  max_nsq_ = value;
}
inline void NVMeControllerSpec::set_max_nsq(int32_t value) {
  _internal_set_max_nsq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.max_nsq)
}

// int32 max_ncq = 6;
inline void NVMeControllerSpec::clear_max_ncq() {
  max_ncq_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_max_ncq() const {
  return max_ncq_;
}
inline int32_t NVMeControllerSpec::max_ncq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.max_ncq)
  return _internal_max_ncq();
}
inline void NVMeControllerSpec::_internal_set_max_ncq(int32_t value) {
  
  max_ncq_ = value;
}
inline void NVMeControllerSpec::set_max_ncq(int32_t value) {
  _internal_set_max_ncq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.max_ncq)
}

// int32 sqes = 7;
inline void NVMeControllerSpec::clear_sqes() {
  sqes_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_sqes() const {
  return sqes_;
}
inline int32_t NVMeControllerSpec::sqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.sqes)
  return _internal_sqes();
}
inline void NVMeControllerSpec::_internal_set_sqes(int32_t value) {
  
  sqes_ = value;
}
inline void NVMeControllerSpec::set_sqes(int32_t value) {
  _internal_set_sqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.sqes)
}

// int32 cqes = 8;
inline void NVMeControllerSpec::clear_cqes() {
  cqes_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_cqes() const {
  return cqes_;
}
inline int32_t NVMeControllerSpec::cqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.cqes)
  return _internal_cqes();
}
inline void NVMeControllerSpec::_internal_set_cqes(int32_t value) {
  
  cqes_ = value;
}
inline void NVMeControllerSpec::set_cqes(int32_t value) {
  _internal_set_cqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.cqes)
}

// int32 max_namespaces = 9;
inline void NVMeControllerSpec::clear_max_namespaces() {
  max_namespaces_ = 0;
}
inline int32_t NVMeControllerSpec::_internal_max_namespaces() const {
  return max_namespaces_;
}
inline int32_t NVMeControllerSpec::max_namespaces() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerSpec.max_namespaces)
  return _internal_max_namespaces();
}
inline void NVMeControllerSpec::_internal_set_max_namespaces(int32_t value) {
  
  max_namespaces_ = value;
}
inline void NVMeControllerSpec::set_max_namespaces(int32_t value) {
  _internal_set_max_namespaces(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerSpec.max_namespaces)
}

// -------------------------------------------------------------------

// NVMeControllerStatus

// bool active = 1;
inline void NVMeControllerStatus::clear_active() {
  active_ = false;
}
inline bool NVMeControllerStatus::_internal_active() const {
  return active_;
}
inline bool NVMeControllerStatus::active() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatus.active)
  return _internal_active();
}
inline void NVMeControllerStatus::_internal_set_active(bool value) {
  
  active_ = value;
}
inline void NVMeControllerStatus::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeControllerStatus.active)
}

// -------------------------------------------------------------------

// NVMeNamespace

// .opi_api.storage.v1.NVMeNamespaceSpec spec = 1;
inline bool NVMeNamespace::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NVMeNamespace::has_spec() const {
  return _internal_has_spec();
}
inline void NVMeNamespace::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespaceSpec& NVMeNamespace::_internal_spec() const {
  const ::opi_api::storage::v1::NVMeNamespaceSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespaceSpec&>(
      ::opi_api::storage::v1::_NVMeNamespaceSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespaceSpec& NVMeNamespace::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.spec)
  return _internal_spec();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NVMeNamespaceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.spec)
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::release_spec() {
  
  ::opi_api::storage::v1::NVMeNamespaceSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.spec)
  
  ::opi_api::storage::v1::NVMeNamespaceSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::opi_api::storage::v1::NVMeNamespaceSpec* NVMeNamespace::mutable_spec() {
  ::opi_api::storage::v1::NVMeNamespaceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.spec)
  return _msg;
}
inline void NVMeNamespace::set_allocated_spec(::opi_api::storage::v1::NVMeNamespaceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespaceSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.spec)
}

// .opi_api.storage.v1.NVMeNamespaceStatus status = 2;
inline bool NVMeNamespace::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NVMeNamespace::has_status() const {
  return _internal_has_status();
}
inline void NVMeNamespace::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespaceStatus& NVMeNamespace::_internal_status() const {
  const ::opi_api::storage::v1::NVMeNamespaceStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespaceStatus&>(
      ::opi_api::storage::v1::_NVMeNamespaceStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespaceStatus& NVMeNamespace::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespace.status)
  return _internal_status();
}
inline void NVMeNamespace::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NVMeNamespaceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespace.status)
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::release_status() {
  
  ::opi_api::storage::v1::NVMeNamespaceStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespace.status)
  
  ::opi_api::storage::v1::NVMeNamespaceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespaceStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::opi_api::storage::v1::NVMeNamespaceStatus* NVMeNamespace::mutable_status() {
  ::opi_api::storage::v1::NVMeNamespaceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespace.status)
  return _msg;
}
inline void NVMeNamespace::set_allocated_status(::opi_api::storage::v1::NVMeNamespaceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespaceStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespace.status)
}

// -------------------------------------------------------------------

// NVMeNamespaceSpec

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeNamespaceSpec::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.id)
  return _internal_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.id)
}

// .opi_api.common.v1.ObjectKey subsystem_id = 2;
inline bool NVMeNamespaceSpec::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.subsystem_id)
}

// int32 host_nsid = 4;
inline void NVMeNamespaceSpec::clear_host_nsid() {
  host_nsid_ = 0;
}
inline int32_t NVMeNamespaceSpec::_internal_host_nsid() const {
  return host_nsid_;
}
inline int32_t NVMeNamespaceSpec::host_nsid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.host_nsid)
  return _internal_host_nsid();
}
inline void NVMeNamespaceSpec::_internal_set_host_nsid(int32_t value) {
  
  host_nsid_ = value;
}
inline void NVMeNamespaceSpec::set_host_nsid(int32_t value) {
  _internal_set_host_nsid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.host_nsid)
}

// string nguid = 7;
inline void NVMeNamespaceSpec::clear_nguid() {
  nguid_.ClearToEmpty();
}
inline const std::string& NVMeNamespaceSpec::nguid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
  return _internal_nguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NVMeNamespaceSpec::set_nguid(ArgT0&& arg0, ArgT... args) {
 
 nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
}
inline std::string* NVMeNamespaceSpec::mutable_nguid() {
  std::string* _s = _internal_mutable_nguid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
  return _s;
}
inline const std::string& NVMeNamespaceSpec::_internal_nguid() const {
  return nguid_.Get();
}
inline void NVMeNamespaceSpec::_internal_set_nguid(const std::string& value) {
  
  nguid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceSpec::_internal_mutable_nguid() {
  
  return nguid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NVMeNamespaceSpec::release_nguid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
  return nguid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NVMeNamespaceSpec::set_allocated_nguid(std::string* nguid) {
  if (nguid != nullptr) {
    
  } else {
    
  }
  nguid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nguid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nguid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nguid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.nguid)
}

// int64 eui64 = 8;
inline void NVMeNamespaceSpec::clear_eui64() {
  eui64_ = int64_t{0};
}
inline int64_t NVMeNamespaceSpec::_internal_eui64() const {
  return eui64_;
}
inline int64_t NVMeNamespaceSpec::eui64() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.eui64)
  return _internal_eui64();
}
inline void NVMeNamespaceSpec::_internal_set_eui64(int64_t value) {
  
  eui64_ = value;
}
inline void NVMeNamespaceSpec::set_eui64(int64_t value) {
  _internal_set_eui64(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceSpec.eui64)
}

// .opi_api.common.v1.Uuid uuid = 9;
inline bool NVMeNamespaceSpec::_internal_has_uuid() const {
  return this != internal_default_instance() && uuid_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_uuid() const {
  return _internal_has_uuid();
}
inline const ::opi_api::common::v1::Uuid& NVMeNamespaceSpec::_internal_uuid() const {
  const ::opi_api::common::v1::Uuid* p = uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::Uuid&>(
      ::opi_api::common::v1::_Uuid_default_instance_);
}
inline const ::opi_api::common::v1::Uuid& NVMeNamespaceSpec::uuid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
  return _internal_uuid();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_uuid(
    ::opi_api::common::v1::Uuid* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  uuid_ = uuid;
  if (uuid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::release_uuid() {
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
  
  ::opi_api::common::v1::Uuid* temp = uuid_;
  uuid_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::_internal_mutable_uuid() {
  
  if (uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::Uuid>(GetArenaForAllocation());
    uuid_ = p;
  }
  return uuid_;
}
inline ::opi_api::common::v1::Uuid* NVMeNamespaceSpec::mutable_uuid() {
  ::opi_api::common::v1::Uuid* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_uuid(::opi_api::common::v1::Uuid* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid_);
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid));
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    
  } else {
    
  }
  uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.uuid)
}

// .opi_api.common.v1.ObjectKey volume_id = 10;
inline bool NVMeNamespaceSpec::_internal_has_volume_id() const {
  return this != internal_default_instance() && volume_id_ != nullptr;
}
inline bool NVMeNamespaceSpec::has_volume_id() const {
  return _internal_has_volume_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::_internal_volume_id() const {
  const ::opi_api::common::v1::ObjectKey* p = volume_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceSpec::volume_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
  return _internal_volume_id();
}
inline void NVMeNamespaceSpec::unsafe_arena_set_allocated_volume_id(
    ::opi_api::common::v1::ObjectKey* volume_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  volume_id_ = volume_id;
  if (volume_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::release_volume_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
  
  ::opi_api::common::v1::ObjectKey* temp = volume_id_;
  volume_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::_internal_mutable_volume_id() {
  
  if (volume_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    volume_id_ = p;
  }
  return volume_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceSpec::mutable_volume_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
  return _msg;
}
inline void NVMeNamespaceSpec::set_allocated_volume_id(::opi_api::common::v1::ObjectKey* volume_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id_);
  }
  if (volume_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_id));
    if (message_arena != submessage_arena) {
      volume_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_id, submessage_arena);
    }
    
  } else {
    
  }
  volume_id_ = volume_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceSpec.volume_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatus

// .opi_api.storage.v1.NVMeNamespacePciState pci_state = 1;
inline void NVMeNamespaceStatus::clear_pci_state() {
  pci_state_ = 0;
}
inline ::opi_api::storage::v1::NVMeNamespacePciState NVMeNamespaceStatus::_internal_pci_state() const {
  return static_cast< ::opi_api::storage::v1::NVMeNamespacePciState >(pci_state_);
}
inline ::opi_api::storage::v1::NVMeNamespacePciState NVMeNamespaceStatus::pci_state() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatus.pci_state)
  return _internal_pci_state();
}
inline void NVMeNamespaceStatus::_internal_set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value) {
  
  pci_state_ = value;
}
inline void NVMeNamespaceStatus::set_pci_state(::opi_api::storage::v1::NVMeNamespacePciState value) {
  _internal_set_pci_state(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceStatus.pci_state)
}

// .opi_api.storage.v1.NVMeNamespacePciOperState pci_oper_state = 2;
inline void NVMeNamespaceStatus::clear_pci_oper_state() {
  pci_oper_state_ = 0;
}
inline ::opi_api::storage::v1::NVMeNamespacePciOperState NVMeNamespaceStatus::_internal_pci_oper_state() const {
  return static_cast< ::opi_api::storage::v1::NVMeNamespacePciOperState >(pci_oper_state_);
}
inline ::opi_api::storage::v1::NVMeNamespacePciOperState NVMeNamespaceStatus::pci_oper_state() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatus.pci_oper_state)
  return _internal_pci_oper_state();
}
inline void NVMeNamespaceStatus::_internal_set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value) {
  
  pci_oper_state_ = value;
}
inline void NVMeNamespaceStatus::set_pci_oper_state(::opi_api::storage::v1::NVMeNamespacePciOperState value) {
  _internal_set_pci_oper_state(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NVMeNamespaceStatus.pci_oper_state)
}

// -------------------------------------------------------------------

// CreateNVMeSubsystemRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateNVMeSubsystemRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& CreateNVMeSubsystemRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeSubsystemRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNVMeSubsystemRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNVMeSubsystemRequest.parent)
}
inline std::string* CreateNVMeSubsystemRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeSubsystemRequest.parent)
  return _s;
}
inline const std::string& CreateNVMeSubsystemRequest::_internal_parent() const {
  return parent_.Get();
}
inline void CreateNVMeSubsystemRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateNVMeSubsystemRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateNVMeSubsystemRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeSubsystemRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateNVMeSubsystemRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeSubsystemRequest.parent)
}

// .opi_api.storage.v1.NVMeSubsystem nv_me_subsystem = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNVMeSubsystemRequest::_internal_has_nv_me_subsystem() const {
  return this != internal_default_instance() && nv_me_subsystem_ != nullptr;
}
inline bool CreateNVMeSubsystemRequest::has_nv_me_subsystem() const {
  return _internal_has_nv_me_subsystem();
}
inline void CreateNVMeSubsystemRequest::clear_nv_me_subsystem() {
  if (GetArenaForAllocation() == nullptr && nv_me_subsystem_ != nullptr) {
    delete nv_me_subsystem_;
  }
  nv_me_subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& CreateNVMeSubsystemRequest::_internal_nv_me_subsystem() const {
  const ::opi_api::storage::v1::NVMeSubsystem* p = nv_me_subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystem&>(
      ::opi_api::storage::v1::_NVMeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& CreateNVMeSubsystemRequest::nv_me_subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem)
  return _internal_nv_me_subsystem();
}
inline void CreateNVMeSubsystemRequest::unsafe_arena_set_allocated_nv_me_subsystem(
    ::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nv_me_subsystem_);
  }
  nv_me_subsystem_ = nv_me_subsystem;
  if (nv_me_subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem)
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::release_nv_me_subsystem() {
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = nv_me_subsystem_;
  nv_me_subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::unsafe_arena_release_nv_me_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem)
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = nv_me_subsystem_;
  nv_me_subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::_internal_mutable_nv_me_subsystem() {
  
  if (nv_me_subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(GetArenaForAllocation());
    nv_me_subsystem_ = p;
  }
  return nv_me_subsystem_;
}
inline ::opi_api::storage::v1::NVMeSubsystem* CreateNVMeSubsystemRequest::mutable_nv_me_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _msg = _internal_mutable_nv_me_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem)
  return _msg;
}
inline void CreateNVMeSubsystemRequest::set_allocated_nv_me_subsystem(::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nv_me_subsystem_;
  }
  if (nv_me_subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystem>::GetOwningArena(nv_me_subsystem);
    if (message_arena != submessage_arena) {
      nv_me_subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nv_me_subsystem, submessage_arena);
    }
    
  } else {
    
  }
  nv_me_subsystem_ = nv_me_subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem)
}

// string nv_me_subsystem_id = 3;
inline void CreateNVMeSubsystemRequest::clear_nv_me_subsystem_id() {
  nv_me_subsystem_id_.ClearToEmpty();
}
inline const std::string& CreateNVMeSubsystemRequest::nv_me_subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem_id)
  return _internal_nv_me_subsystem_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNVMeSubsystemRequest::set_nv_me_subsystem_id(ArgT0&& arg0, ArgT... args) {
 
 nv_me_subsystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem_id)
}
inline std::string* CreateNVMeSubsystemRequest::mutable_nv_me_subsystem_id() {
  std::string* _s = _internal_mutable_nv_me_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem_id)
  return _s;
}
inline const std::string& CreateNVMeSubsystemRequest::_internal_nv_me_subsystem_id() const {
  return nv_me_subsystem_id_.Get();
}
inline void CreateNVMeSubsystemRequest::_internal_set_nv_me_subsystem_id(const std::string& value) {
  
  nv_me_subsystem_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateNVMeSubsystemRequest::_internal_mutable_nv_me_subsystem_id() {
  
  return nv_me_subsystem_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateNVMeSubsystemRequest::release_nv_me_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem_id)
  return nv_me_subsystem_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateNVMeSubsystemRequest::set_allocated_nv_me_subsystem_id(std::string* nv_me_subsystem_id) {
  if (nv_me_subsystem_id != nullptr) {
    
  } else {
    
  }
  nv_me_subsystem_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nv_me_subsystem_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nv_me_subsystem_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nv_me_subsystem_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeSubsystemRequest.nv_me_subsystem_id)
}

// -------------------------------------------------------------------

// DeleteNVMeSubsystemRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNVMeSubsystemRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DeleteNVMeSubsystemRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNVMeSubsystemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNVMeSubsystemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNVMeSubsystemRequest.name)
}
inline std::string* DeleteNVMeSubsystemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNVMeSubsystemRequest.name)
  return _s;
}
inline const std::string& DeleteNVMeSubsystemRequest::_internal_name() const {
  return name_.Get();
}
inline void DeleteNVMeSubsystemRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteNVMeSubsystemRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteNVMeSubsystemRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNVMeSubsystemRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteNVMeSubsystemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNVMeSubsystemRequest.name)
}

// -------------------------------------------------------------------

// UpdateNVMeSubsystemRequest

// .opi_api.storage.v1.NVMeSubsystem nv_me_subsystem = 1;
inline bool UpdateNVMeSubsystemRequest::_internal_has_nv_me_subsystem() const {
  return this != internal_default_instance() && nv_me_subsystem_ != nullptr;
}
inline bool UpdateNVMeSubsystemRequest::has_nv_me_subsystem() const {
  return _internal_has_nv_me_subsystem();
}
inline void UpdateNVMeSubsystemRequest::clear_nv_me_subsystem() {
  if (GetArenaForAllocation() == nullptr && nv_me_subsystem_ != nullptr) {
    delete nv_me_subsystem_;
  }
  nv_me_subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& UpdateNVMeSubsystemRequest::_internal_nv_me_subsystem() const {
  const ::opi_api::storage::v1::NVMeSubsystem* p = nv_me_subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeSubsystem&>(
      ::opi_api::storage::v1::_NVMeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& UpdateNVMeSubsystemRequest::nv_me_subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeSubsystemRequest.nv_me_subsystem)
  return _internal_nv_me_subsystem();
}
inline void UpdateNVMeSubsystemRequest::unsafe_arena_set_allocated_nv_me_subsystem(
    ::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nv_me_subsystem_);
  }
  nv_me_subsystem_ = nv_me_subsystem;
  if (nv_me_subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeSubsystemRequest.nv_me_subsystem)
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::release_nv_me_subsystem() {
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = nv_me_subsystem_;
  nv_me_subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::unsafe_arena_release_nv_me_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeSubsystemRequest.nv_me_subsystem)
  
  ::opi_api::storage::v1::NVMeSubsystem* temp = nv_me_subsystem_;
  nv_me_subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::_internal_mutable_nv_me_subsystem() {
  
  if (nv_me_subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeSubsystem>(GetArenaForAllocation());
    nv_me_subsystem_ = p;
  }
  return nv_me_subsystem_;
}
inline ::opi_api::storage::v1::NVMeSubsystem* UpdateNVMeSubsystemRequest::mutable_nv_me_subsystem() {
  ::opi_api::storage::v1::NVMeSubsystem* _msg = _internal_mutable_nv_me_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeSubsystemRequest.nv_me_subsystem)
  return _msg;
}
inline void UpdateNVMeSubsystemRequest::set_allocated_nv_me_subsystem(::opi_api::storage::v1::NVMeSubsystem* nv_me_subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nv_me_subsystem_;
  }
  if (nv_me_subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeSubsystem>::GetOwningArena(nv_me_subsystem);
    if (message_arena != submessage_arena) {
      nv_me_subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nv_me_subsystem, submessage_arena);
    }
    
  } else {
    
  }
  nv_me_subsystem_ = nv_me_subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeSubsystemRequest.nv_me_subsystem)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateNVMeSubsystemRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && update_mask_ != nullptr;
}
inline bool UpdateNVMeSubsystemRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNVMeSubsystemRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNVMeSubsystemRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeSubsystemRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNVMeSubsystemRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeSubsystemRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeSubsystemRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeSubsystemRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeSubsystemRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeSubsystemRequest::_internal_mutable_update_mask() {
  
  if (update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    update_mask_ = p;
  }
  return update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeSubsystemRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeSubsystemRequest.update_mask)
  return _msg;
}
inline void UpdateNVMeSubsystemRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeSubsystemRequest.update_mask)
}

// -------------------------------------------------------------------

// ListNVMeSubsystemsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNVMeSubsystemsRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& ListNVMeSubsystemsRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeSubsystemsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemsRequest.parent)
}
inline std::string* ListNVMeSubsystemsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemsRequest.parent)
  return _s;
}
inline const std::string& ListNVMeSubsystemsRequest::_internal_parent() const {
  return parent_.Get();
}
inline void ListNVMeSubsystemsRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemsRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeSubsystemsRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeSubsystemsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeSubsystemsRequest.parent)
}

// int32 page_size = 2;
inline void ListNVMeSubsystemsRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListNVMeSubsystemsRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListNVMeSubsystemsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_size)
  return _internal_page_size();
}
inline void ListNVMeSubsystemsRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListNVMeSubsystemsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_size)
}

// string page_token = 3;
inline void ListNVMeSubsystemsRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeSubsystemsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeSubsystemsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_token)
}
inline std::string* ListNVMeSubsystemsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_token)
  return _s;
}
inline const std::string& ListNVMeSubsystemsRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListNVMeSubsystemsRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemsRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeSubsystemsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeSubsystemsRequest.page_token)
}

// -------------------------------------------------------------------

// ListNVMeSubsystemsResponse

// repeated .opi_api.storage.v1.NVMeSubsystem nv_me_subsystems = 1;
inline int ListNVMeSubsystemsResponse::_internal_nv_me_subsystems_size() const {
  return nv_me_subsystems_.size();
}
inline int ListNVMeSubsystemsResponse::nv_me_subsystems_size() const {
  return _internal_nv_me_subsystems_size();
}
inline void ListNVMeSubsystemsResponse::clear_nv_me_subsystems() {
  nv_me_subsystems_.Clear();
}
inline ::opi_api::storage::v1::NVMeSubsystem* ListNVMeSubsystemsResponse::mutable_nv_me_subsystems(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemsResponse.nv_me_subsystems)
  return nv_me_subsystems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >*
ListNVMeSubsystemsResponse::mutable_nv_me_subsystems() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNVMeSubsystemsResponse.nv_me_subsystems)
  return &nv_me_subsystems_;
}
inline const ::opi_api::storage::v1::NVMeSubsystem& ListNVMeSubsystemsResponse::_internal_nv_me_subsystems(int index) const {
  return nv_me_subsystems_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeSubsystem& ListNVMeSubsystemsResponse::nv_me_subsystems(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemsResponse.nv_me_subsystems)
  return _internal_nv_me_subsystems(index);
}
inline ::opi_api::storage::v1::NVMeSubsystem* ListNVMeSubsystemsResponse::_internal_add_nv_me_subsystems() {
  return nv_me_subsystems_.Add();
}
inline ::opi_api::storage::v1::NVMeSubsystem* ListNVMeSubsystemsResponse::add_nv_me_subsystems() {
  ::opi_api::storage::v1::NVMeSubsystem* _add = _internal_add_nv_me_subsystems();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNVMeSubsystemsResponse.nv_me_subsystems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeSubsystem >&
ListNVMeSubsystemsResponse::nv_me_subsystems() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNVMeSubsystemsResponse.nv_me_subsystems)
  return nv_me_subsystems_;
}

// string next_page_token = 2;
inline void ListNVMeSubsystemsResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeSubsystemsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeSubsystemsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeSubsystemsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeSubsystemsResponse.next_page_token)
}
inline std::string* ListNVMeSubsystemsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeSubsystemsResponse.next_page_token)
  return _s;
}
inline const std::string& ListNVMeSubsystemsResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListNVMeSubsystemsResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemsResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeSubsystemsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeSubsystemsResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeSubsystemsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeSubsystemsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNVMeSubsystemRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNVMeSubsystemRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetNVMeSubsystemRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNVMeSubsystemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNVMeSubsystemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNVMeSubsystemRequest.name)
}
inline std::string* GetNVMeSubsystemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNVMeSubsystemRequest.name)
  return _s;
}
inline const std::string& GetNVMeSubsystemRequest::_internal_name() const {
  return name_.Get();
}
inline void GetNVMeSubsystemRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNVMeSubsystemRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNVMeSubsystemRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNVMeSubsystemRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNVMeSubsystemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNVMeSubsystemRequest.name)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatsRequest

// .opi_api.common.v1.ObjectKey subsystem_id = 1;
inline bool NVMeSubsystemStatsRequest::_internal_has_subsystem_id() const {
  return this != internal_default_instance() && subsystem_id_ != nullptr;
}
inline bool NVMeSubsystemStatsRequest::has_subsystem_id() const {
  return _internal_has_subsystem_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemStatsRequest::_internal_subsystem_id() const {
  const ::opi_api::common::v1::ObjectKey* p = subsystem_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeSubsystemStatsRequest::subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  return _internal_subsystem_id();
}
inline void NVMeSubsystemStatsRequest::unsafe_arena_set_allocated_subsystem_id(
    ::opi_api::common::v1::ObjectKey* subsystem_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  subsystem_id_ = subsystem_id;
  if (subsystem_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::release_subsystem_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::unsafe_arena_release_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  
  ::opi_api::common::v1::ObjectKey* temp = subsystem_id_;
  subsystem_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::_internal_mutable_subsystem_id() {
  
  if (subsystem_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    subsystem_id_ = p;
  }
  return subsystem_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeSubsystemStatsRequest::mutable_subsystem_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
  return _msg;
}
inline void NVMeSubsystemStatsRequest::set_allocated_subsystem_id(::opi_api::common::v1::ObjectKey* subsystem_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id_);
  }
  if (subsystem_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsystem_id));
    if (message_arena != submessage_arena) {
      subsystem_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsystem_id, submessage_arena);
    }
    
  } else {
    
  }
  subsystem_id_ = subsystem_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsRequest.subsystem_id)
}

// -------------------------------------------------------------------

// NVMeSubsystemStatsResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool NVMeSubsystemStatsResponse::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool NVMeSubsystemStatsResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& NVMeSubsystemStatsResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& NVMeSubsystemStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return _internal_stats();
}
inline void NVMeSubsystemStatsResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* NVMeSubsystemStatsResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeSubsystemStatsResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeSubsystemStatsResponse::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeSubsystemStatsResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
  return _msg;
}
inline void NVMeSubsystemStatsResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeSubsystemStatsResponse.stats)
}

// -------------------------------------------------------------------

// CreateNVMeControllerRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateNVMeControllerRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& CreateNVMeControllerRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeControllerRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNVMeControllerRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNVMeControllerRequest.parent)
}
inline std::string* CreateNVMeControllerRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeControllerRequest.parent)
  return _s;
}
inline const std::string& CreateNVMeControllerRequest::_internal_parent() const {
  return parent_.Get();
}
inline void CreateNVMeControllerRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateNVMeControllerRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateNVMeControllerRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeControllerRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateNVMeControllerRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeControllerRequest.parent)
}

// .opi_api.storage.v1.NVMeController nv_me_controller = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNVMeControllerRequest::_internal_has_nv_me_controller() const {
  return this != internal_default_instance() && nv_me_controller_ != nullptr;
}
inline bool CreateNVMeControllerRequest::has_nv_me_controller() const {
  return _internal_has_nv_me_controller();
}
inline void CreateNVMeControllerRequest::clear_nv_me_controller() {
  if (GetArenaForAllocation() == nullptr && nv_me_controller_ != nullptr) {
    delete nv_me_controller_;
  }
  nv_me_controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeController& CreateNVMeControllerRequest::_internal_nv_me_controller() const {
  const ::opi_api::storage::v1::NVMeController* p = nv_me_controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeController&>(
      ::opi_api::storage::v1::_NVMeController_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeController& CreateNVMeControllerRequest::nv_me_controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller)
  return _internal_nv_me_controller();
}
inline void CreateNVMeControllerRequest::unsafe_arena_set_allocated_nv_me_controller(
    ::opi_api::storage::v1::NVMeController* nv_me_controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nv_me_controller_);
  }
  nv_me_controller_ = nv_me_controller;
  if (nv_me_controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller)
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::release_nv_me_controller() {
  
  ::opi_api::storage::v1::NVMeController* temp = nv_me_controller_;
  nv_me_controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::unsafe_arena_release_nv_me_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller)
  
  ::opi_api::storage::v1::NVMeController* temp = nv_me_controller_;
  nv_me_controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::_internal_mutable_nv_me_controller() {
  
  if (nv_me_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(GetArenaForAllocation());
    nv_me_controller_ = p;
  }
  return nv_me_controller_;
}
inline ::opi_api::storage::v1::NVMeController* CreateNVMeControllerRequest::mutable_nv_me_controller() {
  ::opi_api::storage::v1::NVMeController* _msg = _internal_mutable_nv_me_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller)
  return _msg;
}
inline void CreateNVMeControllerRequest::set_allocated_nv_me_controller(::opi_api::storage::v1::NVMeController* nv_me_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nv_me_controller_;
  }
  if (nv_me_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeController>::GetOwningArena(nv_me_controller);
    if (message_arena != submessage_arena) {
      nv_me_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nv_me_controller, submessage_arena);
    }
    
  } else {
    
  }
  nv_me_controller_ = nv_me_controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller)
}

// string nv_me_controller_id = 3;
inline void CreateNVMeControllerRequest::clear_nv_me_controller_id() {
  nv_me_controller_id_.ClearToEmpty();
}
inline const std::string& CreateNVMeControllerRequest::nv_me_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller_id)
  return _internal_nv_me_controller_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNVMeControllerRequest::set_nv_me_controller_id(ArgT0&& arg0, ArgT... args) {
 
 nv_me_controller_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller_id)
}
inline std::string* CreateNVMeControllerRequest::mutable_nv_me_controller_id() {
  std::string* _s = _internal_mutable_nv_me_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller_id)
  return _s;
}
inline const std::string& CreateNVMeControllerRequest::_internal_nv_me_controller_id() const {
  return nv_me_controller_id_.Get();
}
inline void CreateNVMeControllerRequest::_internal_set_nv_me_controller_id(const std::string& value) {
  
  nv_me_controller_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateNVMeControllerRequest::_internal_mutable_nv_me_controller_id() {
  
  return nv_me_controller_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateNVMeControllerRequest::release_nv_me_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller_id)
  return nv_me_controller_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateNVMeControllerRequest::set_allocated_nv_me_controller_id(std::string* nv_me_controller_id) {
  if (nv_me_controller_id != nullptr) {
    
  } else {
    
  }
  nv_me_controller_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nv_me_controller_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nv_me_controller_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nv_me_controller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeControllerRequest.nv_me_controller_id)
}

// -------------------------------------------------------------------

// DeleteNVMeControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNVMeControllerRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DeleteNVMeControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNVMeControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNVMeControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNVMeControllerRequest.name)
}
inline std::string* DeleteNVMeControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNVMeControllerRequest.name)
  return _s;
}
inline const std::string& DeleteNVMeControllerRequest::_internal_name() const {
  return name_.Get();
}
inline void DeleteNVMeControllerRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteNVMeControllerRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteNVMeControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNVMeControllerRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteNVMeControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNVMeControllerRequest.name)
}

// -------------------------------------------------------------------

// UpdateNVMeControllerRequest

// .opi_api.storage.v1.NVMeController nv_me_controller = 1;
inline bool UpdateNVMeControllerRequest::_internal_has_nv_me_controller() const {
  return this != internal_default_instance() && nv_me_controller_ != nullptr;
}
inline bool UpdateNVMeControllerRequest::has_nv_me_controller() const {
  return _internal_has_nv_me_controller();
}
inline void UpdateNVMeControllerRequest::clear_nv_me_controller() {
  if (GetArenaForAllocation() == nullptr && nv_me_controller_ != nullptr) {
    delete nv_me_controller_;
  }
  nv_me_controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeController& UpdateNVMeControllerRequest::_internal_nv_me_controller() const {
  const ::opi_api::storage::v1::NVMeController* p = nv_me_controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeController&>(
      ::opi_api::storage::v1::_NVMeController_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeController& UpdateNVMeControllerRequest::nv_me_controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeControllerRequest.nv_me_controller)
  return _internal_nv_me_controller();
}
inline void UpdateNVMeControllerRequest::unsafe_arena_set_allocated_nv_me_controller(
    ::opi_api::storage::v1::NVMeController* nv_me_controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nv_me_controller_);
  }
  nv_me_controller_ = nv_me_controller;
  if (nv_me_controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeControllerRequest.nv_me_controller)
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::release_nv_me_controller() {
  
  ::opi_api::storage::v1::NVMeController* temp = nv_me_controller_;
  nv_me_controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::unsafe_arena_release_nv_me_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeControllerRequest.nv_me_controller)
  
  ::opi_api::storage::v1::NVMeController* temp = nv_me_controller_;
  nv_me_controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::_internal_mutable_nv_me_controller() {
  
  if (nv_me_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeController>(GetArenaForAllocation());
    nv_me_controller_ = p;
  }
  return nv_me_controller_;
}
inline ::opi_api::storage::v1::NVMeController* UpdateNVMeControllerRequest::mutable_nv_me_controller() {
  ::opi_api::storage::v1::NVMeController* _msg = _internal_mutable_nv_me_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeControllerRequest.nv_me_controller)
  return _msg;
}
inline void UpdateNVMeControllerRequest::set_allocated_nv_me_controller(::opi_api::storage::v1::NVMeController* nv_me_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nv_me_controller_;
  }
  if (nv_me_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeController>::GetOwningArena(nv_me_controller);
    if (message_arena != submessage_arena) {
      nv_me_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nv_me_controller, submessage_arena);
    }
    
  } else {
    
  }
  nv_me_controller_ = nv_me_controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeControllerRequest.nv_me_controller)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateNVMeControllerRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && update_mask_ != nullptr;
}
inline bool UpdateNVMeControllerRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNVMeControllerRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNVMeControllerRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeControllerRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNVMeControllerRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeControllerRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeControllerRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeControllerRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeControllerRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeControllerRequest::_internal_mutable_update_mask() {
  
  if (update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    update_mask_ = p;
  }
  return update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeControllerRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeControllerRequest.update_mask)
  return _msg;
}
inline void UpdateNVMeControllerRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeControllerRequest.update_mask)
}

// -------------------------------------------------------------------

// ListNVMeControllersRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNVMeControllersRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& ListNVMeControllersRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllersRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeControllersRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllersRequest.parent)
}
inline std::string* ListNVMeControllersRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllersRequest.parent)
  return _s;
}
inline const std::string& ListNVMeControllersRequest::_internal_parent() const {
  return parent_.Get();
}
inline void ListNVMeControllersRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeControllersRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeControllersRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeControllersRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeControllersRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeControllersRequest.parent)
}

// int32 page_size = 2;
inline void ListNVMeControllersRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListNVMeControllersRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListNVMeControllersRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllersRequest.page_size)
  return _internal_page_size();
}
inline void ListNVMeControllersRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListNVMeControllersRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllersRequest.page_size)
}

// string page_token = 3;
inline void ListNVMeControllersRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeControllersRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllersRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeControllersRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllersRequest.page_token)
}
inline std::string* ListNVMeControllersRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllersRequest.page_token)
  return _s;
}
inline const std::string& ListNVMeControllersRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListNVMeControllersRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeControllersRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeControllersRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeControllersRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeControllersRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeControllersRequest.page_token)
}

// -------------------------------------------------------------------

// ListNVMeControllersResponse

// repeated .opi_api.storage.v1.NVMeController nv_me_controllers = 1;
inline int ListNVMeControllersResponse::_internal_nv_me_controllers_size() const {
  return nv_me_controllers_.size();
}
inline int ListNVMeControllersResponse::nv_me_controllers_size() const {
  return _internal_nv_me_controllers_size();
}
inline void ListNVMeControllersResponse::clear_nv_me_controllers() {
  nv_me_controllers_.Clear();
}
inline ::opi_api::storage::v1::NVMeController* ListNVMeControllersResponse::mutable_nv_me_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllersResponse.nv_me_controllers)
  return nv_me_controllers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >*
ListNVMeControllersResponse::mutable_nv_me_controllers() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNVMeControllersResponse.nv_me_controllers)
  return &nv_me_controllers_;
}
inline const ::opi_api::storage::v1::NVMeController& ListNVMeControllersResponse::_internal_nv_me_controllers(int index) const {
  return nv_me_controllers_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeController& ListNVMeControllersResponse::nv_me_controllers(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllersResponse.nv_me_controllers)
  return _internal_nv_me_controllers(index);
}
inline ::opi_api::storage::v1::NVMeController* ListNVMeControllersResponse::_internal_add_nv_me_controllers() {
  return nv_me_controllers_.Add();
}
inline ::opi_api::storage::v1::NVMeController* ListNVMeControllersResponse::add_nv_me_controllers() {
  ::opi_api::storage::v1::NVMeController* _add = _internal_add_nv_me_controllers();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNVMeControllersResponse.nv_me_controllers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeController >&
ListNVMeControllersResponse::nv_me_controllers() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNVMeControllersResponse.nv_me_controllers)
  return nv_me_controllers_;
}

// string next_page_token = 2;
inline void ListNVMeControllersResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeControllersResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeControllersResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeControllersResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeControllersResponse.next_page_token)
}
inline std::string* ListNVMeControllersResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeControllersResponse.next_page_token)
  return _s;
}
inline const std::string& ListNVMeControllersResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListNVMeControllersResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeControllersResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeControllersResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeControllersResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeControllersResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeControllersResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNVMeControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNVMeControllerRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetNVMeControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNVMeControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNVMeControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNVMeControllerRequest.name)
}
inline std::string* GetNVMeControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNVMeControllerRequest.name)
  return _s;
}
inline const std::string& GetNVMeControllerRequest::_internal_name() const {
  return name_.Get();
}
inline void GetNVMeControllerRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNVMeControllerRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNVMeControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNVMeControllerRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNVMeControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNVMeControllerRequest.name)
}

// -------------------------------------------------------------------

// NVMeControllerStatsRequest

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerStatsRequest::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerStatsRequest::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsRequest::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsRequest::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  return _internal_id();
}
inline void NVMeControllerStatsRequest::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsRequest.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsRequest::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsRequest.id)
  return _msg;
}
inline void NVMeControllerStatsRequest::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsRequest.id)
}

// -------------------------------------------------------------------

// NVMeControllerStatsResponse

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeControllerStatsResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeControllerStatsResponse::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsResponse::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeControllerStatsResponse::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  return _internal_id();
}
inline void NVMeControllerStatsResponse::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeControllerStatsResponse::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsResponse.id)
  return _msg;
}
inline void NVMeControllerStatsResponse::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.id)
}

// .opi_api.storage.v1.VolumeStats stats = 2;
inline bool NVMeControllerStatsResponse::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool NVMeControllerStatsResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& NVMeControllerStatsResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& NVMeControllerStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return _internal_stats();
}
inline void NVMeControllerStatsResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* NVMeControllerStatsResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeControllerStatsResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeControllerStatsResponse::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeControllerStatsResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
  return _msg;
}
inline void NVMeControllerStatsResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeControllerStatsResponse.stats)
}

// -------------------------------------------------------------------

// CreateNVMeNamespaceRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateNVMeNamespaceRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& CreateNVMeNamespaceRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeNamespaceRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNVMeNamespaceRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNVMeNamespaceRequest.parent)
}
inline std::string* CreateNVMeNamespaceRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeNamespaceRequest.parent)
  return _s;
}
inline const std::string& CreateNVMeNamespaceRequest::_internal_parent() const {
  return parent_.Get();
}
inline void CreateNVMeNamespaceRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateNVMeNamespaceRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateNVMeNamespaceRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeNamespaceRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateNVMeNamespaceRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeNamespaceRequest.parent)
}

// .opi_api.storage.v1.NVMeNamespace nv_me_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNVMeNamespaceRequest::_internal_has_nv_me_namespace() const {
  return this != internal_default_instance() && nv_me_namespace_ != nullptr;
}
inline bool CreateNVMeNamespaceRequest::has_nv_me_namespace() const {
  return _internal_has_nv_me_namespace();
}
inline void CreateNVMeNamespaceRequest::clear_nv_me_namespace() {
  if (GetArenaForAllocation() == nullptr && nv_me_namespace_ != nullptr) {
    delete nv_me_namespace_;
  }
  nv_me_namespace_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespace& CreateNVMeNamespaceRequest::_internal_nv_me_namespace() const {
  const ::opi_api::storage::v1::NVMeNamespace* p = nv_me_namespace_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespace&>(
      ::opi_api::storage::v1::_NVMeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespace& CreateNVMeNamespaceRequest::nv_me_namespace() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace)
  return _internal_nv_me_namespace();
}
inline void CreateNVMeNamespaceRequest::unsafe_arena_set_allocated_nv_me_namespace(
    ::opi_api::storage::v1::NVMeNamespace* nv_me_namespace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nv_me_namespace_);
  }
  nv_me_namespace_ = nv_me_namespace;
  if (nv_me_namespace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace)
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::release_nv_me_namespace() {
  
  ::opi_api::storage::v1::NVMeNamespace* temp = nv_me_namespace_;
  nv_me_namespace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::unsafe_arena_release_nv_me_namespace() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace)
  
  ::opi_api::storage::v1::NVMeNamespace* temp = nv_me_namespace_;
  nv_me_namespace_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::_internal_mutable_nv_me_namespace() {
  
  if (nv_me_namespace_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(GetArenaForAllocation());
    nv_me_namespace_ = p;
  }
  return nv_me_namespace_;
}
inline ::opi_api::storage::v1::NVMeNamespace* CreateNVMeNamespaceRequest::mutable_nv_me_namespace() {
  ::opi_api::storage::v1::NVMeNamespace* _msg = _internal_mutable_nv_me_namespace();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace)
  return _msg;
}
inline void CreateNVMeNamespaceRequest::set_allocated_nv_me_namespace(::opi_api::storage::v1::NVMeNamespace* nv_me_namespace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nv_me_namespace_;
  }
  if (nv_me_namespace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespace>::GetOwningArena(nv_me_namespace);
    if (message_arena != submessage_arena) {
      nv_me_namespace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nv_me_namespace, submessage_arena);
    }
    
  } else {
    
  }
  nv_me_namespace_ = nv_me_namespace;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace)
}

// string nv_me_namespace_id = 3;
inline void CreateNVMeNamespaceRequest::clear_nv_me_namespace_id() {
  nv_me_namespace_id_.ClearToEmpty();
}
inline const std::string& CreateNVMeNamespaceRequest::nv_me_namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace_id)
  return _internal_nv_me_namespace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNVMeNamespaceRequest::set_nv_me_namespace_id(ArgT0&& arg0, ArgT... args) {
 
 nv_me_namespace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace_id)
}
inline std::string* CreateNVMeNamespaceRequest::mutable_nv_me_namespace_id() {
  std::string* _s = _internal_mutable_nv_me_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace_id)
  return _s;
}
inline const std::string& CreateNVMeNamespaceRequest::_internal_nv_me_namespace_id() const {
  return nv_me_namespace_id_.Get();
}
inline void CreateNVMeNamespaceRequest::_internal_set_nv_me_namespace_id(const std::string& value) {
  
  nv_me_namespace_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateNVMeNamespaceRequest::_internal_mutable_nv_me_namespace_id() {
  
  return nv_me_namespace_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateNVMeNamespaceRequest::release_nv_me_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace_id)
  return nv_me_namespace_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateNVMeNamespaceRequest::set_allocated_nv_me_namespace_id(std::string* nv_me_namespace_id) {
  if (nv_me_namespace_id != nullptr) {
    
  } else {
    
  }
  nv_me_namespace_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nv_me_namespace_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nv_me_namespace_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nv_me_namespace_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNVMeNamespaceRequest.nv_me_namespace_id)
}

// -------------------------------------------------------------------

// DeleteNVMeNamespaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNVMeNamespaceRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DeleteNVMeNamespaceRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNVMeNamespaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNVMeNamespaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNVMeNamespaceRequest.name)
}
inline std::string* DeleteNVMeNamespaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNVMeNamespaceRequest.name)
  return _s;
}
inline const std::string& DeleteNVMeNamespaceRequest::_internal_name() const {
  return name_.Get();
}
inline void DeleteNVMeNamespaceRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteNVMeNamespaceRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteNVMeNamespaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNVMeNamespaceRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteNVMeNamespaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNVMeNamespaceRequest.name)
}

// -------------------------------------------------------------------

// UpdateNVMeNamespaceRequest

// .opi_api.storage.v1.NVMeNamespace nv_me_namespace = 1;
inline bool UpdateNVMeNamespaceRequest::_internal_has_nv_me_namespace() const {
  return this != internal_default_instance() && nv_me_namespace_ != nullptr;
}
inline bool UpdateNVMeNamespaceRequest::has_nv_me_namespace() const {
  return _internal_has_nv_me_namespace();
}
inline void UpdateNVMeNamespaceRequest::clear_nv_me_namespace() {
  if (GetArenaForAllocation() == nullptr && nv_me_namespace_ != nullptr) {
    delete nv_me_namespace_;
  }
  nv_me_namespace_ = nullptr;
}
inline const ::opi_api::storage::v1::NVMeNamespace& UpdateNVMeNamespaceRequest::_internal_nv_me_namespace() const {
  const ::opi_api::storage::v1::NVMeNamespace* p = nv_me_namespace_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NVMeNamespace&>(
      ::opi_api::storage::v1::_NVMeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NVMeNamespace& UpdateNVMeNamespaceRequest::nv_me_namespace() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeNamespaceRequest.nv_me_namespace)
  return _internal_nv_me_namespace();
}
inline void UpdateNVMeNamespaceRequest::unsafe_arena_set_allocated_nv_me_namespace(
    ::opi_api::storage::v1::NVMeNamespace* nv_me_namespace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nv_me_namespace_);
  }
  nv_me_namespace_ = nv_me_namespace;
  if (nv_me_namespace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeNamespaceRequest.nv_me_namespace)
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::release_nv_me_namespace() {
  
  ::opi_api::storage::v1::NVMeNamespace* temp = nv_me_namespace_;
  nv_me_namespace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::unsafe_arena_release_nv_me_namespace() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeNamespaceRequest.nv_me_namespace)
  
  ::opi_api::storage::v1::NVMeNamespace* temp = nv_me_namespace_;
  nv_me_namespace_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::_internal_mutable_nv_me_namespace() {
  
  if (nv_me_namespace_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NVMeNamespace>(GetArenaForAllocation());
    nv_me_namespace_ = p;
  }
  return nv_me_namespace_;
}
inline ::opi_api::storage::v1::NVMeNamespace* UpdateNVMeNamespaceRequest::mutable_nv_me_namespace() {
  ::opi_api::storage::v1::NVMeNamespace* _msg = _internal_mutable_nv_me_namespace();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeNamespaceRequest.nv_me_namespace)
  return _msg;
}
inline void UpdateNVMeNamespaceRequest::set_allocated_nv_me_namespace(::opi_api::storage::v1::NVMeNamespace* nv_me_namespace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nv_me_namespace_;
  }
  if (nv_me_namespace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::opi_api::storage::v1::NVMeNamespace>::GetOwningArena(nv_me_namespace);
    if (message_arena != submessage_arena) {
      nv_me_namespace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nv_me_namespace, submessage_arena);
    }
    
  } else {
    
  }
  nv_me_namespace_ = nv_me_namespace;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeNamespaceRequest.nv_me_namespace)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateNVMeNamespaceRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && update_mask_ != nullptr;
}
inline bool UpdateNVMeNamespaceRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNVMeNamespaceRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNVMeNamespaceRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNVMeNamespaceRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNVMeNamespaceRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNVMeNamespaceRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeNamespaceRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeNamespaceRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNVMeNamespaceRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = update_mask_;
  update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeNamespaceRequest::_internal_mutable_update_mask() {
  
  if (update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    update_mask_ = p;
  }
  return update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNVMeNamespaceRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNVMeNamespaceRequest.update_mask)
  return _msg;
}
inline void UpdateNVMeNamespaceRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNVMeNamespaceRequest.update_mask)
}

// -------------------------------------------------------------------

// ListNVMeNamespacesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNVMeNamespacesRequest::clear_parent() {
  parent_.ClearToEmpty();
}
inline const std::string& ListNVMeNamespacesRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespacesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeNamespacesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespacesRequest.parent)
}
inline std::string* ListNVMeNamespacesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespacesRequest.parent)
  return _s;
}
inline const std::string& ListNVMeNamespacesRequest::_internal_parent() const {
  return parent_.Get();
}
inline void ListNVMeNamespacesRequest::_internal_set_parent(const std::string& value) {
  
  parent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespacesRequest::_internal_mutable_parent() {
  
  return parent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespacesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespacesRequest.parent)
  return parent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeNamespacesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  parent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (parent_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    parent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespacesRequest.parent)
}

// int32 page_size = 2;
inline void ListNVMeNamespacesRequest::clear_page_size() {
  page_size_ = 0;
}
inline int32_t ListNVMeNamespacesRequest::_internal_page_size() const {
  return page_size_;
}
inline int32_t ListNVMeNamespacesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespacesRequest.page_size)
  return _internal_page_size();
}
inline void ListNVMeNamespacesRequest::_internal_set_page_size(int32_t value) {
  
  page_size_ = value;
}
inline void ListNVMeNamespacesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespacesRequest.page_size)
}

// string page_token = 3;
inline void ListNVMeNamespacesRequest::clear_page_token() {
  page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeNamespacesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespacesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeNamespacesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespacesRequest.page_token)
}
inline std::string* ListNVMeNamespacesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespacesRequest.page_token)
  return _s;
}
inline const std::string& ListNVMeNamespacesRequest::_internal_page_token() const {
  return page_token_.Get();
}
inline void ListNVMeNamespacesRequest::_internal_set_page_token(const std::string& value) {
  
  page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespacesRequest::_internal_mutable_page_token() {
  
  return page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespacesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespacesRequest.page_token)
  return page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeNamespacesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespacesRequest.page_token)
}

// -------------------------------------------------------------------

// ListNVMeNamespacesResponse

// repeated .opi_api.storage.v1.NVMeNamespace nv_me_namespaces = 1;
inline int ListNVMeNamespacesResponse::_internal_nv_me_namespaces_size() const {
  return nv_me_namespaces_.size();
}
inline int ListNVMeNamespacesResponse::nv_me_namespaces_size() const {
  return _internal_nv_me_namespaces_size();
}
inline void ListNVMeNamespacesResponse::clear_nv_me_namespaces() {
  nv_me_namespaces_.Clear();
}
inline ::opi_api::storage::v1::NVMeNamespace* ListNVMeNamespacesResponse::mutable_nv_me_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespacesResponse.nv_me_namespaces)
  return nv_me_namespaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >*
ListNVMeNamespacesResponse::mutable_nv_me_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNVMeNamespacesResponse.nv_me_namespaces)
  return &nv_me_namespaces_;
}
inline const ::opi_api::storage::v1::NVMeNamespace& ListNVMeNamespacesResponse::_internal_nv_me_namespaces(int index) const {
  return nv_me_namespaces_.Get(index);
}
inline const ::opi_api::storage::v1::NVMeNamespace& ListNVMeNamespacesResponse::nv_me_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespacesResponse.nv_me_namespaces)
  return _internal_nv_me_namespaces(index);
}
inline ::opi_api::storage::v1::NVMeNamespace* ListNVMeNamespacesResponse::_internal_add_nv_me_namespaces() {
  return nv_me_namespaces_.Add();
}
inline ::opi_api::storage::v1::NVMeNamespace* ListNVMeNamespacesResponse::add_nv_me_namespaces() {
  ::opi_api::storage::v1::NVMeNamespace* _add = _internal_add_nv_me_namespaces();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNVMeNamespacesResponse.nv_me_namespaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NVMeNamespace >&
ListNVMeNamespacesResponse::nv_me_namespaces() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNVMeNamespacesResponse.nv_me_namespaces)
  return nv_me_namespaces_;
}

// string next_page_token = 2;
inline void ListNVMeNamespacesResponse::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& ListNVMeNamespacesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNVMeNamespacesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNVMeNamespacesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNVMeNamespacesResponse.next_page_token)
}
inline std::string* ListNVMeNamespacesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNVMeNamespacesResponse.next_page_token)
  return _s;
}
inline const std::string& ListNVMeNamespacesResponse::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void ListNVMeNamespacesResponse::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespacesResponse::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListNVMeNamespacesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNVMeNamespacesResponse.next_page_token)
  return next_page_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListNVMeNamespacesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_page_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    next_page_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNVMeNamespacesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNVMeNamespaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNVMeNamespaceRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GetNVMeNamespaceRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNVMeNamespaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNVMeNamespaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNVMeNamespaceRequest.name)
}
inline std::string* GetNVMeNamespaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNVMeNamespaceRequest.name)
  return _s;
}
inline const std::string& GetNVMeNamespaceRequest::_internal_name() const {
  return name_.Get();
}
inline void GetNVMeNamespaceRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNVMeNamespaceRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNVMeNamespaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNVMeNamespaceRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNVMeNamespaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNVMeNamespaceRequest.name)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatsRequest

// .opi_api.common.v1.ObjectKey namespace_id = 1;
inline bool NVMeNamespaceStatsRequest::_internal_has_namespace_id() const {
  return this != internal_default_instance() && namespace_id_ != nullptr;
}
inline bool NVMeNamespaceStatsRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsRequest::_internal_namespace_id() const {
  const ::opi_api::common::v1::ObjectKey* p = namespace_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  return _internal_namespace_id();
}
inline void NVMeNamespaceStatsRequest::unsafe_arena_set_allocated_namespace_id(
    ::opi_api::common::v1::ObjectKey* namespace_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  namespace_id_ = namespace_id;
  if (namespace_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::release_namespace_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::unsafe_arena_release_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  
  ::opi_api::common::v1::ObjectKey* temp = namespace_id_;
  namespace_id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::_internal_mutable_namespace_id() {
  
  if (namespace_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    namespace_id_ = p;
  }
  return namespace_id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsRequest::mutable_namespace_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
  return _msg;
}
inline void NVMeNamespaceStatsRequest::set_allocated_namespace_id(::opi_api::common::v1::ObjectKey* namespace_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id_);
  }
  if (namespace_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_id));
    if (message_arena != submessage_arena) {
      namespace_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_id, submessage_arena);
    }
    
  } else {
    
  }
  namespace_id_ = namespace_id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsRequest.namespace_id)
}

// -------------------------------------------------------------------

// NVMeNamespaceStatsResponse

// .opi_api.common.v1.ObjectKey id = 1;
inline bool NVMeNamespaceStatsResponse::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NVMeNamespaceStatsResponse::has_id() const {
  return _internal_has_id();
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsResponse::_internal_id() const {
  const ::opi_api::common::v1::ObjectKey* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::ObjectKey&>(
      ::opi_api::common::v1::_ObjectKey_default_instance_);
}
inline const ::opi_api::common::v1::ObjectKey& NVMeNamespaceStatsResponse::id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  return _internal_id();
}
inline void NVMeNamespaceStatsResponse::unsafe_arena_set_allocated_id(
    ::opi_api::common::v1::ObjectKey* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::release_id() {
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  
  ::opi_api::common::v1::ObjectKey* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::ObjectKey>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::opi_api::common::v1::ObjectKey* NVMeNamespaceStatsResponse::mutable_id() {
  ::opi_api::common::v1::ObjectKey* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
  return _msg;
}
inline void NVMeNamespaceStatsResponse::set_allocated_id(::opi_api::common::v1::ObjectKey* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.id)
}

// .opi_api.storage.v1.VolumeStats stats = 2;
inline bool NVMeNamespaceStatsResponse::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool NVMeNamespaceStatsResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& NVMeNamespaceStatsResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& NVMeNamespaceStatsResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return _internal_stats();
}
inline void NVMeNamespaceStatsResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* NVMeNamespaceStatsResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeNamespaceStatsResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeNamespaceStatsResponse::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::opi_api::storage::v1::VolumeStats* NVMeNamespaceStatsResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
  return _msg;
}
inline void NVMeNamespaceStatsResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NVMeNamespaceStatsResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::storage::v1::NVMeNamespacePciState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NVMeNamespacePciState>() {
  return ::opi_api::storage::v1::NVMeNamespacePciState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::storage::v1::NVMeNamespacePciOperState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NVMeNamespacePciOperState>() {
  return ::opi_api::storage::v1::NVMeNamespacePciOperState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_5fpcie_2eproto
