// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme_pcie.proto

#include "frontend_nvme_pcie.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace opi_api {
namespace storage {
namespace v1 {
PROTOBUF_CONSTEXPR NvmeSubsystem::NvmeSubsystem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeSubsystemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeSubsystemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeSubsystemDefaultTypeInternal() {}
  union {
    NvmeSubsystem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeSubsystemDefaultTypeInternal _NvmeSubsystem_default_instance_;
PROTOBUF_CONSTEXPR NvmeSubsystemSpec::NvmeSubsystemSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serial_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.model_number_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.max_namespaces_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeSubsystemSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeSubsystemSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeSubsystemSpecDefaultTypeInternal() {}
  union {
    NvmeSubsystemSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeSubsystemSpecDefaultTypeInternal _NvmeSubsystemSpec_default_instance_;
PROTOBUF_CONSTEXPR NvmeSubsystemStatus::NvmeSubsystemStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.firmware_revision_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fru_guid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeSubsystemStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeSubsystemStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeSubsystemStatusDefaultTypeInternal() {}
  union {
    NvmeSubsystemStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeSubsystemStatusDefaultTypeInternal _NvmeSubsystemStatus_default_instance_;
PROTOBUF_CONSTEXPR NvmeController::NvmeController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeControllerDefaultTypeInternal() {}
  union {
    NvmeController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeControllerDefaultTypeInternal _NvmeController_default_instance_;
PROTOBUF_CONSTEXPR NvmeControllerSpec::NvmeControllerSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pcie_id_)*/nullptr
  , /*decltype(_impl_.min_limit_)*/nullptr
  , /*decltype(_impl_.max_limit_)*/nullptr
  , /*decltype(_impl_.nvme_controller_id_)*/0
  , /*decltype(_impl_.max_nsq_)*/0
  , /*decltype(_impl_.max_ncq_)*/0
  , /*decltype(_impl_.sqes_)*/0
  , /*decltype(_impl_.cqes_)*/0
  , /*decltype(_impl_.max_namespaces_)*/0} {}
struct NvmeControllerSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeControllerSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeControllerSpecDefaultTypeInternal() {}
  union {
    NvmeControllerSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeControllerSpecDefaultTypeInternal _NvmeControllerSpec_default_instance_;
PROTOBUF_CONSTEXPR NvmeControllerStatus::NvmeControllerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeControllerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeControllerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeControllerStatusDefaultTypeInternal() {}
  union {
    NvmeControllerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeControllerStatusDefaultTypeInternal _NvmeControllerStatus_default_instance_;
PROTOBUF_CONSTEXPR NvmeNamespace::NvmeNamespace(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.spec_)*/nullptr
  , /*decltype(_impl_.status_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeNamespaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeNamespaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeNamespaceDefaultTypeInternal() {}
  union {
    NvmeNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeNamespaceDefaultTypeInternal _NvmeNamespace_default_instance_;
PROTOBUF_CONSTEXPR NvmeNamespaceSpec::NvmeNamespaceSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nguid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.volume_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.eui64_)*/int64_t{0}
  , /*decltype(_impl_.host_nsid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeNamespaceSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeNamespaceSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeNamespaceSpecDefaultTypeInternal() {}
  union {
    NvmeNamespaceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeNamespaceSpecDefaultTypeInternal _NvmeNamespaceSpec_default_instance_;
PROTOBUF_CONSTEXPR NvmeNamespaceStatus::NvmeNamespaceStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pci_state_)*/0
  , /*decltype(_impl_.pci_oper_state_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeNamespaceStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeNamespaceStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeNamespaceStatusDefaultTypeInternal() {}
  union {
    NvmeNamespaceStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeNamespaceStatusDefaultTypeInternal _NvmeNamespaceStatus_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmeSubsystemRequest::CreateNvmeSubsystemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_subsystem_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_subsystem_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmeSubsystemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmeSubsystemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    CreateNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmeSubsystemRequestDefaultTypeInternal _CreateNvmeSubsystemRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmeSubsystemRequest::DeleteNvmeSubsystemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmeSubsystemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmeSubsystemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmeSubsystemRequestDefaultTypeInternal _DeleteNvmeSubsystemRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmeSubsystemRequest::UpdateNvmeSubsystemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_subsystem_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmeSubsystemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmeSubsystemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmeSubsystemRequestDefaultTypeInternal _UpdateNvmeSubsystemRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeSubsystemsRequest::ListNvmeSubsystemsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeSubsystemsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeSubsystemsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeSubsystemsRequestDefaultTypeInternal() {}
  union {
    ListNvmeSubsystemsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeSubsystemsRequestDefaultTypeInternal _ListNvmeSubsystemsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeSubsystemsResponse::ListNvmeSubsystemsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_subsystems_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeSubsystemsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeSubsystemsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeSubsystemsResponseDefaultTypeInternal() {}
  union {
    ListNvmeSubsystemsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeSubsystemsResponseDefaultTypeInternal _ListNvmeSubsystemsResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeSubsystemRequest::GetNvmeSubsystemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeSubsystemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeSubsystemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    GetNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeSubsystemRequestDefaultTypeInternal _GetNvmeSubsystemRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeSubsystemRequest::StatsNvmeSubsystemRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeSubsystemRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeSubsystemRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeSubsystemRequestDefaultTypeInternal() {}
  union {
    StatsNvmeSubsystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeSubsystemRequestDefaultTypeInternal _StatsNvmeSubsystemRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeSubsystemResponse::StatsNvmeSubsystemResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeSubsystemResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeSubsystemResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeSubsystemResponseDefaultTypeInternal() {}
  union {
    StatsNvmeSubsystemResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeSubsystemResponseDefaultTypeInternal _StatsNvmeSubsystemResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmeControllerRequest::CreateNvmeControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_controller_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_controller_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmeControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmeControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmeControllerRequestDefaultTypeInternal() {}
  union {
    CreateNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmeControllerRequestDefaultTypeInternal _CreateNvmeControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmeControllerRequest::DeleteNvmeControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmeControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmeControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmeControllerRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmeControllerRequestDefaultTypeInternal _DeleteNvmeControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmeControllerRequest::UpdateNvmeControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_controller_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmeControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmeControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmeControllerRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmeControllerRequestDefaultTypeInternal _UpdateNvmeControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeControllersRequest::ListNvmeControllersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeControllersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeControllersRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeControllersRequestDefaultTypeInternal() {}
  union {
    ListNvmeControllersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeControllersRequestDefaultTypeInternal _ListNvmeControllersRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeControllersResponse::ListNvmeControllersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_controllers_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeControllersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeControllersResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeControllersResponseDefaultTypeInternal() {}
  union {
    ListNvmeControllersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeControllersResponseDefaultTypeInternal _ListNvmeControllersResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeControllerRequest::GetNvmeControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeControllerRequestDefaultTypeInternal() {}
  union {
    GetNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeControllerRequestDefaultTypeInternal _GetNvmeControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeControllerRequest::StatsNvmeControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeControllerRequestDefaultTypeInternal() {}
  union {
    StatsNvmeControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeControllerRequestDefaultTypeInternal _StatsNvmeControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeControllerResponse::StatsNvmeControllerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeControllerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeControllerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeControllerResponseDefaultTypeInternal() {}
  union {
    StatsNvmeControllerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeControllerResponseDefaultTypeInternal _StatsNvmeControllerResponse_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmeNamespaceRequest::CreateNvmeNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_namespace_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_namespace_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmeNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmeNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    CreateNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmeNamespaceRequestDefaultTypeInternal _CreateNvmeNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmeNamespaceRequest::DeleteNvmeNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmeNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmeNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmeNamespaceRequestDefaultTypeInternal _DeleteNvmeNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmeNamespaceRequest::UpdateNvmeNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_namespace_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmeNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmeNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmeNamespaceRequestDefaultTypeInternal _UpdateNvmeNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeNamespacesRequest::ListNvmeNamespacesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeNamespacesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeNamespacesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeNamespacesRequestDefaultTypeInternal() {}
  union {
    ListNvmeNamespacesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeNamespacesRequestDefaultTypeInternal _ListNvmeNamespacesRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeNamespacesResponse::ListNvmeNamespacesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_namespaces_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeNamespacesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeNamespacesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeNamespacesResponseDefaultTypeInternal() {}
  union {
    ListNvmeNamespacesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeNamespacesResponseDefaultTypeInternal _ListNvmeNamespacesResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeNamespaceRequest::GetNvmeNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    GetNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeNamespaceRequestDefaultTypeInternal _GetNvmeNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeNamespaceRequest::StatsNvmeNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeNamespaceRequestDefaultTypeInternal() {}
  union {
    StatsNvmeNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeNamespaceRequestDefaultTypeInternal _StatsNvmeNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeNamespaceResponse::StatsNvmeNamespaceResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeNamespaceResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeNamespaceResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeNamespaceResponseDefaultTypeInternal() {}
  union {
    StatsNvmeNamespaceResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeNamespaceResponseDefaultTypeInternal _StatsNvmeNamespaceResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::_pb::Metadata file_level_metadata_frontend_5fnvme_5fpcie_2eproto[33];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto = nullptr;

const uint32_t TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystem, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, _impl_.nqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, _impl_.serial_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, _impl_.model_number_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemSpec, _impl_.max_namespaces_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemStatus, _impl_.firmware_revision_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeSubsystemStatus, _impl_.fru_guid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeController, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.nvme_controller_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.pcie_id_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.max_nsq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.max_ncq_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.sqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.cqes_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.max_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.min_limit_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerSpec, _impl_.max_limit_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeControllerStatus, _impl_.active_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, _impl_.spec_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespace, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _impl_.host_nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _impl_.nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _impl_.eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceSpec, _impl_.volume_name_ref_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceStatus, _impl_.pci_state_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeNamespaceStatus, _impl_.pci_oper_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeSubsystemRequest, _impl_.nvme_subsystem_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeSubsystemRequest, _impl_.nvme_subsystem_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeSubsystemRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeSubsystemRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, _impl_.nvme_subsystem_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeSubsystemRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsResponse, _impl_.nvme_subsystems_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeSubsystemsResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeSubsystemRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeSubsystemResponse, _impl_.stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, _impl_.nvme_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeControllerRequest, _impl_.nvme_controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeControllerRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, _impl_.nvme_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersResponse, _impl_.nvme_controllers_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeControllersResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeControllerResponse, _impl_.stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, _impl_.nvme_namespace_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeNamespaceRequest, _impl_.nvme_namespace_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeNamespaceRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeNamespaceRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, _impl_.nvme_namespace_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeNamespaceRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesResponse, _impl_.nvme_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeNamespacesResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeNamespaceRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeNamespaceResponse, _impl_.stats_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NvmeSubsystem)},
  { 9, -1, -1, sizeof(::opi_api::storage::v1::NvmeSubsystemSpec)},
  { 19, -1, -1, sizeof(::opi_api::storage::v1::NvmeSubsystemStatus)},
  { 27, -1, -1, sizeof(::opi_api::storage::v1::NvmeController)},
  { 36, 51, -1, sizeof(::opi_api::storage::v1::NvmeControllerSpec)},
  { 60, -1, -1, sizeof(::opi_api::storage::v1::NvmeControllerStatus)},
  { 67, -1, -1, sizeof(::opi_api::storage::v1::NvmeNamespace)},
  { 76, -1, -1, sizeof(::opi_api::storage::v1::NvmeNamespaceSpec)},
  { 87, -1, -1, sizeof(::opi_api::storage::v1::NvmeNamespaceStatus)},
  { 95, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeSubsystemRequest)},
  { 103, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeSubsystemRequest)},
  { 111, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeSubsystemRequest)},
  { 120, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeSubsystemsRequest)},
  { 128, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeSubsystemsResponse)},
  { 136, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeSubsystemRequest)},
  { 143, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeSubsystemRequest)},
  { 150, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeSubsystemResponse)},
  { 157, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeControllerRequest)},
  { 166, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeControllerRequest)},
  { 174, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeControllerRequest)},
  { 183, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeControllersRequest)},
  { 192, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeControllersResponse)},
  { 200, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeControllerRequest)},
  { 207, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeControllerRequest)},
  { 214, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeControllerResponse)},
  { 221, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeNamespaceRequest)},
  { 230, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeNamespaceRequest)},
  { 238, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeNamespaceRequest)},
  { 247, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeNamespacesRequest)},
  { 256, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeNamespacesResponse)},
  { 264, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeNamespaceRequest)},
  { 271, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeNamespaceRequest)},
  { 278, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeNamespaceResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::opi_api::storage::v1::_NvmeSubsystem_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeSubsystemSpec_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeSubsystemStatus_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeController_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeControllerSpec_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeControllerStatus_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeNamespace_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeNamespaceSpec_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeNamespaceStatus_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmeSubsystemRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmeSubsystemRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmeSubsystemRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeSubsystemsRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeSubsystemsResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeSubsystemRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeSubsystemRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeSubsystemResponse_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmeControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmeControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmeControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeControllersRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeControllersResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeControllerResponse_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmeNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmeNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmeNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeNamespacesRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeNamespacesResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeNamespaceResponse_default_instance_._instance,
};

const char descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030frontend_nvme_pcie.proto\022\022opi_api.stor"
  "age.v1\032\017opicommon.proto\032\nuuid.proto\032\027goo"
  "gle/api/client.proto\032\031google/api/resourc"
  "e.proto\032\033google/protobuf/empty.proto\032\034go"
  "ogle/api/annotations.proto\032\037google/api/f"
  "ield_behavior.proto\032 google/protobuf/fie"
  "ld_mask.proto\"\250\002\n\rNvmeSubsystem\0229\n\004name\030"
  "\001 \001(\tB+\340A\003\340A\005\372A\"\n opi_api.storage.v1/Nvm"
  "eSubsystem\0228\n\004spec\030\002 \001(\0132%.opi_api.stora"
  "ge.v1.NvmeSubsystemSpecB\003\340A\002\022<\n\006status\030\003"
  " \001(\0132\'.opi_api.storage.v1.NvmeSubsystemS"
  "tatusB\003\340A\003:d\352Aa\n$storage.opiproject.org/"
  "NvmeSubsystem\022\032nvmeSubsystems/{subsystem"
  "}*\016nvmeSubsystems2\rnvmeSubsystem\"y\n\021Nvme"
  "SubsystemSpec\022\020\n\003nqn\030\001 \001(\tB\003\340A\002\022\032\n\rseria"
  "l_number\030\002 \001(\tB\003\340A\001\022\031\n\014model_number\030\003 \001("
  "\tB\003\340A\001\022\033\n\016max_namespaces\030\004 \001(\003B\003\340A\001\"L\n\023N"
  "vmeSubsystemStatus\022\036\n\021firmware_revision\030"
  "\001 \001(\tB\003\340A\003\022\025\n\010fru_guid\030\002 \001(\014B\003\340A\003\"\316\002\n\016Nv"
  "meController\022:\n\004name\030\001 \001(\tB,\340A\003\340A\005\372A#\n!o"
  "pi_api.storage.v1/NvmeController\0229\n\004spec"
  "\030\002 \001(\0132&.opi_api.storage.v1.NvmeControll"
  "erSpecB\003\340A\002\022=\n\006status\030\003 \001(\0132(.opi_api.st"
  "orage.v1.NvmeControllerStatusB\003\340A\003:\205\001\352A\201"
  "\001\n%storage.opiproject.org/NvmeController"
  "\0227nvmeSubsystems/{subsystem}/nvmeControl"
  "lers/{controller}*\017nvmeControllers2\016nvme"
  "Controller\"\343\002\n\022NvmeControllerSpec\022$\n\022nvm"
  "e_controller_id\030\001 \001(\005B\003\340A\001H\000\210\001\001\0225\n\007pcie_"
  "id\030\003 \001(\0132\037.opi_api.storage.v1.PciEndpoin"
  "tB\003\340A\002\022\024\n\007max_nsq\030\004 \001(\005B\003\340A\001\022\024\n\007max_ncq\030"
  "\005 \001(\005B\003\340A\001\022\021\n\004sqes\030\006 \001(\005B\003\340A\001\022\021\n\004cqes\030\007 "
  "\001(\005B\003\340A\001\022\033\n\016max_namespaces\030\010 \001(\005B\003\340A\001\0224\n"
  "\tmin_limit\030\t \001(\0132\034.opi_api.storage.v1.Qo"
  "sLimitB\003\340A\001\0224\n\tmax_limit\030\n \001(\0132\034.opi_api"
  ".storage.v1.QosLimitB\003\340A\001B\025\n\023_nvme_contr"
  "oller_id\"+\n\024NvmeControllerStatus\022\023\n\006acti"
  "ve\030\001 \001(\010B\003\340A\003\"\303\002\n\rNvmeNamespace\0229\n\004name\030"
  "\001 \001(\tB+\340A\003\340A\005\372A\"\n opi_api.storage.v1/Nvm"
  "eNamespace\0228\n\004spec\030\002 \001(\0132%.opi_api.stora"
  "ge.v1.NvmeNamespaceSpecB\003\340A\002\022<\n\006status\030\003"
  " \001(\0132\'.opi_api.storage.v1.NvmeNamespaceS"
  "tatusB\003\340A\003:\177\352A|\n$storage.opiproject.org/"
  "NvmeNamespace\0225nvmeSubsystems/{subsystem"
  "}/nvmeNamespaces/{namespace}*\016nvmeNamesp"
  "aces2\rnvmeNamespace\"\235\001\n\021NvmeNamespaceSpe"
  "c\022\026\n\thost_nsid\030\002 \001(\005B\003\340A\001\022\022\n\005nguid\030\003 \001(\t"
  "B\003\340A\001\022\022\n\005eui64\030\004 \001(\003B\003\340A\001\022*\n\004uuid\030\005 \001(\0132"
  "\027.opi_api.common.v1.UuidB\003\340A\001\022\034\n\017volume_"
  "name_ref\030\006 \001(\tB\003\340A\002\"\244\001\n\023NvmeNamespaceSta"
  "tus\022A\n\tpci_state\030\001 \001(\0162).opi_api.storage"
  ".v1.NvmeNamespacePciStateB\003\340A\003\022J\n\016pci_op"
  "er_state\030\002 \001(\0162-.opi_api.storage.v1.Nvme"
  "NamespacePciOperStateB\003\340A\003\"|\n\032CreateNvme"
  "SubsystemRequest\022>\n\016nvme_subsystem\030\001 \001(\013"
  "2!.opi_api.storage.v1.NvmeSubsystemB\003\340A\002"
  "\022\036\n\021nvme_subsystem_id\030\002 \001(\tB\003\340A\001\"p\n\032Dele"
  "teNvmeSubsystemRequest\0226\n\004name\030\001 \001(\tB(\340A"
  "\002\372A\"\n opi_api.storage.v1/NvmeSubsystem\022\032"
  "\n\rallow_missing\030\002 \001(\010B\003\340A\001\"\256\001\n\032UpdateNvm"
  "eSubsystemRequest\022>\n\016nvme_subsystem\030\001 \001("
  "\0132!.opi_api.storage.v1.NvmeSubsystemB\003\340A"
  "\002\0224\n\013update_mask\030\002 \001(\0132\032.google.protobuf"
  ".FieldMaskB\003\340A\001\022\032\n\rallow_missing\030\003 \001(\010B\003"
  "\340A\001\"L\n\031ListNvmeSubsystemsRequest\022\026\n\tpage"
  "_size\030\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 \001(\tB\003\340A"
  "\001\"q\n\032ListNvmeSubsystemsResponse\022:\n\017nvme_"
  "subsystems\030\001 \003(\0132!.opi_api.storage.v1.Nv"
  "meSubsystem\022\027\n\017next_page_token\030\002 \001(\t\"Q\n\027"
  "GetNvmeSubsystemRequest\0226\n\004name\030\001 \001(\tB(\340"
  "A\002\372A\"\n opi_api.storage.v1/NvmeSubsystem\""
  "S\n\031StatsNvmeSubsystemRequest\0226\n\004name\030\001 \001"
  "(\tB(\340A\002\372A\"\n opi_api.storage.v1/NvmeSubsy"
  "stem\"L\n\032StatsNvmeSubsystemResponse\022.\n\005st"
  "ats\030\001 \001(\0132\037.opi_api.storage.v1.VolumeSta"
  "ts\"\272\001\n\033CreateNvmeControllerRequest\0228\n\006pa"
  "rent\030\001 \001(\tB(\340A\002\372A\"\n opi_api.storage.v1/N"
  "vmeSubsystem\022@\n\017nvme_controller\030\002 \001(\0132\"."
  "opi_api.storage.v1.NvmeControllerB\003\340A\002\022\037"
  "\n\022nvme_controller_id\030\003 \001(\tB\003\340A\001\"r\n\033Delet"
  "eNvmeControllerRequest\0227\n\004name\030\001 \001(\tB)\340A"
  "\002\372A#\n!opi_api.storage.v1/NvmeController\022"
  "\032\n\rallow_missing\030\002 \001(\010B\003\340A\001\"\261\001\n\033UpdateNv"
  "meControllerRequest\022@\n\017nvme_controller\030\001"
  " \001(\0132\".opi_api.storage.v1.NvmeController"
  "B\003\340A\002\0224\n\013update_mask\030\002 \001(\0132\032.google.prot"
  "obuf.FieldMaskB\003\340A\001\022\032\n\rallow_missing\030\003 \001"
  "(\010B\003\340A\001\"\210\001\n\032ListNvmeControllersRequest\0229"
  "\n\006parent\030\001 \001(\tB)\340A\002\372A#\n!opi_api.storage."
  "v1/NvmeController\022\026\n\tpage_size\030\002 \001(\005B\003\340A"
  "\001\022\027\n\npage_token\030\003 \001(\tB\003\340A\001\"t\n\033ListNvmeCo"
  "ntrollersResponse\022<\n\020nvme_controllers\030\001 "
  "\003(\0132\".opi_api.storage.v1.NvmeController\022"
  "\027\n\017next_page_token\030\002 \001(\t\"S\n\030GetNvmeContr"
  "ollerRequest\0227\n\004name\030\001 \001(\tB)\340A\002\372A#\n!opi_"
  "api.storage.v1/NvmeController\"U\n\032StatsNv"
  "meControllerRequest\0227\n\004name\030\001 \001(\tB)\340A\002\372A"
  "#\n!opi_api.storage.v1/NvmeController\"M\n\033"
  "StatsNvmeControllerResponse\022.\n\005stats\030\001 \001"
  "(\0132\037.opi_api.storage.v1.VolumeStats\"\266\001\n\032"
  "CreateNvmeNamespaceRequest\0228\n\006parent\030\001 \001"
  "(\tB(\340A\002\372A\"\n opi_api.storage.v1/NvmeSubsy"
  "stem\022>\n\016nvme_namespace\030\002 \001(\0132!.opi_api.s"
  "torage.v1.NvmeNamespaceB\003\340A\002\022\036\n\021nvme_nam"
  "espace_id\030\003 \001(\tB\003\340A\001\"p\n\032DeleteNvmeNamesp"
  "aceRequest\0226\n\004name\030\001 \001(\tB(\340A\002\372A\"\n opi_ap"
  "i.storage.v1/NvmeNamespace\022\032\n\rallow_miss"
  "ing\030\002 \001(\010B\003\340A\001\"\256\001\n\032UpdateNvmeNamespaceRe"
  "quest\022>\n\016nvme_namespace\030\001 \001(\0132!.opi_api."
  "storage.v1.NvmeNamespaceB\003\340A\002\0224\n\013update_"
  "mask\030\002 \001(\0132\032.google.protobuf.FieldMaskB\003"
  "\340A\001\022\032\n\rallow_missing\030\003 \001(\010B\003\340A\001\"\206\001\n\031List"
  "NvmeNamespacesRequest\0228\n\006parent\030\001 \001(\tB(\340"
  "A\002\372A\"\n opi_api.storage.v1/NvmeNamespace\022"
  "\026\n\tpage_size\030\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 "
  "\001(\tB\003\340A\001\"q\n\032ListNvmeNamespacesResponse\022:"
  "\n\017nvme_namespaces\030\001 \003(\0132!.opi_api.storag"
  "e.v1.NvmeNamespace\022\027\n\017next_page_token\030\002 "
  "\001(\t\"Q\n\027GetNvmeNamespaceRequest\0226\n\004name\030\001"
  " \001(\tB(\340A\002\372A\"\n opi_api.storage.v1/NvmeNam"
  "espace\"S\n\031StatsNvmeNamespaceRequest\0226\n\004n"
  "ame\030\001 \001(\tB(\340A\002\372A\"\n opi_api.storage.v1/Nv"
  "meNamespace\"L\n\032StatsNvmeNamespaceRespons"
  "e\022.\n\005stats\030\001 \001(\0132\037.opi_api.storage.v1.Vo"
  "lumeStats*\265\001\n\025NvmeNamespacePciState\022(\n$N"
  "VME_NAMESPACE_PCI_STATE_UNSPECIFIED\020\000\022%\n"
  "!NVME_NAMESPACE_PCI_STATE_DISABLED\020\001\022$\n "
  "NVME_NAMESPACE_PCI_STATE_ENABLED\020\002\022%\n!NV"
  "ME_NAMESPACE_PCI_STATE_DELETING\020\003*\237\001\n\031Nv"
  "meNamespacePciOperState\022-\n)NVME_NAMESPAC"
  "E_PCI_OPER_STATE_UNSPECIFIED\020\000\022(\n$NVME_N"
  "AMESPACE_PCI_OPER_STATE_ONLINE\020\001\022)\n%NVME"
  "_NAMESPACE_PCI_OPER_STATE_OFFLINE\020\0022\331\031\n\023"
  "FrontendNvmeService\022\267\001\n\023CreateNvmeSubsys"
  "tem\022..opi_api.storage.v1.CreateNvmeSubsy"
  "stemRequest\032!.opi_api.storage.v1.NvmeSub"
  "system\"M\202\323\344\223\002$\"\022/v1/nvmeSubsystems:\016nvme"
  "_subsystem\332A nvme_subsystem,nvme_subsyst"
  "em_id\022\211\001\n\023DeleteNvmeSubsystem\022..opi_api."
  "storage.v1.DeleteNvmeSubsystemRequest\032\026."
  "google.protobuf.Empty\"*\202\323\344\223\002\035*\033/v1/{name"
  "=nvmeSubsystems/*}\332A\004name\022\311\001\n\023UpdateNvme"
  "Subsystem\022..opi_api.storage.v1.UpdateNvm"
  "eSubsystemRequest\032!.opi_api.storage.v1.N"
  "vmeSubsystem\"_\202\323\344\223\002<2*/v1/{nvme_subsyste"
  "m.name=nvmeSubsystems/*}:\016nvme_subsystem"
  "\332A\032nvme_subsystem,update_mask\022\217\001\n\022ListNv"
  "meSubsystems\022-.opi_api.storage.v1.ListNv"
  "meSubsystemsRequest\032..opi_api.storage.v1"
  ".ListNvmeSubsystemsResponse\"\032\202\323\344\223\002\024\022\022/v1"
  "/nvmeSubsystems\022\216\001\n\020GetNvmeSubsystem\022+.o"
  "pi_api.storage.v1.GetNvmeSubsystemReques"
  "t\032!.opi_api.storage.v1.NvmeSubsystem\"*\202\323"
  "\344\223\002\035\022\033/v1/{name=nvmeSubsystems/*}\332A\004name"
  "\022\245\001\n\022StatsNvmeSubsystem\022-.opi_api.storag"
  "e.v1.StatsNvmeSubsystemRequest\032..opi_api"
  ".storage.v1.StatsNvmeSubsystemResponse\"0"
  "\202\323\344\223\002#\022!/v1/{name=nvmeSubsystems/*}:stat"
  "s\332A\004name\022\337\001\n\024CreateNvmeController\022/.opi_"
  "api.storage.v1.CreateNvmeControllerReque"
  "st\032\".opi_api.storage.v1.NvmeController\"r"
  "\202\323\344\223\002@\"-/v1/{parent=nvmeSubsystems/*}/nv"
  "meControllers:\017nvme_controller\332A)parent,"
  "nvme_controller,nvme_controller_id\022\235\001\n\024D"
  "eleteNvmeController\022/.opi_api.storage.v1"
  ".DeleteNvmeControllerRequest\032\026.google.pr"
  "otobuf.Empty\"<\202\323\344\223\002/*-/v1/{name=nvmeSubs"
  "ystems/*/nvmeControllers/*}\332A\004name\022\341\001\n\024U"
  "pdateNvmeController\022/.opi_api.storage.v1"
  ".UpdateNvmeControllerRequest\032\".opi_api.s"
  "torage.v1.NvmeController\"t\202\323\344\223\002P2=/v1/{n"
  "vme_controller.name=nvmeSubsystems/*/nvm"
  "eControllers/*}:\017nvme_controller\332A\033nvme_"
  "controller,update_mask\022\266\001\n\023ListNvmeContr"
  "ollers\022..opi_api.storage.v1.ListNvmeCont"
  "rollersRequest\032/.opi_api.storage.v1.List"
  "NvmeControllersResponse\">\202\323\344\223\002/\022-/v1/{pa"
  "rent=nvmeSubsystems/*}/nvmeControllers\332A"
  "\006parent\022\243\001\n\021GetNvmeController\022,.opi_api."
  "storage.v1.GetNvmeControllerRequest\032\".op"
  "i_api.storage.v1.NvmeController\"<\202\323\344\223\002/\022"
  "-/v1/{name=nvmeSubsystems/*/nvmeControll"
  "ers/*}\332A\004name\022\272\001\n\023StatsNvmeController\022.."
  "opi_api.storage.v1.StatsNvmeControllerRe"
  "quest\032/.opi_api.storage.v1.StatsNvmeCont"
  "rollerResponse\"B\202\323\344\223\0025\0223/v1/{name=nvmeSu"
  "bsystems/*/nvmeControllers/*}:stats\332A\004na"
  "me\022\330\001\n\023CreateNvmeNamespace\022..opi_api.sto"
  "rage.v1.CreateNvmeNamespaceRequest\032!.opi"
  "_api.storage.v1.NvmeNamespace\"n\202\323\344\223\002>\",/"
  "v1/{parent=nvmeSubsystems/*}/nvmeNamespa"
  "ces:\016nvme_namespace\332A\'parent,nvme_namesp"
  "ace,nvme_namespace_id\022\232\001\n\023DeleteNvmeName"
  "space\022..opi_api.storage.v1.DeleteNvmeNam"
  "espaceRequest\032\026.google.protobuf.Empty\";\202"
  "\323\344\223\002.*,/v1/{name=nvmeSubsystems/*/nvmeNa"
  "mespaces/*}\332A\004name\022\332\001\n\023UpdateNvmeNamespa"
  "ce\022..opi_api.storage.v1.UpdateNvmeNamesp"
  "aceRequest\032!.opi_api.storage.v1.NvmeName"
  "space\"p\202\323\344\223\002M2;/v1/{nvme_namespace.name="
  "nvmeSubsystems/*/nvmeNamespaces/*}:\016nvme"
  "_namespace\332A\032nvme_namespace,update_mask\022"
  "\262\001\n\022ListNvmeNamespaces\022-.opi_api.storage"
  ".v1.ListNvmeNamespacesRequest\032..opi_api."
  "storage.v1.ListNvmeNamespacesResponse\"=\202"
  "\323\344\223\002.\022,/v1/{parent=nvmeSubsystems/*}/nvm"
  "eNamespaces\332A\006parent\022\237\001\n\020GetNvmeNamespac"
  "e\022+.opi_api.storage.v1.GetNvmeNamespaceR"
  "equest\032!.opi_api.storage.v1.NvmeNamespac"
  "e\";\202\323\344\223\002.\022,/v1/{name=nvmeSubsystems/*/nv"
  "meNamespaces/*}\332A\004name\022\266\001\n\022StatsNvmeName"
  "space\022-.opi_api.storage.v1.StatsNvmeName"
  "spaceRequest\032..opi_api.storage.v1.StatsN"
  "vmeNamespaceResponse\"A\202\323\344\223\0024\0222/v1/{name="
  "nvmeSubsystems/*/nvmeNamespaces/*}:stats"
  "\332A\004nameBd\n\022opi_api.storage.v1B\025FrontendN"
  "vmePcieProtoP\001Z5github.com/opiproject/op"
  "i-api/storage/v1alpha1/gen/gob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps[8] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2fclient_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ffield_5fmask_2eproto,
  &::descriptor_table_opicommon_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::_pbi::once_flag descriptor_table_frontend_5fnvme_5fpcie_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_frontend_5fnvme_5fpcie_2eproto = {
    false, false, 8717, descriptor_table_protodef_frontend_5fnvme_5fpcie_2eproto,
    "frontend_nvme_pcie.proto",
    &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once, descriptor_table_frontend_5fnvme_5fpcie_2eproto_deps, 8, 33,
    schemas, file_default_instances, TableStruct_frontend_5fnvme_5fpcie_2eproto::offsets,
    file_level_metadata_frontend_5fnvme_5fpcie_2eproto, file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto,
    file_level_service_descriptors_frontend_5fnvme_5fpcie_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter() {
  return &descriptor_table_frontend_5fnvme_5fpcie_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_frontend_5fnvme_5fpcie_2eproto(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeNamespacePciState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[0];
}
bool NvmeNamespacePciState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeNamespacePciOperState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_frontend_5fnvme_5fpcie_2eproto);
  return file_level_enum_descriptors_frontend_5fnvme_5fpcie_2eproto[1];
}
bool NvmeNamespacePciOperState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NvmeSubsystem::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeSubsystemSpec& spec(const NvmeSubsystem* msg);
  static const ::opi_api::storage::v1::NvmeSubsystemStatus& status(const NvmeSubsystem* msg);
};

const ::opi_api::storage::v1::NvmeSubsystemSpec&
NvmeSubsystem::_Internal::spec(const NvmeSubsystem* msg) {
  return *msg->_impl_.spec_;
}
const ::opi_api::storage::v1::NvmeSubsystemStatus&
NvmeSubsystem::_Internal::status(const NvmeSubsystem* msg) {
  return *msg->_impl_.status_;
}
NvmeSubsystem::NvmeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeSubsystem)
}
NvmeSubsystem::NvmeSubsystem(const NvmeSubsystem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeSubsystem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::opi_api::storage::v1::NvmeSubsystemSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::opi_api::storage::v1::NvmeSubsystemStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeSubsystem)
}

inline void NvmeSubsystem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeSubsystem::~NvmeSubsystem() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeSubsystem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeSubsystem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void NvmeSubsystem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeSubsystem::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeSubsystem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeSubsystem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystem.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeSubsystemStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeSubsystem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeSubsystem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystem.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.storage.v1.NvmeSubsystemStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeSubsystem)
  return target;
}

size_t NvmeSubsystem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeSubsystem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spec_);
  }

  // .opi_api.storage.v1.NvmeSubsystemStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeSubsystem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeSubsystem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeSubsystem::GetClassData() const { return &_class_data_; }


void NvmeSubsystem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeSubsystem*>(&to_msg);
  auto& from = static_cast<const NvmeSubsystem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeSubsystem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _this->_internal_mutable_spec()->::opi_api::storage::v1::NvmeSubsystemSpec::MergeFrom(
        from._internal_spec());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::opi_api::storage::v1::NvmeSubsystemStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeSubsystem::CopyFrom(const NvmeSubsystem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeSubsystem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeSubsystem::IsInitialized() const {
  return true;
}

void NvmeSubsystem::InternalSwap(NvmeSubsystem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeSubsystem, _impl_.status_)
      + sizeof(NvmeSubsystem::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(NvmeSubsystem, _impl_.spec_)>(
          reinterpret_cast<char*>(&_impl_.spec_),
          reinterpret_cast<char*>(&other->_impl_.spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeSubsystem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[0]);
}

// ===================================================================

class NvmeSubsystemSpec::_Internal {
 public:
};

NvmeSubsystemSpec::NvmeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeSubsystemSpec)
}
NvmeSubsystemSpec::NvmeSubsystemSpec(const NvmeSubsystemSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeSubsystemSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nqn_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.model_number_){}
    , decltype(_impl_.max_namespaces_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nqn().empty()) {
    _this->_impl_.nqn_.Set(from._internal_nqn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_serial_number().empty()) {
    _this->_impl_.serial_number_.Set(from._internal_serial_number(), 
      _this->GetArenaForAllocation());
  }
  _impl_.model_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_model_number().empty()) {
    _this->_impl_.model_number_.Set(from._internal_model_number(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.max_namespaces_ = from._impl_.max_namespaces_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeSubsystemSpec)
}

inline void NvmeSubsystemSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nqn_){}
    , decltype(_impl_.serial_number_){}
    , decltype(_impl_.model_number_){}
    , decltype(_impl_.max_namespaces_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serial_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.model_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeSubsystemSpec::~NvmeSubsystemSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeSubsystemSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeSubsystemSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nqn_.Destroy();
  _impl_.serial_number_.Destroy();
  _impl_.model_number_.Destroy();
}

void NvmeSubsystemSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeSubsystemSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nqn_.ClearToEmpty();
  _impl_.serial_number_.ClearToEmpty();
  _impl_.model_number_.ClearToEmpty();
  _impl_.max_namespaces_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeSubsystemSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string nqn = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemSpec.nqn"));
        } else
          goto handle_unusual;
        continue;
      // string serial_number = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_serial_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemSpec.serial_number"));
        } else
          goto handle_unusual;
        continue;
      // string model_number = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemSpec.model_number"));
        } else
          goto handle_unusual;
        continue;
      // int64 max_namespaces = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeSubsystemSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeSubsystemSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string nqn = 1 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_nqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nqn().data(), static_cast<int>(this->_internal_nqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemSpec.nqn");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nqn(), target);
  }

  // string serial_number = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_serial_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_serial_number().data(), static_cast<int>(this->_internal_serial_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemSpec.serial_number");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_serial_number(), target);
  }

  // string model_number = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_model_number().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_model_number().data(), static_cast<int>(this->_internal_model_number().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemSpec.model_number");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_number(), target);
  }

  // int64 max_namespaces = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_max_namespaces(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeSubsystemSpec)
  return target;
}

size_t NvmeSubsystemSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeSubsystemSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nqn = 1 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_nqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nqn());
  }

  // string serial_number = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_serial_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_serial_number());
  }

  // string model_number = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_model_number().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_number());
  }

  // int64 max_namespaces = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeSubsystemSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeSubsystemSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeSubsystemSpec::GetClassData() const { return &_class_data_; }


void NvmeSubsystemSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeSubsystemSpec*>(&to_msg);
  auto& from = static_cast<const NvmeSubsystemSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeSubsystemSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nqn().empty()) {
    _this->_internal_set_nqn(from._internal_nqn());
  }
  if (!from._internal_serial_number().empty()) {
    _this->_internal_set_serial_number(from._internal_serial_number());
  }
  if (!from._internal_model_number().empty()) {
    _this->_internal_set_model_number(from._internal_model_number());
  }
  if (from._internal_max_namespaces() != 0) {
    _this->_internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeSubsystemSpec::CopyFrom(const NvmeSubsystemSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeSubsystemSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeSubsystemSpec::IsInitialized() const {
  return true;
}

void NvmeSubsystemSpec::InternalSwap(NvmeSubsystemSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nqn_, lhs_arena,
      &other->_impl_.nqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serial_number_, lhs_arena,
      &other->_impl_.serial_number_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.model_number_, lhs_arena,
      &other->_impl_.model_number_, rhs_arena
  );
  swap(_impl_.max_namespaces_, other->_impl_.max_namespaces_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeSubsystemSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[1]);
}

// ===================================================================

class NvmeSubsystemStatus::_Internal {
 public:
};

NvmeSubsystemStatus::NvmeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeSubsystemStatus)
}
NvmeSubsystemStatus::NvmeSubsystemStatus(const NvmeSubsystemStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeSubsystemStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.firmware_revision_){}
    , decltype(_impl_.fru_guid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.firmware_revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_revision_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firmware_revision().empty()) {
    _this->_impl_.firmware_revision_.Set(from._internal_firmware_revision(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fru_guid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fru_guid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fru_guid().empty()) {
    _this->_impl_.fru_guid_.Set(from._internal_fru_guid(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeSubsystemStatus)
}

inline void NvmeSubsystemStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.firmware_revision_){}
    , decltype(_impl_.fru_guid_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.firmware_revision_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_revision_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fru_guid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fru_guid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeSubsystemStatus::~NvmeSubsystemStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeSubsystemStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeSubsystemStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.firmware_revision_.Destroy();
  _impl_.fru_guid_.Destroy();
}

void NvmeSubsystemStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeSubsystemStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.firmware_revision_.ClearToEmpty();
  _impl_.fru_guid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeSubsystemStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string firmware_revision = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firmware_revision();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision"));
        } else
          goto handle_unusual;
        continue;
      // bytes fru_guid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_fru_guid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeSubsystemStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeSubsystemStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string firmware_revision = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_firmware_revision().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firmware_revision().data(), static_cast<int>(this->_internal_firmware_revision().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firmware_revision(), target);
  }

  // bytes fru_guid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_fru_guid().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_fru_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeSubsystemStatus)
  return target;
}

size_t NvmeSubsystemStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeSubsystemStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string firmware_revision = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_firmware_revision().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firmware_revision());
  }

  // bytes fru_guid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_fru_guid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_fru_guid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeSubsystemStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeSubsystemStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeSubsystemStatus::GetClassData() const { return &_class_data_; }


void NvmeSubsystemStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeSubsystemStatus*>(&to_msg);
  auto& from = static_cast<const NvmeSubsystemStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeSubsystemStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_firmware_revision().empty()) {
    _this->_internal_set_firmware_revision(from._internal_firmware_revision());
  }
  if (!from._internal_fru_guid().empty()) {
    _this->_internal_set_fru_guid(from._internal_fru_guid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeSubsystemStatus::CopyFrom(const NvmeSubsystemStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeSubsystemStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeSubsystemStatus::IsInitialized() const {
  return true;
}

void NvmeSubsystemStatus::InternalSwap(NvmeSubsystemStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.firmware_revision_, lhs_arena,
      &other->_impl_.firmware_revision_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fru_guid_, lhs_arena,
      &other->_impl_.fru_guid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeSubsystemStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[2]);
}

// ===================================================================

class NvmeController::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeControllerSpec& spec(const NvmeController* msg);
  static const ::opi_api::storage::v1::NvmeControllerStatus& status(const NvmeController* msg);
};

const ::opi_api::storage::v1::NvmeControllerSpec&
NvmeController::_Internal::spec(const NvmeController* msg) {
  return *msg->_impl_.spec_;
}
const ::opi_api::storage::v1::NvmeControllerStatus&
NvmeController::_Internal::status(const NvmeController* msg) {
  return *msg->_impl_.status_;
}
NvmeController::NvmeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeController)
}
NvmeController::NvmeController(const NvmeController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::opi_api::storage::v1::NvmeControllerSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::opi_api::storage::v1::NvmeControllerStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeController)
}

inline void NvmeController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeController::~NvmeController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void NvmeController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeController.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeControllerSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeControllerStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeController.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeControllerSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.storage.v1.NvmeControllerStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeController)
  return target;
}

size_t NvmeController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.NvmeControllerSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spec_);
  }

  // .opi_api.storage.v1.NvmeControllerStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeController::GetClassData() const { return &_class_data_; }


void NvmeController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeController*>(&to_msg);
  auto& from = static_cast<const NvmeController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _this->_internal_mutable_spec()->::opi_api::storage::v1::NvmeControllerSpec::MergeFrom(
        from._internal_spec());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::opi_api::storage::v1::NvmeControllerStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeController::CopyFrom(const NvmeController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeController::IsInitialized() const {
  return true;
}

void NvmeController::InternalSwap(NvmeController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeController, _impl_.status_)
      + sizeof(NvmeController::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(NvmeController, _impl_.spec_)>(
          reinterpret_cast<char*>(&_impl_.spec_),
          reinterpret_cast<char*>(&other->_impl_.spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[3]);
}

// ===================================================================

class NvmeControllerSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<NvmeControllerSpec>()._impl_._has_bits_);
  static void set_has_nvme_controller_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::opi_api::storage::v1::PciEndpoint& pcie_id(const NvmeControllerSpec* msg);
  static const ::opi_api::storage::v1::QosLimit& min_limit(const NvmeControllerSpec* msg);
  static const ::opi_api::storage::v1::QosLimit& max_limit(const NvmeControllerSpec* msg);
};

const ::opi_api::storage::v1::PciEndpoint&
NvmeControllerSpec::_Internal::pcie_id(const NvmeControllerSpec* msg) {
  return *msg->_impl_.pcie_id_;
}
const ::opi_api::storage::v1::QosLimit&
NvmeControllerSpec::_Internal::min_limit(const NvmeControllerSpec* msg) {
  return *msg->_impl_.min_limit_;
}
const ::opi_api::storage::v1::QosLimit&
NvmeControllerSpec::_Internal::max_limit(const NvmeControllerSpec* msg) {
  return *msg->_impl_.max_limit_;
}
void NvmeControllerSpec::clear_pcie_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.pcie_id_ != nullptr) {
    delete _impl_.pcie_id_;
  }
  _impl_.pcie_id_ = nullptr;
}
void NvmeControllerSpec::clear_min_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.min_limit_ != nullptr) {
    delete _impl_.min_limit_;
  }
  _impl_.min_limit_ = nullptr;
}
void NvmeControllerSpec::clear_max_limit() {
  if (GetArenaForAllocation() == nullptr && _impl_.max_limit_ != nullptr) {
    delete _impl_.max_limit_;
  }
  _impl_.max_limit_ = nullptr;
}
NvmeControllerSpec::NvmeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeControllerSpec)
}
NvmeControllerSpec::NvmeControllerSpec(const NvmeControllerSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeControllerSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pcie_id_){nullptr}
    , decltype(_impl_.min_limit_){nullptr}
    , decltype(_impl_.max_limit_){nullptr}
    , decltype(_impl_.nvme_controller_id_){}
    , decltype(_impl_.max_nsq_){}
    , decltype(_impl_.max_ncq_){}
    , decltype(_impl_.sqes_){}
    , decltype(_impl_.cqes_){}
    , decltype(_impl_.max_namespaces_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pcie_id()) {
    _this->_impl_.pcie_id_ = new ::opi_api::storage::v1::PciEndpoint(*from._impl_.pcie_id_);
  }
  if (from._internal_has_min_limit()) {
    _this->_impl_.min_limit_ = new ::opi_api::storage::v1::QosLimit(*from._impl_.min_limit_);
  }
  if (from._internal_has_max_limit()) {
    _this->_impl_.max_limit_ = new ::opi_api::storage::v1::QosLimit(*from._impl_.max_limit_);
  }
  ::memcpy(&_impl_.nvme_controller_id_, &from._impl_.nvme_controller_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_namespaces_) -
    reinterpret_cast<char*>(&_impl_.nvme_controller_id_)) + sizeof(_impl_.max_namespaces_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeControllerSpec)
}

inline void NvmeControllerSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pcie_id_){nullptr}
    , decltype(_impl_.min_limit_){nullptr}
    , decltype(_impl_.max_limit_){nullptr}
    , decltype(_impl_.nvme_controller_id_){0}
    , decltype(_impl_.max_nsq_){0}
    , decltype(_impl_.max_ncq_){0}
    , decltype(_impl_.sqes_){0}
    , decltype(_impl_.cqes_){0}
    , decltype(_impl_.max_namespaces_){0}
  };
}

NvmeControllerSpec::~NvmeControllerSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeControllerSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeControllerSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pcie_id_;
  if (this != internal_default_instance()) delete _impl_.min_limit_;
  if (this != internal_default_instance()) delete _impl_.max_limit_;
}

void NvmeControllerSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeControllerSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeControllerSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pcie_id_ != nullptr) {
    delete _impl_.pcie_id_;
  }
  _impl_.pcie_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.min_limit_ != nullptr) {
    delete _impl_.min_limit_;
  }
  _impl_.min_limit_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.max_limit_ != nullptr) {
    delete _impl_.max_limit_;
  }
  _impl_.max_limit_ = nullptr;
  _impl_.nvme_controller_id_ = 0;
  ::memset(&_impl_.max_nsq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.max_namespaces_) -
      reinterpret_cast<char*>(&_impl_.max_nsq_)) + sizeof(_impl_.max_namespaces_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeControllerSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 nvme_controller_id = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_nvme_controller_id(&has_bits);
          _impl_.nvme_controller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.PciEndpoint pcie_id = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pcie_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_nsq = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.max_nsq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_ncq = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.max_ncq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 sqes = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.sqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 cqes = 7 [(.google.api.field_behavior) = OPTIONAL];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.cqes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 max_namespaces = 8 [(.google.api.field_behavior) = OPTIONAL];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.max_namespaces_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.QosLimit min_limit = 9 [(.google.api.field_behavior) = OPTIONAL];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_min_limit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.QosLimit max_limit = 10 [(.google.api.field_behavior) = OPTIONAL];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_max_limit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeControllerSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeControllerSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 nvme_controller_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (_internal_has_nvme_controller_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_nvme_controller_id(), target);
  }

  // .opi_api.storage.v1.PciEndpoint pcie_id = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_pcie_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pcie_id(this),
        _Internal::pcie_id(this).GetCachedSize(), target, stream);
  }

  // int32 max_nsq = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_nsq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_nsq(), target);
  }

  // int32 max_ncq = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_ncq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_max_ncq(), target);
  }

  // int32 sqes = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_sqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_sqes(), target);
  }

  // int32 cqes = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_cqes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_cqes(), target);
  }

  // int32 max_namespaces = 8 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_namespaces() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_max_namespaces(), target);
  }

  // .opi_api.storage.v1.QosLimit min_limit = 9 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_min_limit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::min_limit(this),
        _Internal::min_limit(this).GetCachedSize(), target, stream);
  }

  // .opi_api.storage.v1.QosLimit max_limit = 10 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_max_limit()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::max_limit(this),
        _Internal::max_limit(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeControllerSpec)
  return target;
}

size_t NvmeControllerSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeControllerSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.PciEndpoint pcie_id = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_pcie_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pcie_id_);
  }

  // .opi_api.storage.v1.QosLimit min_limit = 9 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_min_limit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.min_limit_);
  }

  // .opi_api.storage.v1.QosLimit max_limit = 10 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_max_limit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.max_limit_);
  }

  // optional int32 nvme_controller_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nvme_controller_id());
  }

  // int32 max_nsq = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_nsq() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_nsq());
  }

  // int32 max_ncq = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_ncq() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_ncq());
  }

  // int32 sqes = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_sqes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sqes());
  }

  // int32 cqes = 7 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_cqes() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cqes());
  }

  // int32 max_namespaces = 8 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_max_namespaces() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_namespaces());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeControllerSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeControllerSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeControllerSpec::GetClassData() const { return &_class_data_; }


void NvmeControllerSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeControllerSpec*>(&to_msg);
  auto& from = static_cast<const NvmeControllerSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeControllerSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pcie_id()) {
    _this->_internal_mutable_pcie_id()->::opi_api::storage::v1::PciEndpoint::MergeFrom(
        from._internal_pcie_id());
  }
  if (from._internal_has_min_limit()) {
    _this->_internal_mutable_min_limit()->::opi_api::storage::v1::QosLimit::MergeFrom(
        from._internal_min_limit());
  }
  if (from._internal_has_max_limit()) {
    _this->_internal_mutable_max_limit()->::opi_api::storage::v1::QosLimit::MergeFrom(
        from._internal_max_limit());
  }
  if (from._internal_has_nvme_controller_id()) {
    _this->_internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_max_nsq() != 0) {
    _this->_internal_set_max_nsq(from._internal_max_nsq());
  }
  if (from._internal_max_ncq() != 0) {
    _this->_internal_set_max_ncq(from._internal_max_ncq());
  }
  if (from._internal_sqes() != 0) {
    _this->_internal_set_sqes(from._internal_sqes());
  }
  if (from._internal_cqes() != 0) {
    _this->_internal_set_cqes(from._internal_cqes());
  }
  if (from._internal_max_namespaces() != 0) {
    _this->_internal_set_max_namespaces(from._internal_max_namespaces());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeControllerSpec::CopyFrom(const NvmeControllerSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeControllerSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeControllerSpec::IsInitialized() const {
  return true;
}

void NvmeControllerSpec::InternalSwap(NvmeControllerSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeControllerSpec, _impl_.max_namespaces_)
      + sizeof(NvmeControllerSpec::_impl_.max_namespaces_)
      - PROTOBUF_FIELD_OFFSET(NvmeControllerSpec, _impl_.pcie_id_)>(
          reinterpret_cast<char*>(&_impl_.pcie_id_),
          reinterpret_cast<char*>(&other->_impl_.pcie_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeControllerSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[4]);
}

// ===================================================================

class NvmeControllerStatus::_Internal {
 public:
};

NvmeControllerStatus::NvmeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeControllerStatus)
}
NvmeControllerStatus::NvmeControllerStatus(const NvmeControllerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeControllerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.active_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.active_ = from._impl_.active_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeControllerStatus)
}

inline void NvmeControllerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.active_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NvmeControllerStatus::~NvmeControllerStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeControllerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeControllerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NvmeControllerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeControllerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeControllerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.active_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeControllerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool active = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeControllerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeControllerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool active = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeControllerStatus)
  return target;
}

size_t NvmeControllerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeControllerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool active = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_active() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeControllerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeControllerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeControllerStatus::GetClassData() const { return &_class_data_; }


void NvmeControllerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeControllerStatus*>(&to_msg);
  auto& from = static_cast<const NvmeControllerStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeControllerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_active() != 0) {
    _this->_internal_set_active(from._internal_active());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeControllerStatus::CopyFrom(const NvmeControllerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeControllerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeControllerStatus::IsInitialized() const {
  return true;
}

void NvmeControllerStatus::InternalSwap(NvmeControllerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.active_, other->_impl_.active_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeControllerStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[5]);
}

// ===================================================================

class NvmeNamespace::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeNamespaceSpec& spec(const NvmeNamespace* msg);
  static const ::opi_api::storage::v1::NvmeNamespaceStatus& status(const NvmeNamespace* msg);
};

const ::opi_api::storage::v1::NvmeNamespaceSpec&
NvmeNamespace::_Internal::spec(const NvmeNamespace* msg) {
  return *msg->_impl_.spec_;
}
const ::opi_api::storage::v1::NvmeNamespaceStatus&
NvmeNamespace::_Internal::status(const NvmeNamespace* msg) {
  return *msg->_impl_.status_;
}
NvmeNamespace::NvmeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeNamespace)
}
NvmeNamespace::NvmeNamespace(const NvmeNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeNamespace* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_spec()) {
    _this->_impl_.spec_ = new ::opi_api::storage::v1::NvmeNamespaceSpec(*from._impl_.spec_);
  }
  if (from._internal_has_status()) {
    _this->_impl_.status_ = new ::opi_api::storage::v1::NvmeNamespaceStatus(*from._impl_.status_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeNamespace)
}

inline void NvmeNamespace::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.spec_){nullptr}
    , decltype(_impl_.status_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeNamespace::~NvmeNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeNamespace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.spec_;
  if (this != internal_default_instance()) delete _impl_.status_;
}

void NvmeNamespace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeNamespace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespace.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespaceStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespace.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::spec(this),
        _Internal::spec(this).GetCachedSize(), target, stream);
  }

  // .opi_api.storage.v1.NvmeNamespaceStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeNamespace)
  return target;
}

size_t NvmeNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_spec()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.spec_);
  }

  // .opi_api.storage.v1.NvmeNamespaceStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.status_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeNamespace::GetClassData() const { return &_class_data_; }


void NvmeNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeNamespace*>(&to_msg);
  auto& from = static_cast<const NvmeNamespace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeNamespace)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_spec()) {
    _this->_internal_mutable_spec()->::opi_api::storage::v1::NvmeNamespaceSpec::MergeFrom(
        from._internal_spec());
  }
  if (from._internal_has_status()) {
    _this->_internal_mutable_status()->::opi_api::storage::v1::NvmeNamespaceStatus::MergeFrom(
        from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeNamespace::CopyFrom(const NvmeNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeNamespace::IsInitialized() const {
  return true;
}

void NvmeNamespace::InternalSwap(NvmeNamespace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeNamespace, _impl_.status_)
      + sizeof(NvmeNamespace::_impl_.status_)
      - PROTOBUF_FIELD_OFFSET(NvmeNamespace, _impl_.spec_)>(
          reinterpret_cast<char*>(&_impl_.spec_),
          reinterpret_cast<char*>(&other->_impl_.spec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeNamespace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[6]);
}

// ===================================================================

class NvmeNamespaceSpec::_Internal {
 public:
  static const ::opi_api::common::v1::Uuid& uuid(const NvmeNamespaceSpec* msg);
};

const ::opi_api::common::v1::Uuid&
NvmeNamespaceSpec::_Internal::uuid(const NvmeNamespaceSpec* msg) {
  return *msg->_impl_.uuid_;
}
void NvmeNamespaceSpec::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
}
NvmeNamespaceSpec::NvmeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeNamespaceSpec)
}
NvmeNamespaceSpec::NvmeNamespaceSpec(const NvmeNamespaceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeNamespaceSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nguid_){}
    , decltype(_impl_.volume_name_ref_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){}
    , decltype(_impl_.host_nsid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    _this->_impl_.nguid_.Set(from._internal_nguid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.volume_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volume_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_volume_name_ref().empty()) {
    _this->_impl_.volume_name_ref_.Set(from._internal_volume_name_ref(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::opi_api::common::v1::Uuid(*from._impl_.uuid_);
  }
  ::memcpy(&_impl_.eui64_, &from._impl_.eui64_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.host_nsid_) -
    reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.host_nsid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeNamespaceSpec)
}

inline void NvmeNamespaceSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nguid_){}
    , decltype(_impl_.volume_name_ref_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){int64_t{0}}
    , decltype(_impl_.host_nsid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.volume_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.volume_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeNamespaceSpec::~NvmeNamespaceSpec() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeNamespaceSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeNamespaceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nguid_.Destroy();
  _impl_.volume_name_ref_.Destroy();
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void NvmeNamespaceSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeNamespaceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nguid_.ClearToEmpty();
  _impl_.volume_name_ref_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
  ::memset(&_impl_.eui64_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.host_nsid_) -
      reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.host_nsid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeNamespaceSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 host_nsid = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.host_nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nguid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespaceSpec.nguid"));
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_volume_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeNamespaceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeNamespaceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 host_nsid = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_host_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_host_nsid(), target);
  }

  // string nguid = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespaceSpec.nguid");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nguid(), target);
  }

  // int64 eui64 = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_uuid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_volume_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_volume_name_ref().data(), static_cast<int>(this->_internal_volume_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_volume_name_ref(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeNamespaceSpec)
  return target;
}

size_t NvmeNamespaceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeNamespaceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nguid = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_volume_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_volume_name_ref());
  }

  // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_);
  }

  // int64 eui64 = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_eui64() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 host_nsid = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_host_nsid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_host_nsid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeNamespaceSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeNamespaceSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeNamespaceSpec::GetClassData() const { return &_class_data_; }


void NvmeNamespaceSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeNamespaceSpec*>(&to_msg);
  auto& from = static_cast<const NvmeNamespaceSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeNamespaceSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nguid().empty()) {
    _this->_internal_set_nguid(from._internal_nguid());
  }
  if (!from._internal_volume_name_ref().empty()) {
    _this->_internal_set_volume_name_ref(from._internal_volume_name_ref());
  }
  if (from._internal_has_uuid()) {
    _this->_internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(
        from._internal_uuid());
  }
  if (from._internal_eui64() != 0) {
    _this->_internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_host_nsid() != 0) {
    _this->_internal_set_host_nsid(from._internal_host_nsid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeNamespaceSpec::CopyFrom(const NvmeNamespaceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeNamespaceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeNamespaceSpec::IsInitialized() const {
  return true;
}

void NvmeNamespaceSpec::InternalSwap(NvmeNamespaceSpec* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nguid_, lhs_arena,
      &other->_impl_.nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.volume_name_ref_, lhs_arena,
      &other->_impl_.volume_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeNamespaceSpec, _impl_.host_nsid_)
      + sizeof(NvmeNamespaceSpec::_impl_.host_nsid_)
      - PROTOBUF_FIELD_OFFSET(NvmeNamespaceSpec, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeNamespaceSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[7]);
}

// ===================================================================

class NvmeNamespaceStatus::_Internal {
 public:
};

NvmeNamespaceStatus::NvmeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeNamespaceStatus)
}
NvmeNamespaceStatus::NvmeNamespaceStatus(const NvmeNamespaceStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeNamespaceStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pci_state_){}
    , decltype(_impl_.pci_oper_state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pci_state_, &from._impl_.pci_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pci_oper_state_) -
    reinterpret_cast<char*>(&_impl_.pci_state_)) + sizeof(_impl_.pci_oper_state_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeNamespaceStatus)
}

inline void NvmeNamespaceStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pci_state_){0}
    , decltype(_impl_.pci_oper_state_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NvmeNamespaceStatus::~NvmeNamespaceStatus() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeNamespaceStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeNamespaceStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NvmeNamespaceStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeNamespaceStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.pci_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.pci_oper_state_) -
      reinterpret_cast<char*>(&_impl_.pci_state_)) + sizeof(_impl_.pci_oper_state_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeNamespaceStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_state(static_cast<::opi_api::storage::v1::NvmeNamespacePciState>(val));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pci_oper_state(static_cast<::opi_api::storage::v1::NvmeNamespacePciOperState>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeNamespaceStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeNamespaceStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_pci_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pci_state(), target);
  }

  // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_pci_oper_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_pci_oper_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeNamespaceStatus)
  return target;
}

size_t NvmeNamespaceStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeNamespaceStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_pci_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pci_state());
  }

  // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_pci_oper_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pci_oper_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeNamespaceStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeNamespaceStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeNamespaceStatus::GetClassData() const { return &_class_data_; }


void NvmeNamespaceStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeNamespaceStatus*>(&to_msg);
  auto& from = static_cast<const NvmeNamespaceStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeNamespaceStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_pci_state() != 0) {
    _this->_internal_set_pci_state(from._internal_pci_state());
  }
  if (from._internal_pci_oper_state() != 0) {
    _this->_internal_set_pci_oper_state(from._internal_pci_oper_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeNamespaceStatus::CopyFrom(const NvmeNamespaceStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeNamespaceStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeNamespaceStatus::IsInitialized() const {
  return true;
}

void NvmeNamespaceStatus::InternalSwap(NvmeNamespaceStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeNamespaceStatus, _impl_.pci_oper_state_)
      + sizeof(NvmeNamespaceStatus::_impl_.pci_oper_state_)
      - PROTOBUF_FIELD_OFFSET(NvmeNamespaceStatus, _impl_.pci_state_)>(
          reinterpret_cast<char*>(&_impl_.pci_state_),
          reinterpret_cast<char*>(&other->_impl_.pci_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeNamespaceStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[8]);
}

// ===================================================================

class CreateNvmeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystem(const CreateNvmeSubsystemRequest* msg);
};

const ::opi_api::storage::v1::NvmeSubsystem&
CreateNvmeSubsystemRequest::_Internal::nvme_subsystem(const CreateNvmeSubsystemRequest* msg) {
  return *msg->_impl_.nvme_subsystem_;
}
CreateNvmeSubsystemRequest::CreateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeSubsystemRequest)
}
CreateNvmeSubsystemRequest::CreateNvmeSubsystemRequest(const CreateNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmeSubsystemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_subsystem_id_){}
    , decltype(_impl_.nvme_subsystem_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nvme_subsystem_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_subsystem_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_subsystem_id().empty()) {
    _this->_impl_.nvme_subsystem_id_.Set(from._internal_nvme_subsystem_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_subsystem()) {
    _this->_impl_.nvme_subsystem_ = new ::opi_api::storage::v1::NvmeSubsystem(*from._impl_.nvme_subsystem_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeSubsystemRequest)
}

inline void CreateNvmeSubsystemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_subsystem_id_){}
    , decltype(_impl_.nvme_subsystem_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nvme_subsystem_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_subsystem_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmeSubsystemRequest::~CreateNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_subsystem_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_subsystem_;
}

void CreateNvmeSubsystemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_subsystem_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_subsystem_ != nullptr) {
    delete _impl_.nvme_subsystem_;
  }
  _impl_.nvme_subsystem_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeSubsystemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_subsystem_id = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_subsystem_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_subsystem()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_subsystem(this),
        _Internal::nvme_subsystem(this).GetCachedSize(), target, stream);
  }

  // string nvme_subsystem_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_subsystem_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_subsystem_id().data(), static_cast<int>(this->_internal_nvme_subsystem_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_subsystem_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  return target;
}

size_t CreateNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_subsystem_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_subsystem_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_subsystem_id());
  }

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_subsystem_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }


void CreateNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmeSubsystemRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmeSubsystemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_subsystem_id().empty()) {
    _this->_internal_set_nvme_subsystem_id(from._internal_nvme_subsystem_id());
  }
  if (from._internal_has_nvme_subsystem()) {
    _this->_internal_mutable_nvme_subsystem()->::opi_api::storage::v1::NvmeSubsystem::MergeFrom(
        from._internal_nvme_subsystem());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeSubsystemRequest::CopyFrom(const CreateNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void CreateNvmeSubsystemRequest::InternalSwap(CreateNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_subsystem_id_, lhs_arena,
      &other->_impl_.nvme_subsystem_id_, rhs_arena
  );
  swap(_impl_.nvme_subsystem_, other->_impl_.nvme_subsystem_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeSubsystemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[9]);
}

// ===================================================================

class DeleteNvmeSubsystemRequest::_Internal {
 public:
};

DeleteNvmeSubsystemRequest::DeleteNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
}
DeleteNvmeSubsystemRequest::DeleteNvmeSubsystemRequest(const DeleteNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmeSubsystemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
}

inline void DeleteNvmeSubsystemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmeSubsystemRequest::~DeleteNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmeSubsystemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeSubsystemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeSubsystemRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeSubsystemRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  return target;
}

size_t DeleteNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmeSubsystemRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmeSubsystemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeSubsystemRequest::CopyFrom(const DeleteNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeSubsystemRequest::InternalSwap(DeleteNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeSubsystemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[10]);
}

// ===================================================================

class UpdateNvmeSubsystemRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystem(const UpdateNvmeSubsystemRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeSubsystemRequest* msg);
};

const ::opi_api::storage::v1::NvmeSubsystem&
UpdateNvmeSubsystemRequest::_Internal::nvme_subsystem(const UpdateNvmeSubsystemRequest* msg) {
  return *msg->_impl_.nvme_subsystem_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeSubsystemRequest::_Internal::update_mask(const UpdateNvmeSubsystemRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmeSubsystemRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmeSubsystemRequest::UpdateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
}
UpdateNvmeSubsystemRequest::UpdateNvmeSubsystemRequest(const UpdateNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmeSubsystemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_subsystem_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_subsystem()) {
    _this->_impl_.nvme_subsystem_ = new ::opi_api::storage::v1::NvmeSubsystem(*from._impl_.nvme_subsystem_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
}

inline void UpdateNvmeSubsystemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_subsystem_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmeSubsystemRequest::~UpdateNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_subsystem_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmeSubsystemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_subsystem_ != nullptr) {
    delete _impl_.nvme_subsystem_;
  }
  _impl_.nvme_subsystem_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeSubsystemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_subsystem(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_subsystem()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_subsystem(this),
        _Internal::nvme_subsystem(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  return target;
}

size_t UpdateNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_subsystem()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_subsystem_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmeSubsystemRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmeSubsystemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_subsystem()) {
    _this->_internal_mutable_nvme_subsystem()->::opi_api::storage::v1::NvmeSubsystem::MergeFrom(
        from._internal_nvme_subsystem());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeSubsystemRequest::CopyFrom(const UpdateNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeSubsystemRequest::InternalSwap(UpdateNvmeSubsystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeSubsystemRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmeSubsystemRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeSubsystemRequest, _impl_.nvme_subsystem_)>(
          reinterpret_cast<char*>(&_impl_.nvme_subsystem_),
          reinterpret_cast<char*>(&other->_impl_.nvme_subsystem_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeSubsystemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[11]);
}

// ===================================================================

class ListNvmeSubsystemsRequest::_Internal {
 public:
};

ListNvmeSubsystemsRequest::ListNvmeSubsystemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeSubsystemsRequest)
}
ListNvmeSubsystemsRequest::ListNvmeSubsystemsRequest(const ListNvmeSubsystemsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeSubsystemsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeSubsystemsRequest)
}

inline void ListNvmeSubsystemsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeSubsystemsRequest::~ListNvmeSubsystemsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeSubsystemsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.page_token_.Destroy();
}

void ListNvmeSubsystemsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeSubsystemsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeSubsystemsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeSubsystemsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  return target;
}

size_t ListNvmeSubsystemsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeSubsystemsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeSubsystemsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeSubsystemsRequest::GetClassData() const { return &_class_data_; }


void ListNvmeSubsystemsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeSubsystemsRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeSubsystemsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeSubsystemsRequest::CopyFrom(const ListNvmeSubsystemsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeSubsystemsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeSubsystemsRequest::IsInitialized() const {
  return true;
}

void ListNvmeSubsystemsRequest::InternalSwap(ListNvmeSubsystemsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeSubsystemsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[12]);
}

// ===================================================================

class ListNvmeSubsystemsResponse::_Internal {
 public:
};

ListNvmeSubsystemsResponse::ListNvmeSubsystemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeSubsystemsResponse)
}
ListNvmeSubsystemsResponse::ListNvmeSubsystemsResponse(const ListNvmeSubsystemsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeSubsystemsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_subsystems_){from._impl_.nvme_subsystems_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeSubsystemsResponse)
}

inline void ListNvmeSubsystemsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_subsystems_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeSubsystemsResponse::~ListNvmeSubsystemsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeSubsystemsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_subsystems_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeSubsystemsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeSubsystemsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_subsystems_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeSubsystemsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_subsystems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeSubsystemsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_subsystems_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_subsystems(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  return target;
}

size_t ListNvmeSubsystemsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
  total_size += 1UL * this->_internal_nvme_subsystems_size();
  for (const auto& msg : this->_impl_.nvme_subsystems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeSubsystemsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeSubsystemsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeSubsystemsResponse::GetClassData() const { return &_class_data_; }


void ListNvmeSubsystemsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeSubsystemsResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeSubsystemsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_subsystems_.MergeFrom(from._impl_.nvme_subsystems_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeSubsystemsResponse::CopyFrom(const ListNvmeSubsystemsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeSubsystemsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeSubsystemsResponse::IsInitialized() const {
  return true;
}

void ListNvmeSubsystemsResponse::InternalSwap(ListNvmeSubsystemsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_subsystems_.InternalSwap(&other->_impl_.nvme_subsystems_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeSubsystemsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[13]);
}

// ===================================================================

class GetNvmeSubsystemRequest::_Internal {
 public:
};

GetNvmeSubsystemRequest::GetNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeSubsystemRequest)
}
GetNvmeSubsystemRequest::GetNvmeSubsystemRequest(const GetNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeSubsystemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeSubsystemRequest)
}

inline void GetNvmeSubsystemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeSubsystemRequest::~GetNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeSubsystemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeSubsystemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeSubsystemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeSubsystemRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeSubsystemRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeSubsystemRequest)
  return target;
}

size_t GetNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }


void GetNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeSubsystemRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeSubsystemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeSubsystemRequest::CopyFrom(const GetNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void GetNvmeSubsystemRequest::InternalSwap(GetNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeSubsystemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[14]);
}

// ===================================================================

class StatsNvmeSubsystemRequest::_Internal {
 public:
};

StatsNvmeSubsystemRequest::StatsNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeSubsystemRequest)
}
StatsNvmeSubsystemRequest::StatsNvmeSubsystemRequest(const StatsNvmeSubsystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeSubsystemRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeSubsystemRequest)
}

inline void StatsNvmeSubsystemRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeSubsystemRequest::~StatsNvmeSubsystemRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeSubsystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmeSubsystemRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeSubsystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeSubsystemRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeSubsystemRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeSubsystemRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeSubsystemRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  return target;
}

size_t StatsNvmeSubsystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeSubsystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeSubsystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeSubsystemRequest::GetClassData() const { return &_class_data_; }


void StatsNvmeSubsystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeSubsystemRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmeSubsystemRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeSubsystemRequest::CopyFrom(const StatsNvmeSubsystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeSubsystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeSubsystemRequest::IsInitialized() const {
  return true;
}

void StatsNvmeSubsystemRequest::InternalSwap(StatsNvmeSubsystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeSubsystemRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[15]);
}

// ===================================================================

class StatsNvmeSubsystemResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeSubsystemResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeSubsystemResponse::_Internal::stats(const StatsNvmeSubsystemResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmeSubsystemResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmeSubsystemResponse::StatsNvmeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeSubsystemResponse)
}
StatsNvmeSubsystemResponse::StatsNvmeSubsystemResponse(const StatsNvmeSubsystemResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeSubsystemResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeSubsystemResponse)
}

inline void StatsNvmeSubsystemResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmeSubsystemResponse::~StatsNvmeSubsystemResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeSubsystemResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmeSubsystemResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeSubsystemResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeSubsystemResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeSubsystemResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  return target;
}

size_t StatsNvmeSubsystemResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeSubsystemResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeSubsystemResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeSubsystemResponse::GetClassData() const { return &_class_data_; }


void StatsNvmeSubsystemResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeSubsystemResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmeSubsystemResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeSubsystemResponse::CopyFrom(const StatsNvmeSubsystemResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeSubsystemResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeSubsystemResponse::IsInitialized() const {
  return true;
}

void StatsNvmeSubsystemResponse::InternalSwap(StatsNvmeSubsystemResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeSubsystemResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[16]);
}

// ===================================================================

class CreateNvmeControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeController& nvme_controller(const CreateNvmeControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeController&
CreateNvmeControllerRequest::_Internal::nvme_controller(const CreateNvmeControllerRequest* msg) {
  return *msg->_impl_.nvme_controller_;
}
CreateNvmeControllerRequest::CreateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeControllerRequest)
}
CreateNvmeControllerRequest::CreateNvmeControllerRequest(const CreateNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmeControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.nvme_controller_id_){}
    , decltype(_impl_.nvme_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nvme_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_controller_id().empty()) {
    _this->_impl_.nvme_controller_id_.Set(from._internal_nvme_controller_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_controller()) {
    _this->_impl_.nvme_controller_ = new ::opi_api::storage::v1::NvmeController(*from._impl_.nvme_controller_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeControllerRequest)
}

inline void CreateNvmeControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.nvme_controller_id_){}
    , decltype(_impl_.nvme_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nvme_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmeControllerRequest::~CreateNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.nvme_controller_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_controller_;
}

void CreateNvmeControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.nvme_controller_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_controller_ != nullptr) {
    delete _impl_.nvme_controller_;
  }
  _impl_.nvme_controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeControllerRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeController nvme_controller = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_controller_id = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nvme_controller_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeControllerRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // .opi_api.storage.v1.NvmeController nvme_controller = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nvme_controller(this),
        _Internal::nvme_controller(this).GetCachedSize(), target, stream);
  }

  // string nvme_controller_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_controller_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_controller_id().data(), static_cast<int>(this->_internal_nvme_controller_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nvme_controller_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeControllerRequest)
  return target;
}

size_t CreateNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string nvme_controller_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_controller_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_controller_id());
  }

  // .opi_api.storage.v1.NvmeController nvme_controller = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeControllerRequest::GetClassData() const { return &_class_data_; }


void CreateNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmeControllerRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmeControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_nvme_controller_id().empty()) {
    _this->_internal_set_nvme_controller_id(from._internal_nvme_controller_id());
  }
  if (from._internal_has_nvme_controller()) {
    _this->_internal_mutable_nvme_controller()->::opi_api::storage::v1::NvmeController::MergeFrom(
        from._internal_nvme_controller());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeControllerRequest::CopyFrom(const CreateNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeControllerRequest::IsInitialized() const {
  return true;
}

void CreateNvmeControllerRequest::InternalSwap(CreateNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_controller_id_, lhs_arena,
      &other->_impl_.nvme_controller_id_, rhs_arena
  );
  swap(_impl_.nvme_controller_, other->_impl_.nvme_controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[17]);
}

// ===================================================================

class DeleteNvmeControllerRequest::_Internal {
 public:
};

DeleteNvmeControllerRequest::DeleteNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeControllerRequest)
}
DeleteNvmeControllerRequest::DeleteNvmeControllerRequest(const DeleteNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmeControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeControllerRequest)
}

inline void DeleteNvmeControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmeControllerRequest::~DeleteNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmeControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeControllerRequest)
  return target;
}

size_t DeleteNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeControllerRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmeControllerRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmeControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeControllerRequest::CopyFrom(const DeleteNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeControllerRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeControllerRequest::InternalSwap(DeleteNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[18]);
}

// ===================================================================

class UpdateNvmeControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeController& nvme_controller(const UpdateNvmeControllerRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeController&
UpdateNvmeControllerRequest::_Internal::nvme_controller(const UpdateNvmeControllerRequest* msg) {
  return *msg->_impl_.nvme_controller_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeControllerRequest::_Internal::update_mask(const UpdateNvmeControllerRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmeControllerRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmeControllerRequest::UpdateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeControllerRequest)
}
UpdateNvmeControllerRequest::UpdateNvmeControllerRequest(const UpdateNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmeControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_controller()) {
    _this->_impl_.nvme_controller_ = new ::opi_api::storage::v1::NvmeController(*from._impl_.nvme_controller_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeControllerRequest)
}

inline void UpdateNvmeControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmeControllerRequest::~UpdateNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_controller_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmeControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_controller_ != nullptr) {
    delete _impl_.nvme_controller_;
  }
  _impl_.nvme_controller_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_controller(this),
        _Internal::nvme_controller(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeControllerRequest)
  return target;
}

size_t UpdateNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_controller_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeControllerRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmeControllerRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmeControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_controller()) {
    _this->_internal_mutable_nvme_controller()->::opi_api::storage::v1::NvmeController::MergeFrom(
        from._internal_nvme_controller());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeControllerRequest::CopyFrom(const UpdateNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeControllerRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeControllerRequest::InternalSwap(UpdateNvmeControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeControllerRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmeControllerRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeControllerRequest, _impl_.nvme_controller_)>(
          reinterpret_cast<char*>(&_impl_.nvme_controller_),
          reinterpret_cast<char*>(&other->_impl_.nvme_controller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[19]);
}

// ===================================================================

class ListNvmeControllersRequest::_Internal {
 public:
};

ListNvmeControllersRequest::ListNvmeControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeControllersRequest)
}
ListNvmeControllersRequest::ListNvmeControllersRequest(const ListNvmeControllersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeControllersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeControllersRequest)
}

inline void ListNvmeControllersRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeControllersRequest::~ListNvmeControllersRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeControllersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeControllersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeControllersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeControllersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeControllersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeControllersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeControllersRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeControllersRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeControllersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeControllersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeControllersRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeControllersRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeControllersRequest)
  return target;
}

size_t ListNvmeControllersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeControllersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeControllersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeControllersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeControllersRequest::GetClassData() const { return &_class_data_; }


void ListNvmeControllersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeControllersRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeControllersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeControllersRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeControllersRequest::CopyFrom(const ListNvmeControllersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeControllersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeControllersRequest::IsInitialized() const {
  return true;
}

void ListNvmeControllersRequest::InternalSwap(ListNvmeControllersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeControllersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[20]);
}

// ===================================================================

class ListNvmeControllersResponse::_Internal {
 public:
};

ListNvmeControllersResponse::ListNvmeControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeControllersResponse)
}
ListNvmeControllersResponse::ListNvmeControllersResponse(const ListNvmeControllersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeControllersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_controllers_){from._impl_.nvme_controllers_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeControllersResponse)
}

inline void ListNvmeControllersResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_controllers_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeControllersResponse::~ListNvmeControllersResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeControllersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeControllersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_controllers_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeControllersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeControllersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeControllersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_controllers_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeControllersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_controllers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeControllersResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeControllersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeControllersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_controllers_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_controllers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeControllersResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeControllersResponse)
  return target;
}

size_t ListNvmeControllersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeControllersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
  total_size += 1UL * this->_internal_nvme_controllers_size();
  for (const auto& msg : this->_impl_.nvme_controllers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeControllersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeControllersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeControllersResponse::GetClassData() const { return &_class_data_; }


void ListNvmeControllersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeControllersResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeControllersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeControllersResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_controllers_.MergeFrom(from._impl_.nvme_controllers_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeControllersResponse::CopyFrom(const ListNvmeControllersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeControllersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeControllersResponse::IsInitialized() const {
  return true;
}

void ListNvmeControllersResponse::InternalSwap(ListNvmeControllersResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_controllers_.InternalSwap(&other->_impl_.nvme_controllers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeControllersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[21]);
}

// ===================================================================

class GetNvmeControllerRequest::_Internal {
 public:
};

GetNvmeControllerRequest::GetNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeControllerRequest)
}
GetNvmeControllerRequest::GetNvmeControllerRequest(const GetNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeControllerRequest)
}

inline void GetNvmeControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeControllerRequest::~GetNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeControllerRequest)
  return target;
}

size_t GetNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeControllerRequest::GetClassData() const { return &_class_data_; }


void GetNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeControllerRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeControllerRequest::CopyFrom(const GetNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeControllerRequest::IsInitialized() const {
  return true;
}

void GetNvmeControllerRequest::InternalSwap(GetNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[22]);
}

// ===================================================================

class StatsNvmeControllerRequest::_Internal {
 public:
};

StatsNvmeControllerRequest::StatsNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeControllerRequest)
}
StatsNvmeControllerRequest::StatsNvmeControllerRequest(const StatsNvmeControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeControllerRequest)
}

inline void StatsNvmeControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeControllerRequest::~StatsNvmeControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmeControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeControllerRequest)
  return target;
}

size_t StatsNvmeControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeControllerRequest::GetClassData() const { return &_class_data_; }


void StatsNvmeControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeControllerRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmeControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeControllerRequest::CopyFrom(const StatsNvmeControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeControllerRequest::IsInitialized() const {
  return true;
}

void StatsNvmeControllerRequest::InternalSwap(StatsNvmeControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[23]);
}

// ===================================================================

class StatsNvmeControllerResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeControllerResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeControllerResponse::_Internal::stats(const StatsNvmeControllerResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmeControllerResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmeControllerResponse::StatsNvmeControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeControllerResponse)
}
StatsNvmeControllerResponse::StatsNvmeControllerResponse(const StatsNvmeControllerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeControllerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeControllerResponse)
}

inline void StatsNvmeControllerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmeControllerResponse::~StatsNvmeControllerResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeControllerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeControllerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmeControllerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeControllerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeControllerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeControllerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeControllerResponse)
  return target;
}

size_t StatsNvmeControllerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeControllerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeControllerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeControllerResponse::GetClassData() const { return &_class_data_; }


void StatsNvmeControllerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeControllerResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmeControllerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeControllerResponse::CopyFrom(const StatsNvmeControllerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeControllerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeControllerResponse::IsInitialized() const {
  return true;
}

void StatsNvmeControllerResponse::InternalSwap(StatsNvmeControllerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeControllerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[24]);
}

// ===================================================================

class CreateNvmeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeNamespace& nvme_namespace(const CreateNvmeNamespaceRequest* msg);
};

const ::opi_api::storage::v1::NvmeNamespace&
CreateNvmeNamespaceRequest::_Internal::nvme_namespace(const CreateNvmeNamespaceRequest* msg) {
  return *msg->_impl_.nvme_namespace_;
}
CreateNvmeNamespaceRequest::CreateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeNamespaceRequest)
}
CreateNvmeNamespaceRequest::CreateNvmeNamespaceRequest(const CreateNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmeNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.nvme_namespace_id_){}
    , decltype(_impl_.nvme_namespace_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nvme_namespace_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_namespace_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_namespace_id().empty()) {
    _this->_impl_.nvme_namespace_id_.Set(from._internal_nvme_namespace_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_namespace()) {
    _this->_impl_.nvme_namespace_ = new ::opi_api::storage::v1::NvmeNamespace(*from._impl_.nvme_namespace_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeNamespaceRequest)
}

inline void CreateNvmeNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.nvme_namespace_id_){}
    , decltype(_impl_.nvme_namespace_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nvme_namespace_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_namespace_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmeNamespaceRequest::~CreateNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.nvme_namespace_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_namespace_;
}

void CreateNvmeNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.nvme_namespace_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_namespace_ != nullptr) {
    delete _impl_.nvme_namespace_;
  }
  _impl_.nvme_namespace_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeNamespaceRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_namespace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_namespace_id = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nvme_namespace_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeNamespaceRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_namespace()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nvme_namespace(this),
        _Internal::nvme_namespace(this).GetCachedSize(), target, stream);
  }

  // string nvme_namespace_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_namespace_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_namespace_id().data(), static_cast<int>(this->_internal_nvme_namespace_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nvme_namespace_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  return target;
}

size_t CreateNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string nvme_namespace_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_namespace_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_namespace_id());
  }

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_namespace()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_namespace_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }


void CreateNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmeNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmeNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_nvme_namespace_id().empty()) {
    _this->_internal_set_nvme_namespace_id(from._internal_nvme_namespace_id());
  }
  if (from._internal_has_nvme_namespace()) {
    _this->_internal_mutable_nvme_namespace()->::opi_api::storage::v1::NvmeNamespace::MergeFrom(
        from._internal_nvme_namespace());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeNamespaceRequest::CopyFrom(const CreateNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void CreateNvmeNamespaceRequest::InternalSwap(CreateNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_namespace_id_, lhs_arena,
      &other->_impl_.nvme_namespace_id_, rhs_arena
  );
  swap(_impl_.nvme_namespace_, other->_impl_.nvme_namespace_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[25]);
}

// ===================================================================

class DeleteNvmeNamespaceRequest::_Internal {
 public:
};

DeleteNvmeNamespaceRequest::DeleteNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
}
DeleteNvmeNamespaceRequest::DeleteNvmeNamespaceRequest(const DeleteNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmeNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
}

inline void DeleteNvmeNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmeNamespaceRequest::~DeleteNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmeNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeNamespaceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  return target;
}

size_t DeleteNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmeNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmeNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeNamespaceRequest::CopyFrom(const DeleteNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeNamespaceRequest::InternalSwap(DeleteNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[26]);
}

// ===================================================================

class UpdateNvmeNamespaceRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeNamespace& nvme_namespace(const UpdateNvmeNamespaceRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeNamespaceRequest* msg);
};

const ::opi_api::storage::v1::NvmeNamespace&
UpdateNvmeNamespaceRequest::_Internal::nvme_namespace(const UpdateNvmeNamespaceRequest* msg) {
  return *msg->_impl_.nvme_namespace_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeNamespaceRequest::_Internal::update_mask(const UpdateNvmeNamespaceRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmeNamespaceRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmeNamespaceRequest::UpdateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
}
UpdateNvmeNamespaceRequest::UpdateNvmeNamespaceRequest(const UpdateNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmeNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_namespace_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_namespace()) {
    _this->_impl_.nvme_namespace_ = new ::opi_api::storage::v1::NvmeNamespace(*from._impl_.nvme_namespace_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
}

inline void UpdateNvmeNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_namespace_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmeNamespaceRequest::~UpdateNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_namespace_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmeNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_namespace_ != nullptr) {
    delete _impl_.nvme_namespace_;
  }
  _impl_.nvme_namespace_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_namespace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_namespace()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_namespace(this),
        _Internal::nvme_namespace(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  return target;
}

size_t UpdateNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_namespace()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_namespace_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmeNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmeNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_namespace()) {
    _this->_internal_mutable_nvme_namespace()->::opi_api::storage::v1::NvmeNamespace::MergeFrom(
        from._internal_nvme_namespace());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeNamespaceRequest::CopyFrom(const UpdateNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeNamespaceRequest::InternalSwap(UpdateNvmeNamespaceRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeNamespaceRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmeNamespaceRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeNamespaceRequest, _impl_.nvme_namespace_)>(
          reinterpret_cast<char*>(&_impl_.nvme_namespace_),
          reinterpret_cast<char*>(&other->_impl_.nvme_namespace_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[27]);
}

// ===================================================================

class ListNvmeNamespacesRequest::_Internal {
 public:
};

ListNvmeNamespacesRequest::ListNvmeNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeNamespacesRequest)
}
ListNvmeNamespacesRequest::ListNvmeNamespacesRequest(const ListNvmeNamespacesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeNamespacesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeNamespacesRequest)
}

inline void ListNvmeNamespacesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeNamespacesRequest::~ListNvmeNamespacesRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeNamespacesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeNamespacesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeNamespacesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeNamespacesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeNamespacesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeNamespacesRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeNamespacesRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeNamespacesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeNamespacesRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeNamespacesRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeNamespacesRequest)
  return target;
}

size_t ListNvmeNamespacesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeNamespacesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeNamespacesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeNamespacesRequest::GetClassData() const { return &_class_data_; }


void ListNvmeNamespacesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeNamespacesRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeNamespacesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeNamespacesRequest::CopyFrom(const ListNvmeNamespacesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeNamespacesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeNamespacesRequest::IsInitialized() const {
  return true;
}

void ListNvmeNamespacesRequest::InternalSwap(ListNvmeNamespacesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeNamespacesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[28]);
}

// ===================================================================

class ListNvmeNamespacesResponse::_Internal {
 public:
};

ListNvmeNamespacesResponse::ListNvmeNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeNamespacesResponse)
}
ListNvmeNamespacesResponse::ListNvmeNamespacesResponse(const ListNvmeNamespacesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeNamespacesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_namespaces_){from._impl_.nvme_namespaces_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeNamespacesResponse)
}

inline void ListNvmeNamespacesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_namespaces_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeNamespacesResponse::~ListNvmeNamespacesResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeNamespacesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeNamespacesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_namespaces_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeNamespacesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeNamespacesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_namespaces_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeNamespacesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_namespaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeNamespacesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_namespaces_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_namespaces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeNamespacesResponse)
  return target;
}

size_t ListNvmeNamespacesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
  total_size += 1UL * this->_internal_nvme_namespaces_size();
  for (const auto& msg : this->_impl_.nvme_namespaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeNamespacesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeNamespacesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeNamespacesResponse::GetClassData() const { return &_class_data_; }


void ListNvmeNamespacesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeNamespacesResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeNamespacesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_namespaces_.MergeFrom(from._impl_.nvme_namespaces_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeNamespacesResponse::CopyFrom(const ListNvmeNamespacesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeNamespacesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeNamespacesResponse::IsInitialized() const {
  return true;
}

void ListNvmeNamespacesResponse::InternalSwap(ListNvmeNamespacesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_namespaces_.InternalSwap(&other->_impl_.nvme_namespaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeNamespacesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[29]);
}

// ===================================================================

class GetNvmeNamespaceRequest::_Internal {
 public:
};

GetNvmeNamespaceRequest::GetNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeNamespaceRequest)
}
GetNvmeNamespaceRequest::GetNvmeNamespaceRequest(const GetNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeNamespaceRequest)
}

inline void GetNvmeNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeNamespaceRequest::~GetNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeNamespaceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeNamespaceRequest)
  return target;
}

size_t GetNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }


void GetNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeNamespaceRequest::CopyFrom(const GetNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void GetNvmeNamespaceRequest::InternalSwap(GetNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[30]);
}

// ===================================================================

class StatsNvmeNamespaceRequest::_Internal {
 public:
};

StatsNvmeNamespaceRequest::StatsNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeNamespaceRequest)
}
StatsNvmeNamespaceRequest::StatsNvmeNamespaceRequest(const StatsNvmeNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeNamespaceRequest)
}

inline void StatsNvmeNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeNamespaceRequest::~StatsNvmeNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmeNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeNamespaceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  return target;
}

size_t StatsNvmeNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeNamespaceRequest::GetClassData() const { return &_class_data_; }


void StatsNvmeNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmeNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeNamespaceRequest::CopyFrom(const StatsNvmeNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeNamespaceRequest::IsInitialized() const {
  return true;
}

void StatsNvmeNamespaceRequest::InternalSwap(StatsNvmeNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[31]);
}

// ===================================================================

class StatsNvmeNamespaceResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeNamespaceResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeNamespaceResponse::_Internal::stats(const StatsNvmeNamespaceResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmeNamespaceResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmeNamespaceResponse::StatsNvmeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeNamespaceResponse)
}
StatsNvmeNamespaceResponse::StatsNvmeNamespaceResponse(const StatsNvmeNamespaceResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeNamespaceResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeNamespaceResponse)
}

inline void StatsNvmeNamespaceResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmeNamespaceResponse::~StatsNvmeNamespaceResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeNamespaceResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmeNamespaceResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeNamespaceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeNamespaceResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeNamespaceResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  return target;
}

size_t StatsNvmeNamespaceResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeNamespaceResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeNamespaceResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeNamespaceResponse::GetClassData() const { return &_class_data_; }


void StatsNvmeNamespaceResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeNamespaceResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmeNamespaceResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeNamespaceResponse::CopyFrom(const StatsNvmeNamespaceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeNamespaceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeNamespaceResponse::IsInitialized() const {
  return true;
}

void StatsNvmeNamespaceResponse::InternalSwap(StatsNvmeNamespaceResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeNamespaceResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_frontend_5fnvme_5fpcie_2eproto_getter, &descriptor_table_frontend_5fnvme_5fpcie_2eproto_once,
      file_level_metadata_frontend_5fnvme_5fpcie_2eproto[32]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeSubsystem*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeSubsystem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeSubsystem >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeSubsystemSpec*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeSubsystemSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeSubsystemSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeSubsystemStatus*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeSubsystemStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeSubsystemStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeController*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeControllerSpec*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeControllerSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeControllerSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeControllerStatus*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeControllerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeControllerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeNamespace*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeNamespaceSpec*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeNamespaceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeNamespaceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeNamespaceStatus*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeNamespaceStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeNamespaceStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeSubsystemRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeSubsystemRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeSubsystemRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeSubsystemsRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeSubsystemsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeSubsystemsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeSubsystemsResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeSubsystemsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeSubsystemsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeSubsystemRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeSubsystemRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeSubsystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeSubsystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeSubsystemResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeSubsystemResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeSubsystemResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeControllersRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeControllersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeControllersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeControllersResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeControllersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeControllersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeControllerResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeControllerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeControllerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeNamespacesRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeNamespacesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeNamespacesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeNamespacesResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeNamespacesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeNamespacesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeNamespaceResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeNamespaceResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeNamespaceResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
