// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: backend_aio.proto
// Original file comments:
// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2022 Dell Inc, or its subsidiaries.
// Copyright (C) 2023 Intel Corporation
//
#ifndef GRPC_backend_5faio_2eproto__INCLUDED
#define GRPC_backend_5faio_2eproto__INCLUDED

#include "backend_aio.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace opi_api {
namespace storage {
namespace v1 {

// Back End (network-facing) APIs. This service is for AIO generic kernel block device.
class AioVolumeService final {
 public:
  static constexpr char const* service_full_name() {
    return "opi_api.storage.v1.AioVolumeService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create an Aio Volume
    virtual ::grpc::Status CreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::opi_api::storage::v1::AioVolume* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>> AsyncCreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>>(AsyncCreateAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>> PrepareAsyncCreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>>(PrepareAsyncCreateAioVolumeRaw(context, request, cq));
    }
    // Delete an Aio Volume
    virtual ::grpc::Status DeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteAioVolumeRaw(context, request, cq));
    }
    // Update an Aio Volume
    virtual ::grpc::Status UpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::opi_api::storage::v1::AioVolume* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>> AsyncUpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>>(AsyncUpdateAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>> PrepareAsyncUpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>>(PrepareAsyncUpdateAioVolumeRaw(context, request, cq));
    }
    // List Aio Volumes
    virtual ::grpc::Status ListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::opi_api::storage::v1::ListAioVolumesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::ListAioVolumesResponse>> AsyncListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::ListAioVolumesResponse>>(AsyncListAioVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::ListAioVolumesResponse>> PrepareAsyncListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::ListAioVolumesResponse>>(PrepareAsyncListAioVolumesRaw(context, request, cq));
    }
    // Get an Aio Volume
    virtual ::grpc::Status GetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::opi_api::storage::v1::AioVolume* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>> AsyncGetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>>(AsyncGetAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>> PrepareAsyncGetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>>(PrepareAsyncGetAioVolumeRaw(context, request, cq));
    }
    // Get an Aio Volume statistics
    virtual ::grpc::Status StatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::opi_api::storage::v1::StatsAioVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::StatsAioVolumeResponse>> AsyncStatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::StatsAioVolumeResponse>>(AsyncStatsAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::StatsAioVolumeResponse>> PrepareAsyncStatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::StatsAioVolumeResponse>>(PrepareAsyncStatsAioVolumeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Create an Aio Volume
      virtual void CreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Delete an Aio Volume
      virtual void DeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Update an Aio Volume
      virtual void UpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List Aio Volumes
      virtual void ListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest* request, ::opi_api::storage::v1::ListAioVolumesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest* request, ::opi_api::storage::v1::ListAioVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get an Aio Volume
      virtual void GetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get an Aio Volume statistics
      virtual void StatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::opi_api::storage::v1::StatsAioVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::opi_api::storage::v1::StatsAioVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>* AsyncCreateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>* PrepareAsyncCreateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>* AsyncUpdateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>* PrepareAsyncUpdateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::ListAioVolumesResponse>* AsyncListAioVolumesRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::ListAioVolumesResponse>* PrepareAsyncListAioVolumesRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>* AsyncGetAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::AioVolume>* PrepareAsyncGetAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::StatsAioVolumeResponse>* AsyncStatsAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::opi_api::storage::v1::StatsAioVolumeResponse>* PrepareAsyncStatsAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::opi_api::storage::v1::AioVolume* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>> AsyncCreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>>(AsyncCreateAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>> PrepareAsyncCreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>>(PrepareAsyncCreateAioVolumeRaw(context, request, cq));
    }
    ::grpc::Status DeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteAioVolumeRaw(context, request, cq));
    }
    ::grpc::Status UpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::opi_api::storage::v1::AioVolume* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>> AsyncUpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>>(AsyncUpdateAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>> PrepareAsyncUpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>>(PrepareAsyncUpdateAioVolumeRaw(context, request, cq));
    }
    ::grpc::Status ListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::opi_api::storage::v1::ListAioVolumesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::ListAioVolumesResponse>> AsyncListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::ListAioVolumesResponse>>(AsyncListAioVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::ListAioVolumesResponse>> PrepareAsyncListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::ListAioVolumesResponse>>(PrepareAsyncListAioVolumesRaw(context, request, cq));
    }
    ::grpc::Status GetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::opi_api::storage::v1::AioVolume* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>> AsyncGetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>>(AsyncGetAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>> PrepareAsyncGetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>>(PrepareAsyncGetAioVolumeRaw(context, request, cq));
    }
    ::grpc::Status StatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::opi_api::storage::v1::StatsAioVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::StatsAioVolumeResponse>> AsyncStatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::StatsAioVolumeResponse>>(AsyncStatsAioVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::StatsAioVolumeResponse>> PrepareAsyncStatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::StatsAioVolumeResponse>>(PrepareAsyncStatsAioVolumeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void CreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, std::function<void(::grpc::Status)>) override;
      void CreateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, std::function<void(::grpc::Status)>) override;
      void UpdateAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest* request, ::opi_api::storage::v1::ListAioVolumesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAioVolumes(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest* request, ::opi_api::storage::v1::ListAioVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, std::function<void(::grpc::Status)>) override;
      void GetAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::opi_api::storage::v1::StatsAioVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void StatsAioVolume(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::opi_api::storage::v1::StatsAioVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>* AsyncCreateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>* PrepareAsyncCreateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>* AsyncUpdateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>* PrepareAsyncUpdateAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::ListAioVolumesResponse>* AsyncListAioVolumesRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::ListAioVolumesResponse>* PrepareAsyncListAioVolumesRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>* AsyncGetAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::AioVolume>* PrepareAsyncGetAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::StatsAioVolumeResponse>* AsyncStatsAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::opi_api::storage::v1::StatsAioVolumeResponse>* PrepareAsyncStatsAioVolumeRaw(::grpc::ClientContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateAioVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAioVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateAioVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAioVolumes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAioVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_StatsAioVolume_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create an Aio Volume
    virtual ::grpc::Status CreateAioVolume(::grpc::ServerContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response);
    // Delete an Aio Volume
    virtual ::grpc::Status DeleteAioVolume(::grpc::ServerContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::google::protobuf::Empty* response);
    // Update an Aio Volume
    virtual ::grpc::Status UpdateAioVolume(::grpc::ServerContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response);
    // List Aio Volumes
    virtual ::grpc::Status ListAioVolumes(::grpc::ServerContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest* request, ::opi_api::storage::v1::ListAioVolumesResponse* response);
    // Get an Aio Volume
    virtual ::grpc::Status GetAioVolume(::grpc::ServerContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response);
    // Get an Aio Volume statistics
    virtual ::grpc::Status StatsAioVolume(::grpc::ServerContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::opi_api::storage::v1::StatsAioVolumeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateAioVolume() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAioVolume(::grpc::ServerContext* context, ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::opi_api::storage::v1::AioVolume>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAioVolume() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeleteAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAioVolume(::grpc::ServerContext* context, ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateAioVolume() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_UpdateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAioVolume(::grpc::ServerContext* context, ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::opi_api::storage::v1::AioVolume>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAioVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAioVolumes() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ListAioVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAioVolumes(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAioVolumes(::grpc::ServerContext* context, ::opi_api::storage::v1::ListAioVolumesRequest* request, ::grpc::ServerAsyncResponseWriter< ::opi_api::storage::v1::ListAioVolumesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAioVolume() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAioVolume(::grpc::ServerContext* context, ::opi_api::storage::v1::GetAioVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::opi_api::storage::v1::AioVolume>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StatsAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StatsAioVolume() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StatsAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatsAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatsAioVolume(::grpc::ServerContext* context, ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::opi_api::storage::v1::StatsAioVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateAioVolume<WithAsyncMethod_DeleteAioVolume<WithAsyncMethod_UpdateAioVolume<WithAsyncMethod_ListAioVolumes<WithAsyncMethod_GetAioVolume<WithAsyncMethod_StatsAioVolume<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CreateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateAioVolume() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::CreateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::opi_api::storage::v1::CreateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response) { return this->CreateAioVolume(context, request, response); }));}
    void SetMessageAllocatorFor_CreateAioVolume(
        ::grpc::MessageAllocator< ::opi_api::storage::v1::CreateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::CreateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteAioVolume() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::DeleteAioVolumeRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::opi_api::storage::v1::DeleteAioVolumeRequest* request, ::google::protobuf::Empty* response) { return this->DeleteAioVolume(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAioVolume(
        ::grpc::MessageAllocator< ::opi_api::storage::v1::DeleteAioVolumeRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::DeleteAioVolumeRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateAioVolume() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::UpdateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::opi_api::storage::v1::UpdateAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response) { return this->UpdateAioVolume(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateAioVolume(
        ::grpc::MessageAllocator< ::opi_api::storage::v1::UpdateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::UpdateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListAioVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListAioVolumes() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::ListAioVolumesRequest, ::opi_api::storage::v1::ListAioVolumesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::opi_api::storage::v1::ListAioVolumesRequest* request, ::opi_api::storage::v1::ListAioVolumesResponse* response) { return this->ListAioVolumes(context, request, response); }));}
    void SetMessageAllocatorFor_ListAioVolumes(
        ::grpc::MessageAllocator< ::opi_api::storage::v1::ListAioVolumesRequest, ::opi_api::storage::v1::ListAioVolumesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::ListAioVolumesRequest, ::opi_api::storage::v1::ListAioVolumesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListAioVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAioVolumes(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAioVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAioVolume() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::GetAioVolumeRequest, ::opi_api::storage::v1::AioVolume>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::opi_api::storage::v1::GetAioVolumeRequest* request, ::opi_api::storage::v1::AioVolume* response) { return this->GetAioVolume(context, request, response); }));}
    void SetMessageAllocatorFor_GetAioVolume(
        ::grpc::MessageAllocator< ::opi_api::storage::v1::GetAioVolumeRequest, ::opi_api::storage::v1::AioVolume>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::GetAioVolumeRequest, ::opi_api::storage::v1::AioVolume>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StatsAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StatsAioVolume() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::StatsAioVolumeRequest, ::opi_api::storage::v1::StatsAioVolumeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::opi_api::storage::v1::StatsAioVolumeRequest* request, ::opi_api::storage::v1::StatsAioVolumeResponse* response) { return this->StatsAioVolume(context, request, response); }));}
    void SetMessageAllocatorFor_StatsAioVolume(
        ::grpc::MessageAllocator< ::opi_api::storage::v1::StatsAioVolumeRequest, ::opi_api::storage::v1::StatsAioVolumeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::opi_api::storage::v1::StatsAioVolumeRequest, ::opi_api::storage::v1::StatsAioVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StatsAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatsAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StatsAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_CreateAioVolume<WithCallbackMethod_DeleteAioVolume<WithCallbackMethod_UpdateAioVolume<WithCallbackMethod_ListAioVolumes<WithCallbackMethod_GetAioVolume<WithCallbackMethod_StatsAioVolume<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateAioVolume() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAioVolume() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeleteAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateAioVolume() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_UpdateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAioVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAioVolumes() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ListAioVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAioVolumes(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAioVolume() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StatsAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StatsAioVolume() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StatsAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatsAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateAioVolume() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAioVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAioVolume() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DeleteAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAioVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateAioVolume() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_UpdateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAioVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAioVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAioVolumes() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ListAioVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAioVolumes(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAioVolumes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAioVolume() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAioVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StatsAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StatsAioVolume() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StatsAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatsAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStatsAioVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateAioVolume() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateAioVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteAioVolume() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAioVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateAioVolume() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateAioVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListAioVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListAioVolumes() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAioVolumes(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListAioVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAioVolumes(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAioVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAioVolume() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAioVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StatsAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StatsAioVolume() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StatsAioVolume(context, request, response); }));
    }
    ~WithRawCallbackMethod_StatsAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StatsAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StatsAioVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateAioVolume() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::opi_api::storage::v1::CreateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::opi_api::storage::v1::CreateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>* streamer) {
                       return this->StreamedCreateAioVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::CreateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateAioVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::opi_api::storage::v1::CreateAioVolumeRequest,::opi_api::storage::v1::AioVolume>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAioVolume() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::opi_api::storage::v1::DeleteAioVolumeRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::opi_api::storage::v1::DeleteAioVolumeRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteAioVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::DeleteAioVolumeRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAioVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::opi_api::storage::v1::DeleteAioVolumeRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateAioVolume() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::opi_api::storage::v1::UpdateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::opi_api::storage::v1::UpdateAioVolumeRequest, ::opi_api::storage::v1::AioVolume>* streamer) {
                       return this->StreamedUpdateAioVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::UpdateAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateAioVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::opi_api::storage::v1::UpdateAioVolumeRequest,::opi_api::storage::v1::AioVolume>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAioVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAioVolumes() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::opi_api::storage::v1::ListAioVolumesRequest, ::opi_api::storage::v1::ListAioVolumesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::opi_api::storage::v1::ListAioVolumesRequest, ::opi_api::storage::v1::ListAioVolumesResponse>* streamer) {
                       return this->StreamedListAioVolumes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListAioVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAioVolumes(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::ListAioVolumesRequest* /*request*/, ::opi_api::storage::v1::ListAioVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAioVolumes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::opi_api::storage::v1::ListAioVolumesRequest,::opi_api::storage::v1::ListAioVolumesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAioVolume() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::opi_api::storage::v1::GetAioVolumeRequest, ::opi_api::storage::v1::AioVolume>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::opi_api::storage::v1::GetAioVolumeRequest, ::opi_api::storage::v1::AioVolume>* streamer) {
                       return this->StreamedGetAioVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::GetAioVolumeRequest* /*request*/, ::opi_api::storage::v1::AioVolume* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAioVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::opi_api::storage::v1::GetAioVolumeRequest,::opi_api::storage::v1::AioVolume>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StatsAioVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StatsAioVolume() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::opi_api::storage::v1::StatsAioVolumeRequest, ::opi_api::storage::v1::StatsAioVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::opi_api::storage::v1::StatsAioVolumeRequest, ::opi_api::storage::v1::StatsAioVolumeResponse>* streamer) {
                       return this->StreamedStatsAioVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StatsAioVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StatsAioVolume(::grpc::ServerContext* /*context*/, const ::opi_api::storage::v1::StatsAioVolumeRequest* /*request*/, ::opi_api::storage::v1::StatsAioVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStatsAioVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::opi_api::storage::v1::StatsAioVolumeRequest,::opi_api::storage::v1::StatsAioVolumeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateAioVolume<WithStreamedUnaryMethod_DeleteAioVolume<WithStreamedUnaryMethod_UpdateAioVolume<WithStreamedUnaryMethod_ListAioVolumes<WithStreamedUnaryMethod_GetAioVolume<WithStreamedUnaryMethod_StatsAioVolume<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateAioVolume<WithStreamedUnaryMethod_DeleteAioVolume<WithStreamedUnaryMethod_UpdateAioVolume<WithStreamedUnaryMethod_ListAioVolumes<WithStreamedUnaryMethod_GetAioVolume<WithStreamedUnaryMethod_StatsAioVolume<Service > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace storage
}  // namespace opi_api


#endif  // GRPC_backend_5faio_2eproto__INCLUDED
