// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backend_nvme_tcp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_backend_5fnvme_5ftcp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_backend_5fnvme_5ftcp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/client.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/field_mask.pb.h>
#include "opicommon.pb.h"
#include "uuid.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_backend_5fnvme_5ftcp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_backend_5fnvme_5ftcp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_backend_5fnvme_5ftcp_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class CreateNvmePathRequest;
struct CreateNvmePathRequestDefaultTypeInternal;
extern CreateNvmePathRequestDefaultTypeInternal _CreateNvmePathRequest_default_instance_;
class CreateNvmeRemoteControllerRequest;
struct CreateNvmeRemoteControllerRequestDefaultTypeInternal;
extern CreateNvmeRemoteControllerRequestDefaultTypeInternal _CreateNvmeRemoteControllerRequest_default_instance_;
class DeleteNvmePathRequest;
struct DeleteNvmePathRequestDefaultTypeInternal;
extern DeleteNvmePathRequestDefaultTypeInternal _DeleteNvmePathRequest_default_instance_;
class DeleteNvmeRemoteControllerRequest;
struct DeleteNvmeRemoteControllerRequestDefaultTypeInternal;
extern DeleteNvmeRemoteControllerRequestDefaultTypeInternal _DeleteNvmeRemoteControllerRequest_default_instance_;
class FabricsPath;
struct FabricsPathDefaultTypeInternal;
extern FabricsPathDefaultTypeInternal _FabricsPath_default_instance_;
class GetNvmePathRequest;
struct GetNvmePathRequestDefaultTypeInternal;
extern GetNvmePathRequestDefaultTypeInternal _GetNvmePathRequest_default_instance_;
class GetNvmeRemoteControllerRequest;
struct GetNvmeRemoteControllerRequestDefaultTypeInternal;
extern GetNvmeRemoteControllerRequestDefaultTypeInternal _GetNvmeRemoteControllerRequest_default_instance_;
class GetNvmeRemoteNamespaceRequest;
struct GetNvmeRemoteNamespaceRequestDefaultTypeInternal;
extern GetNvmeRemoteNamespaceRequestDefaultTypeInternal _GetNvmeRemoteNamespaceRequest_default_instance_;
class ListNvmePathsRequest;
struct ListNvmePathsRequestDefaultTypeInternal;
extern ListNvmePathsRequestDefaultTypeInternal _ListNvmePathsRequest_default_instance_;
class ListNvmePathsResponse;
struct ListNvmePathsResponseDefaultTypeInternal;
extern ListNvmePathsResponseDefaultTypeInternal _ListNvmePathsResponse_default_instance_;
class ListNvmeRemoteControllersRequest;
struct ListNvmeRemoteControllersRequestDefaultTypeInternal;
extern ListNvmeRemoteControllersRequestDefaultTypeInternal _ListNvmeRemoteControllersRequest_default_instance_;
class ListNvmeRemoteControllersResponse;
struct ListNvmeRemoteControllersResponseDefaultTypeInternal;
extern ListNvmeRemoteControllersResponseDefaultTypeInternal _ListNvmeRemoteControllersResponse_default_instance_;
class ListNvmeRemoteNamespacesRequest;
struct ListNvmeRemoteNamespacesRequestDefaultTypeInternal;
extern ListNvmeRemoteNamespacesRequestDefaultTypeInternal _ListNvmeRemoteNamespacesRequest_default_instance_;
class ListNvmeRemoteNamespacesResponse;
struct ListNvmeRemoteNamespacesResponseDefaultTypeInternal;
extern ListNvmeRemoteNamespacesResponseDefaultTypeInternal _ListNvmeRemoteNamespacesResponse_default_instance_;
class NvmePath;
struct NvmePathDefaultTypeInternal;
extern NvmePathDefaultTypeInternal _NvmePath_default_instance_;
class NvmeRemoteController;
struct NvmeRemoteControllerDefaultTypeInternal;
extern NvmeRemoteControllerDefaultTypeInternal _NvmeRemoteController_default_instance_;
class NvmeRemoteNamespace;
struct NvmeRemoteNamespaceDefaultTypeInternal;
extern NvmeRemoteNamespaceDefaultTypeInternal _NvmeRemoteNamespace_default_instance_;
class ResetNvmeRemoteControllerRequest;
struct ResetNvmeRemoteControllerRequestDefaultTypeInternal;
extern ResetNvmeRemoteControllerRequestDefaultTypeInternal _ResetNvmeRemoteControllerRequest_default_instance_;
class StatsNvmePathRequest;
struct StatsNvmePathRequestDefaultTypeInternal;
extern StatsNvmePathRequestDefaultTypeInternal _StatsNvmePathRequest_default_instance_;
class StatsNvmePathResponse;
struct StatsNvmePathResponseDefaultTypeInternal;
extern StatsNvmePathResponseDefaultTypeInternal _StatsNvmePathResponse_default_instance_;
class StatsNvmeRemoteControllerRequest;
struct StatsNvmeRemoteControllerRequestDefaultTypeInternal;
extern StatsNvmeRemoteControllerRequestDefaultTypeInternal _StatsNvmeRemoteControllerRequest_default_instance_;
class StatsNvmeRemoteControllerResponse;
struct StatsNvmeRemoteControllerResponseDefaultTypeInternal;
extern StatsNvmeRemoteControllerResponseDefaultTypeInternal _StatsNvmeRemoteControllerResponse_default_instance_;
class TcpController;
struct TcpControllerDefaultTypeInternal;
extern TcpControllerDefaultTypeInternal _TcpController_default_instance_;
class UpdateNvmePathRequest;
struct UpdateNvmePathRequestDefaultTypeInternal;
extern UpdateNvmePathRequestDefaultTypeInternal _UpdateNvmePathRequest_default_instance_;
class UpdateNvmeRemoteControllerRequest;
struct UpdateNvmeRemoteControllerRequestDefaultTypeInternal;
extern UpdateNvmeRemoteControllerRequestDefaultTypeInternal _UpdateNvmeRemoteControllerRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::CreateNvmePathRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNvmePathRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNvmeRemoteControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNvmePathRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNvmePathRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::FabricsPath* Arena::CreateMaybeMessage<::opi_api::storage::v1::FabricsPath>(Arena*);
template<> ::opi_api::storage::v1::GetNvmePathRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNvmePathRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNvmeRemoteControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNvmeRemoteControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmePathsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmePathsRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmePathsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmePathsResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeRemoteControllersRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeRemoteControllersRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeRemoteControllersResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeRemoteControllersResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse>(Arena*);
template<> ::opi_api::storage::v1::NvmePath* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmePath>(Arena*);
template<> ::opi_api::storage::v1::NvmeRemoteController* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeRemoteController>(Arena*);
template<> ::opi_api::storage::v1::NvmeRemoteNamespace* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeRemoteNamespace>(Arena*);
template<> ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ResetNvmeRemoteControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmePathRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmePathRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmePathResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmePathResponse>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeRemoteControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeRemoteControllerResponse>(Arena*);
template<> ::opi_api::storage::v1::TcpController* Arena::CreateMaybeMessage<::opi_api::storage::v1::TcpController>(Arena*);
template<> ::opi_api::storage::v1::UpdateNvmePathRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNvmePathRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

enum NvmeMultipath : int {
  NVME_MULTIPATH_UNSPECIFIED = 0,
  NVME_MULTIPATH_DISABLE = 1,
  NVME_MULTIPATH_FAILOVER = 2,
  NVME_MULTIPATH_MULTIPATH = 3,
  NvmeMultipath_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NvmeMultipath_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NvmeMultipath_IsValid(int value);
constexpr NvmeMultipath NvmeMultipath_MIN = NVME_MULTIPATH_UNSPECIFIED;
constexpr NvmeMultipath NvmeMultipath_MAX = NVME_MULTIPATH_MULTIPATH;
constexpr int NvmeMultipath_ARRAYSIZE = NvmeMultipath_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeMultipath_descriptor();
template<typename T>
inline const std::string& NvmeMultipath_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NvmeMultipath>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NvmeMultipath_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NvmeMultipath_descriptor(), enum_t_value);
}
inline bool NvmeMultipath_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NvmeMultipath* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NvmeMultipath>(
    NvmeMultipath_descriptor(), name, value);
}
// ===================================================================

class NvmeRemoteController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeRemoteController) */ {
 public:
  inline NvmeRemoteController() : NvmeRemoteController(nullptr) {}
  ~NvmeRemoteController() override;
  explicit PROTOBUF_CONSTEXPR NvmeRemoteController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeRemoteController(const NvmeRemoteController& from);
  NvmeRemoteController(NvmeRemoteController&& from) noexcept
    : NvmeRemoteController() {
    *this = ::std::move(from);
  }

  inline NvmeRemoteController& operator=(const NvmeRemoteController& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeRemoteController& operator=(NvmeRemoteController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeRemoteController& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeRemoteController* internal_default_instance() {
    return reinterpret_cast<const NvmeRemoteController*>(
               &_NvmeRemoteController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NvmeRemoteController& a, NvmeRemoteController& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeRemoteController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeRemoteController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeRemoteController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeRemoteController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeRemoteController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeRemoteController& from) {
    NvmeRemoteController::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeRemoteController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeRemoteController";
  }
  protected:
  explicit NvmeRemoteController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTcpFieldNumber = 5,
    kIoQueuesCountFieldNumber = 3,
    kQueueSizeFieldNumber = 4,
    kMultipathFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
  bool has_tcp() const;
  private:
  bool _internal_has_tcp() const;
  public:
  void clear_tcp();
  const ::opi_api::storage::v1::TcpController& tcp() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::TcpController* release_tcp();
  ::opi_api::storage::v1::TcpController* mutable_tcp();
  void set_allocated_tcp(::opi_api::storage::v1::TcpController* tcp);
  private:
  const ::opi_api::storage::v1::TcpController& _internal_tcp() const;
  ::opi_api::storage::v1::TcpController* _internal_mutable_tcp();
  public:
  void unsafe_arena_set_allocated_tcp(
      ::opi_api::storage::v1::TcpController* tcp);
  ::opi_api::storage::v1::TcpController* unsafe_arena_release_tcp();

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_io_queues_count();
  int64_t io_queues_count() const;
  void set_io_queues_count(int64_t value);
  private:
  int64_t _internal_io_queues_count() const;
  void _internal_set_io_queues_count(int64_t value);
  public:

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  void clear_queue_size();
  int64_t queue_size() const;
  void set_queue_size(int64_t value);
  private:
  int64_t _internal_queue_size() const;
  void _internal_set_queue_size(int64_t value);
  public:

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_multipath();
  ::opi_api::storage::v1::NvmeMultipath multipath() const;
  void set_multipath(::opi_api::storage::v1::NvmeMultipath value);
  private:
  ::opi_api::storage::v1::NvmeMultipath _internal_multipath() const;
  void _internal_set_multipath(::opi_api::storage::v1::NvmeMultipath value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeRemoteController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::storage::v1::TcpController* tcp_;
    int64_t io_queues_count_;
    int64_t queue_size_;
    int multipath_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class TcpController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.TcpController) */ {
 public:
  inline TcpController() : TcpController(nullptr) {}
  ~TcpController() override;
  explicit PROTOBUF_CONSTEXPR TcpController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TcpController(const TcpController& from);
  TcpController(TcpController&& from) noexcept
    : TcpController() {
    *this = ::std::move(from);
  }

  inline TcpController& operator=(const TcpController& from) {
    CopyFrom(from);
    return *this;
  }
  inline TcpController& operator=(TcpController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TcpController& default_instance() {
    return *internal_default_instance();
  }
  static inline const TcpController* internal_default_instance() {
    return reinterpret_cast<const TcpController*>(
               &_TcpController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TcpController& a, TcpController& b) {
    a.Swap(&b);
  }
  inline void Swap(TcpController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TcpController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TcpController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TcpController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TcpController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TcpController& from) {
    TcpController::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TcpController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.TcpController";
  }
  protected:
  explicit TcpController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPskFieldNumber = 3,
    kHdgstFieldNumber = 1,
    kDdgstFieldNumber = 2,
  };
  // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_psk();
  const std::string& psk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_psk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_psk();
  PROTOBUF_NODISCARD std::string* release_psk();
  void set_allocated_psk(std::string* psk);
  private:
  const std::string& _internal_psk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_psk(const std::string& value);
  std::string* _internal_mutable_psk();
  public:

  // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
  void clear_hdgst();
  bool hdgst() const;
  void set_hdgst(bool value);
  private:
  bool _internal_hdgst() const;
  void _internal_set_hdgst(bool value);
  public:

  // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_ddgst();
  bool ddgst() const;
  void set_ddgst(bool value);
  private:
  bool _internal_ddgst() const;
  void _internal_set_ddgst(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.TcpController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr psk_;
    bool hdgst_;
    bool ddgst_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class NvmePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmePath) */ {
 public:
  inline NvmePath() : NvmePath(nullptr) {}
  ~NvmePath() override;
  explicit PROTOBUF_CONSTEXPR NvmePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmePath(const NvmePath& from);
  NvmePath(NvmePath&& from) noexcept
    : NvmePath() {
    *this = ::std::move(from);
  }

  inline NvmePath& operator=(const NvmePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmePath& operator=(NvmePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmePath* internal_default_instance() {
    return reinterpret_cast<const NvmePath*>(
               &_NvmePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NvmePath& a, NvmePath& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmePath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmePath& from) {
    NvmePath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmePath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmePath";
  }
  protected:
  explicit NvmePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kControllerNameRefFieldNumber = 2,
    kTraddrFieldNumber = 4,
    kFabricsFieldNumber = 5,
    kTrtypeFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_controller_name_ref();
  const std::string& controller_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_name_ref();
  PROTOBUF_NODISCARD std::string* release_controller_name_ref();
  void set_allocated_controller_name_ref(std::string* controller_name_ref);
  private:
  const std::string& _internal_controller_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_name_ref(const std::string& value);
  std::string* _internal_mutable_controller_name_ref();
  public:

  // string traddr = 4 [(.google.api.field_behavior) = REQUIRED];
  void clear_traddr();
  const std::string& traddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_traddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_traddr();
  PROTOBUF_NODISCARD std::string* release_traddr();
  void set_allocated_traddr(std::string* traddr);
  private:
  const std::string& _internal_traddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_traddr(const std::string& value);
  std::string* _internal_mutable_traddr();
  public:

  // .opi_api.storage.v1.FabricsPath fabrics = 5 [(.google.api.field_behavior) = OPTIONAL];
  bool has_fabrics() const;
  private:
  bool _internal_has_fabrics() const;
  public:
  void clear_fabrics();
  const ::opi_api::storage::v1::FabricsPath& fabrics() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::FabricsPath* release_fabrics();
  ::opi_api::storage::v1::FabricsPath* mutable_fabrics();
  void set_allocated_fabrics(::opi_api::storage::v1::FabricsPath* fabrics);
  private:
  const ::opi_api::storage::v1::FabricsPath& _internal_fabrics() const;
  ::opi_api::storage::v1::FabricsPath* _internal_mutable_fabrics();
  public:
  void unsafe_arena_set_allocated_fabrics(
      ::opi_api::storage::v1::FabricsPath* fabrics);
  ::opi_api::storage::v1::FabricsPath* unsafe_arena_release_fabrics();

  // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_trtype();
  ::opi_api::storage::v1::NvmeTransportType trtype() const;
  void set_trtype(::opi_api::storage::v1::NvmeTransportType value);
  private:
  ::opi_api::storage::v1::NvmeTransportType _internal_trtype() const;
  void _internal_set_trtype(::opi_api::storage::v1::NvmeTransportType value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr traddr_;
    ::opi_api::storage::v1::FabricsPath* fabrics_;
    int trtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class FabricsPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.FabricsPath) */ {
 public:
  inline FabricsPath() : FabricsPath(nullptr) {}
  ~FabricsPath() override;
  explicit PROTOBUF_CONSTEXPR FabricsPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FabricsPath(const FabricsPath& from);
  FabricsPath(FabricsPath&& from) noexcept
    : FabricsPath() {
    *this = ::std::move(from);
  }

  inline FabricsPath& operator=(const FabricsPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline FabricsPath& operator=(FabricsPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FabricsPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const FabricsPath* internal_default_instance() {
    return reinterpret_cast<const FabricsPath*>(
               &_FabricsPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FabricsPath& a, FabricsPath& b) {
    a.Swap(&b);
  }
  inline void Swap(FabricsPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FabricsPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FabricsPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FabricsPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FabricsPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FabricsPath& from) {
    FabricsPath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FabricsPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.FabricsPath";
  }
  protected:
  explicit FabricsPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubnqnFieldNumber = 2,
    kSourceTraddrFieldNumber = 4,
    kHostnqnFieldNumber = 6,
    kTrsvcidFieldNumber = 1,
    kSourceTrsvcidFieldNumber = 5,
    kAdrfamFieldNumber = 3,
  };
  // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_subnqn();
  const std::string& subnqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subnqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subnqn();
  PROTOBUF_NODISCARD std::string* release_subnqn();
  void set_allocated_subnqn(std::string* subnqn);
  private:
  const std::string& _internal_subnqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subnqn(const std::string& value);
  std::string* _internal_mutable_subnqn();
  public:

  // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
  void clear_source_traddr();
  const std::string& source_traddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_traddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_traddr();
  PROTOBUF_NODISCARD std::string* release_source_traddr();
  void set_allocated_source_traddr(std::string* source_traddr);
  private:
  const std::string& _internal_source_traddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_traddr(const std::string& value);
  std::string* _internal_mutable_source_traddr();
  public:

  // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
  void clear_hostnqn();
  const std::string& hostnqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostnqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostnqn();
  PROTOBUF_NODISCARD std::string* release_hostnqn();
  void set_allocated_hostnqn(std::string* hostnqn);
  private:
  const std::string& _internal_hostnqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostnqn(const std::string& value);
  std::string* _internal_mutable_hostnqn();
  public:

  // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_trsvcid();
  int64_t trsvcid() const;
  void set_trsvcid(int64_t value);
  private:
  int64_t _internal_trsvcid() const;
  void _internal_set_trsvcid(int64_t value);
  public:

  // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_source_trsvcid();
  int64_t source_trsvcid() const;
  void set_source_trsvcid(int64_t value);
  private:
  int64_t _internal_source_trsvcid() const;
  void _internal_set_source_trsvcid(int64_t value);
  public:

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
  void clear_adrfam();
  ::opi_api::storage::v1::NvmeAddressFamily adrfam() const;
  void set_adrfam(::opi_api::storage::v1::NvmeAddressFamily value);
  private:
  ::opi_api::storage::v1::NvmeAddressFamily _internal_adrfam() const;
  void _internal_set_adrfam(::opi_api::storage::v1::NvmeAddressFamily value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.FabricsPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subnqn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_traddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostnqn_;
    int64_t trsvcid_;
    int64_t source_trsvcid_;
    int adrfam_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class NvmeRemoteNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeRemoteNamespace) */ {
 public:
  inline NvmeRemoteNamespace() : NvmeRemoteNamespace(nullptr) {}
  ~NvmeRemoteNamespace() override;
  explicit PROTOBUF_CONSTEXPR NvmeRemoteNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeRemoteNamespace(const NvmeRemoteNamespace& from);
  NvmeRemoteNamespace(NvmeRemoteNamespace&& from) noexcept
    : NvmeRemoteNamespace() {
    *this = ::std::move(from);
  }

  inline NvmeRemoteNamespace& operator=(const NvmeRemoteNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeRemoteNamespace& operator=(NvmeRemoteNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeRemoteNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeRemoteNamespace* internal_default_instance() {
    return reinterpret_cast<const NvmeRemoteNamespace*>(
               &_NvmeRemoteNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NvmeRemoteNamespace& a, NvmeRemoteNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeRemoteNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeRemoteNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeRemoteNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeRemoteNamespace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeRemoteNamespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeRemoteNamespace& from) {
    NvmeRemoteNamespace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeRemoteNamespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeRemoteNamespace";
  }
  protected:
  explicit NvmeRemoteNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kControllerNameRefFieldNumber = 2,
    kNguidFieldNumber = 4,
    kUuidFieldNumber = 6,
    kEui64FieldNumber = 5,
    kNsidFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  void clear_controller_name_ref();
  const std::string& controller_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_name_ref();
  PROTOBUF_NODISCARD std::string* release_controller_name_ref();
  void set_allocated_controller_name_ref(std::string* controller_name_ref);
  private:
  const std::string& _internal_controller_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_name_ref(const std::string& value);
  std::string* _internal_mutable_controller_name_ref();
  public:

  // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_nguid();
  const std::string& nguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nguid();
  PROTOBUF_NODISCARD std::string* release_nguid();
  void set_allocated_nguid(std::string* nguid);
  private:
  const std::string& _internal_nguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nguid(const std::string& value);
  std::string* _internal_mutable_nguid();
  public:

  // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::opi_api::common::v1::Uuid& uuid() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::Uuid* release_uuid();
  ::opi_api::common::v1::Uuid* mutable_uuid();
  void set_allocated_uuid(::opi_api::common::v1::Uuid* uuid);
  private:
  const ::opi_api::common::v1::Uuid& _internal_uuid() const;
  ::opi_api::common::v1::Uuid* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::opi_api::common::v1::Uuid* uuid);
  ::opi_api::common::v1::Uuid* unsafe_arena_release_uuid();

  // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_eui64();
  int64_t eui64() const;
  void set_eui64(int64_t value);
  private:
  int64_t _internal_eui64() const;
  void _internal_set_eui64(int64_t value);
  public:

  // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_nsid();
  int32_t nsid() const;
  void set_nsid(int32_t value);
  private:
  int32_t _internal_nsid() const;
  void _internal_set_nsid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeRemoteNamespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_name_ref_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nguid_;
    ::opi_api::common::v1::Uuid* uuid_;
    int64_t eui64_;
    int32_t nsid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class CreateNvmeRemoteControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNvmeRemoteControllerRequest) */ {
 public:
  inline CreateNvmeRemoteControllerRequest() : CreateNvmeRemoteControllerRequest(nullptr) {}
  ~CreateNvmeRemoteControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNvmeRemoteControllerRequest(const CreateNvmeRemoteControllerRequest& from);
  CreateNvmeRemoteControllerRequest(CreateNvmeRemoteControllerRequest&& from) noexcept
    : CreateNvmeRemoteControllerRequest() {
    *this = ::std::move(from);
  }

  inline CreateNvmeRemoteControllerRequest& operator=(const CreateNvmeRemoteControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNvmeRemoteControllerRequest& operator=(CreateNvmeRemoteControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNvmeRemoteControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNvmeRemoteControllerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNvmeRemoteControllerRequest*>(
               &_CreateNvmeRemoteControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateNvmeRemoteControllerRequest& a, CreateNvmeRemoteControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNvmeRemoteControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNvmeRemoteControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNvmeRemoteControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNvmeRemoteControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNvmeRemoteControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNvmeRemoteControllerRequest& from) {
    CreateNvmeRemoteControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNvmeRemoteControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNvmeRemoteControllerRequest";
  }
  protected:
  explicit CreateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeRemoteControllerIdFieldNumber = 2,
    kNvmeRemoteControllerFieldNumber = 1,
  };
  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_nvme_remote_controller_id();
  const std::string& nvme_remote_controller_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nvme_remote_controller_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nvme_remote_controller_id();
  PROTOBUF_NODISCARD std::string* release_nvme_remote_controller_id();
  void set_allocated_nvme_remote_controller_id(std::string* nvme_remote_controller_id);
  private:
  const std::string& _internal_nvme_remote_controller_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nvme_remote_controller_id(const std::string& value);
  std::string* _internal_mutable_nvme_remote_controller_id();
  public:

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_remote_controller() const;
  private:
  bool _internal_has_nvme_remote_controller() const;
  public:
  void clear_nvme_remote_controller();
  const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeRemoteController* release_nvme_remote_controller();
  ::opi_api::storage::v1::NvmeRemoteController* mutable_nvme_remote_controller();
  void set_allocated_nvme_remote_controller(::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller);
  private:
  const ::opi_api::storage::v1::NvmeRemoteController& _internal_nvme_remote_controller() const;
  ::opi_api::storage::v1::NvmeRemoteController* _internal_mutable_nvme_remote_controller();
  public:
  void unsafe_arena_set_allocated_nvme_remote_controller(
      ::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller);
  ::opi_api::storage::v1::NvmeRemoteController* unsafe_arena_release_nvme_remote_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nvme_remote_controller_id_;
    ::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class DeleteNvmeRemoteControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest) */ {
 public:
  inline DeleteNvmeRemoteControllerRequest() : DeleteNvmeRemoteControllerRequest(nullptr) {}
  ~DeleteNvmeRemoteControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNvmeRemoteControllerRequest(const DeleteNvmeRemoteControllerRequest& from);
  DeleteNvmeRemoteControllerRequest(DeleteNvmeRemoteControllerRequest&& from) noexcept
    : DeleteNvmeRemoteControllerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNvmeRemoteControllerRequest& operator=(const DeleteNvmeRemoteControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNvmeRemoteControllerRequest& operator=(DeleteNvmeRemoteControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNvmeRemoteControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNvmeRemoteControllerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNvmeRemoteControllerRequest*>(
               &_DeleteNvmeRemoteControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteNvmeRemoteControllerRequest& a, DeleteNvmeRemoteControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNvmeRemoteControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNvmeRemoteControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNvmeRemoteControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNvmeRemoteControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNvmeRemoteControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteNvmeRemoteControllerRequest& from) {
    DeleteNvmeRemoteControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNvmeRemoteControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest";
  }
  protected:
  explicit DeleteNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class UpdateNvmeRemoteControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest) */ {
 public:
  inline UpdateNvmeRemoteControllerRequest() : UpdateNvmeRemoteControllerRequest(nullptr) {}
  ~UpdateNvmeRemoteControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNvmeRemoteControllerRequest(const UpdateNvmeRemoteControllerRequest& from);
  UpdateNvmeRemoteControllerRequest(UpdateNvmeRemoteControllerRequest&& from) noexcept
    : UpdateNvmeRemoteControllerRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNvmeRemoteControllerRequest& operator=(const UpdateNvmeRemoteControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNvmeRemoteControllerRequest& operator=(UpdateNvmeRemoteControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNvmeRemoteControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNvmeRemoteControllerRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNvmeRemoteControllerRequest*>(
               &_UpdateNvmeRemoteControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateNvmeRemoteControllerRequest& a, UpdateNvmeRemoteControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNvmeRemoteControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNvmeRemoteControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNvmeRemoteControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNvmeRemoteControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNvmeRemoteControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateNvmeRemoteControllerRequest& from) {
    UpdateNvmeRemoteControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNvmeRemoteControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNvmeRemoteControllerRequest";
  }
  protected:
  explicit UpdateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeRemoteControllerFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_remote_controller() const;
  private:
  bool _internal_has_nvme_remote_controller() const;
  public:
  void clear_nvme_remote_controller();
  const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeRemoteController* release_nvme_remote_controller();
  ::opi_api::storage::v1::NvmeRemoteController* mutable_nvme_remote_controller();
  void set_allocated_nvme_remote_controller(::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller);
  private:
  const ::opi_api::storage::v1::NvmeRemoteController& _internal_nvme_remote_controller() const;
  ::opi_api::storage::v1::NvmeRemoteController* _internal_mutable_nvme_remote_controller();
  public:
  void unsafe_arena_set_allocated_nvme_remote_controller(
      ::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller);
  ::opi_api::storage::v1::NvmeRemoteController* unsafe_arena_release_nvme_remote_controller();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeRemoteControllersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeRemoteControllersRequest) */ {
 public:
  inline ListNvmeRemoteControllersRequest() : ListNvmeRemoteControllersRequest(nullptr) {}
  ~ListNvmeRemoteControllersRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeRemoteControllersRequest(const ListNvmeRemoteControllersRequest& from);
  ListNvmeRemoteControllersRequest(ListNvmeRemoteControllersRequest&& from) noexcept
    : ListNvmeRemoteControllersRequest() {
    *this = ::std::move(from);
  }

  inline ListNvmeRemoteControllersRequest& operator=(const ListNvmeRemoteControllersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeRemoteControllersRequest& operator=(ListNvmeRemoteControllersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeRemoteControllersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeRemoteControllersRequest* internal_default_instance() {
    return reinterpret_cast<const ListNvmeRemoteControllersRequest*>(
               &_ListNvmeRemoteControllersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListNvmeRemoteControllersRequest& a, ListNvmeRemoteControllersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeRemoteControllersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeRemoteControllersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeRemoteControllersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeRemoteControllersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeRemoteControllersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeRemoteControllersRequest& from) {
    ListNvmeRemoteControllersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeRemoteControllersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeRemoteControllersRequest";
  }
  protected:
  explicit ListNvmeRemoteControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeRemoteControllersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeRemoteControllersResponse) */ {
 public:
  inline ListNvmeRemoteControllersResponse() : ListNvmeRemoteControllersResponse(nullptr) {}
  ~ListNvmeRemoteControllersResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeRemoteControllersResponse(const ListNvmeRemoteControllersResponse& from);
  ListNvmeRemoteControllersResponse(ListNvmeRemoteControllersResponse&& from) noexcept
    : ListNvmeRemoteControllersResponse() {
    *this = ::std::move(from);
  }

  inline ListNvmeRemoteControllersResponse& operator=(const ListNvmeRemoteControllersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeRemoteControllersResponse& operator=(ListNvmeRemoteControllersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeRemoteControllersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeRemoteControllersResponse* internal_default_instance() {
    return reinterpret_cast<const ListNvmeRemoteControllersResponse*>(
               &_ListNvmeRemoteControllersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListNvmeRemoteControllersResponse& a, ListNvmeRemoteControllersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeRemoteControllersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeRemoteControllersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeRemoteControllersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeRemoteControllersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeRemoteControllersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeRemoteControllersResponse& from) {
    ListNvmeRemoteControllersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeRemoteControllersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeRemoteControllersResponse";
  }
  protected:
  explicit ListNvmeRemoteControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeRemoteControllersFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  int nvme_remote_controllers_size() const;
  private:
  int _internal_nvme_remote_controllers_size() const;
  public:
  void clear_nvme_remote_controllers();
  ::opi_api::storage::v1::NvmeRemoteController* mutable_nvme_remote_controllers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteController >*
      mutable_nvme_remote_controllers();
  private:
  const ::opi_api::storage::v1::NvmeRemoteController& _internal_nvme_remote_controllers(int index) const;
  ::opi_api::storage::v1::NvmeRemoteController* _internal_add_nvme_remote_controllers();
  public:
  const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controllers(int index) const;
  ::opi_api::storage::v1::NvmeRemoteController* add_nvme_remote_controllers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteController >&
      nvme_remote_controllers() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteController > nvme_remote_controllers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class GetNvmeRemoteControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNvmeRemoteControllerRequest) */ {
 public:
  inline GetNvmeRemoteControllerRequest() : GetNvmeRemoteControllerRequest(nullptr) {}
  ~GetNvmeRemoteControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNvmeRemoteControllerRequest(const GetNvmeRemoteControllerRequest& from);
  GetNvmeRemoteControllerRequest(GetNvmeRemoteControllerRequest&& from) noexcept
    : GetNvmeRemoteControllerRequest() {
    *this = ::std::move(from);
  }

  inline GetNvmeRemoteControllerRequest& operator=(const GetNvmeRemoteControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNvmeRemoteControllerRequest& operator=(GetNvmeRemoteControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNvmeRemoteControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNvmeRemoteControllerRequest* internal_default_instance() {
    return reinterpret_cast<const GetNvmeRemoteControllerRequest*>(
               &_GetNvmeRemoteControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetNvmeRemoteControllerRequest& a, GetNvmeRemoteControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNvmeRemoteControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNvmeRemoteControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNvmeRemoteControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNvmeRemoteControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNvmeRemoteControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNvmeRemoteControllerRequest& from) {
    GetNvmeRemoteControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNvmeRemoteControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNvmeRemoteControllerRequest";
  }
  protected:
  explicit GetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ResetNvmeRemoteControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ResetNvmeRemoteControllerRequest) */ {
 public:
  inline ResetNvmeRemoteControllerRequest() : ResetNvmeRemoteControllerRequest(nullptr) {}
  ~ResetNvmeRemoteControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetNvmeRemoteControllerRequest(const ResetNvmeRemoteControllerRequest& from);
  ResetNvmeRemoteControllerRequest(ResetNvmeRemoteControllerRequest&& from) noexcept
    : ResetNvmeRemoteControllerRequest() {
    *this = ::std::move(from);
  }

  inline ResetNvmeRemoteControllerRequest& operator=(const ResetNvmeRemoteControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetNvmeRemoteControllerRequest& operator=(ResetNvmeRemoteControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetNvmeRemoteControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetNvmeRemoteControllerRequest* internal_default_instance() {
    return reinterpret_cast<const ResetNvmeRemoteControllerRequest*>(
               &_ResetNvmeRemoteControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ResetNvmeRemoteControllerRequest& a, ResetNvmeRemoteControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetNvmeRemoteControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetNvmeRemoteControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetNvmeRemoteControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetNvmeRemoteControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetNvmeRemoteControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetNvmeRemoteControllerRequest& from) {
    ResetNvmeRemoteControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetNvmeRemoteControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ResetNvmeRemoteControllerRequest";
  }
  protected:
  explicit ResetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeRemoteControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeRemoteControllerRequest) */ {
 public:
  inline StatsNvmeRemoteControllerRequest() : StatsNvmeRemoteControllerRequest(nullptr) {}
  ~StatsNvmeRemoteControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeRemoteControllerRequest(const StatsNvmeRemoteControllerRequest& from);
  StatsNvmeRemoteControllerRequest(StatsNvmeRemoteControllerRequest&& from) noexcept
    : StatsNvmeRemoteControllerRequest() {
    *this = ::std::move(from);
  }

  inline StatsNvmeRemoteControllerRequest& operator=(const StatsNvmeRemoteControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeRemoteControllerRequest& operator=(StatsNvmeRemoteControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeRemoteControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeRemoteControllerRequest* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeRemoteControllerRequest*>(
               &_StatsNvmeRemoteControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StatsNvmeRemoteControllerRequest& a, StatsNvmeRemoteControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeRemoteControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeRemoteControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeRemoteControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeRemoteControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeRemoteControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeRemoteControllerRequest& from) {
    StatsNvmeRemoteControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeRemoteControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeRemoteControllerRequest";
  }
  protected:
  explicit StatsNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeRemoteControllerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeRemoteControllerResponse) */ {
 public:
  inline StatsNvmeRemoteControllerResponse() : StatsNvmeRemoteControllerResponse(nullptr) {}
  ~StatsNvmeRemoteControllerResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeRemoteControllerResponse(const StatsNvmeRemoteControllerResponse& from);
  StatsNvmeRemoteControllerResponse(StatsNvmeRemoteControllerResponse&& from) noexcept
    : StatsNvmeRemoteControllerResponse() {
    *this = ::std::move(from);
  }

  inline StatsNvmeRemoteControllerResponse& operator=(const StatsNvmeRemoteControllerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeRemoteControllerResponse& operator=(StatsNvmeRemoteControllerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeRemoteControllerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeRemoteControllerResponse* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeRemoteControllerResponse*>(
               &_StatsNvmeRemoteControllerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StatsNvmeRemoteControllerResponse& a, StatsNvmeRemoteControllerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeRemoteControllerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeRemoteControllerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeRemoteControllerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeRemoteControllerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeRemoteControllerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeRemoteControllerResponse& from) {
    StatsNvmeRemoteControllerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeRemoteControllerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeRemoteControllerResponse";
  }
  protected:
  explicit StatsNvmeRemoteControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::VolumeStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeRemoteNamespacesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest) */ {
 public:
  inline ListNvmeRemoteNamespacesRequest() : ListNvmeRemoteNamespacesRequest(nullptr) {}
  ~ListNvmeRemoteNamespacesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeRemoteNamespacesRequest(const ListNvmeRemoteNamespacesRequest& from);
  ListNvmeRemoteNamespacesRequest(ListNvmeRemoteNamespacesRequest&& from) noexcept
    : ListNvmeRemoteNamespacesRequest() {
    *this = ::std::move(from);
  }

  inline ListNvmeRemoteNamespacesRequest& operator=(const ListNvmeRemoteNamespacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeRemoteNamespacesRequest& operator=(ListNvmeRemoteNamespacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeRemoteNamespacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeRemoteNamespacesRequest* internal_default_instance() {
    return reinterpret_cast<const ListNvmeRemoteNamespacesRequest*>(
               &_ListNvmeRemoteNamespacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListNvmeRemoteNamespacesRequest& a, ListNvmeRemoteNamespacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeRemoteNamespacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeRemoteNamespacesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeRemoteNamespacesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeRemoteNamespacesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeRemoteNamespacesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeRemoteNamespacesRequest& from) {
    ListNvmeRemoteNamespacesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeRemoteNamespacesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest";
  }
  protected:
  explicit ListNvmeRemoteNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeRemoteNamespacesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse) */ {
 public:
  inline ListNvmeRemoteNamespacesResponse() : ListNvmeRemoteNamespacesResponse(nullptr) {}
  ~ListNvmeRemoteNamespacesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeRemoteNamespacesResponse(const ListNvmeRemoteNamespacesResponse& from);
  ListNvmeRemoteNamespacesResponse(ListNvmeRemoteNamespacesResponse&& from) noexcept
    : ListNvmeRemoteNamespacesResponse() {
    *this = ::std::move(from);
  }

  inline ListNvmeRemoteNamespacesResponse& operator=(const ListNvmeRemoteNamespacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeRemoteNamespacesResponse& operator=(ListNvmeRemoteNamespacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeRemoteNamespacesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeRemoteNamespacesResponse* internal_default_instance() {
    return reinterpret_cast<const ListNvmeRemoteNamespacesResponse*>(
               &_ListNvmeRemoteNamespacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListNvmeRemoteNamespacesResponse& a, ListNvmeRemoteNamespacesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeRemoteNamespacesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeRemoteNamespacesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeRemoteNamespacesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeRemoteNamespacesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeRemoteNamespacesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeRemoteNamespacesResponse& from) {
    ListNvmeRemoteNamespacesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeRemoteNamespacesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse";
  }
  protected:
  explicit ListNvmeRemoteNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeRemoteNamespacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  int nvme_remote_namespaces_size() const;
  private:
  int _internal_nvme_remote_namespaces_size() const;
  public:
  void clear_nvme_remote_namespaces();
  ::opi_api::storage::v1::NvmeRemoteNamespace* mutable_nvme_remote_namespaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteNamespace >*
      mutable_nvme_remote_namespaces();
  private:
  const ::opi_api::storage::v1::NvmeRemoteNamespace& _internal_nvme_remote_namespaces(int index) const;
  ::opi_api::storage::v1::NvmeRemoteNamespace* _internal_add_nvme_remote_namespaces();
  public:
  const ::opi_api::storage::v1::NvmeRemoteNamespace& nvme_remote_namespaces(int index) const;
  ::opi_api::storage::v1::NvmeRemoteNamespace* add_nvme_remote_namespaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteNamespace >&
      nvme_remote_namespaces() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteNamespace > nvme_remote_namespaces_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class GetNvmeRemoteNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest) */ {
 public:
  inline GetNvmeRemoteNamespaceRequest() : GetNvmeRemoteNamespaceRequest(nullptr) {}
  ~GetNvmeRemoteNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNvmeRemoteNamespaceRequest(const GetNvmeRemoteNamespaceRequest& from);
  GetNvmeRemoteNamespaceRequest(GetNvmeRemoteNamespaceRequest&& from) noexcept
    : GetNvmeRemoteNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline GetNvmeRemoteNamespaceRequest& operator=(const GetNvmeRemoteNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNvmeRemoteNamespaceRequest& operator=(GetNvmeRemoteNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNvmeRemoteNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNvmeRemoteNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetNvmeRemoteNamespaceRequest*>(
               &_GetNvmeRemoteNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetNvmeRemoteNamespaceRequest& a, GetNvmeRemoteNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNvmeRemoteNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNvmeRemoteNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNvmeRemoteNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNvmeRemoteNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNvmeRemoteNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNvmeRemoteNamespaceRequest& from) {
    GetNvmeRemoteNamespaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNvmeRemoteNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest";
  }
  protected:
  explicit GetNvmeRemoteNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class CreateNvmePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNvmePathRequest) */ {
 public:
  inline CreateNvmePathRequest() : CreateNvmePathRequest(nullptr) {}
  ~CreateNvmePathRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNvmePathRequest(const CreateNvmePathRequest& from);
  CreateNvmePathRequest(CreateNvmePathRequest&& from) noexcept
    : CreateNvmePathRequest() {
    *this = ::std::move(from);
  }

  inline CreateNvmePathRequest& operator=(const CreateNvmePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNvmePathRequest& operator=(CreateNvmePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNvmePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNvmePathRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNvmePathRequest*>(
               &_CreateNvmePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateNvmePathRequest& a, CreateNvmePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNvmePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNvmePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNvmePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNvmePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNvmePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNvmePathRequest& from) {
    CreateNvmePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNvmePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNvmePathRequest";
  }
  protected:
  explicit CreateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmePathIdFieldNumber = 2,
    kNvmePathFieldNumber = 1,
  };
  // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_nvme_path_id();
  const std::string& nvme_path_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nvme_path_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nvme_path_id();
  PROTOBUF_NODISCARD std::string* release_nvme_path_id();
  void set_allocated_nvme_path_id(std::string* nvme_path_id);
  private:
  const std::string& _internal_nvme_path_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nvme_path_id(const std::string& value);
  std::string* _internal_mutable_nvme_path_id();
  public:

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_path() const;
  private:
  bool _internal_has_nvme_path() const;
  public:
  void clear_nvme_path();
  const ::opi_api::storage::v1::NvmePath& nvme_path() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmePath* release_nvme_path();
  ::opi_api::storage::v1::NvmePath* mutable_nvme_path();
  void set_allocated_nvme_path(::opi_api::storage::v1::NvmePath* nvme_path);
  private:
  const ::opi_api::storage::v1::NvmePath& _internal_nvme_path() const;
  ::opi_api::storage::v1::NvmePath* _internal_mutable_nvme_path();
  public:
  void unsafe_arena_set_allocated_nvme_path(
      ::opi_api::storage::v1::NvmePath* nvme_path);
  ::opi_api::storage::v1::NvmePath* unsafe_arena_release_nvme_path();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNvmePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nvme_path_id_;
    ::opi_api::storage::v1::NvmePath* nvme_path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class DeleteNvmePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNvmePathRequest) */ {
 public:
  inline DeleteNvmePathRequest() : DeleteNvmePathRequest(nullptr) {}
  ~DeleteNvmePathRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteNvmePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNvmePathRequest(const DeleteNvmePathRequest& from);
  DeleteNvmePathRequest(DeleteNvmePathRequest&& from) noexcept
    : DeleteNvmePathRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNvmePathRequest& operator=(const DeleteNvmePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNvmePathRequest& operator=(DeleteNvmePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNvmePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNvmePathRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNvmePathRequest*>(
               &_DeleteNvmePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteNvmePathRequest& a, DeleteNvmePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNvmePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNvmePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNvmePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNvmePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNvmePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteNvmePathRequest& from) {
    DeleteNvmePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNvmePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNvmePathRequest";
  }
  protected:
  explicit DeleteNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNvmePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class UpdateNvmePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNvmePathRequest) */ {
 public:
  inline UpdateNvmePathRequest() : UpdateNvmePathRequest(nullptr) {}
  ~UpdateNvmePathRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNvmePathRequest(const UpdateNvmePathRequest& from);
  UpdateNvmePathRequest(UpdateNvmePathRequest&& from) noexcept
    : UpdateNvmePathRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNvmePathRequest& operator=(const UpdateNvmePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNvmePathRequest& operator=(UpdateNvmePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNvmePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNvmePathRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNvmePathRequest*>(
               &_UpdateNvmePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateNvmePathRequest& a, UpdateNvmePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNvmePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNvmePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNvmePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNvmePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNvmePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateNvmePathRequest& from) {
    UpdateNvmePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNvmePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNvmePathRequest";
  }
  protected:
  explicit UpdateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmePathFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_path() const;
  private:
  bool _internal_has_nvme_path() const;
  public:
  void clear_nvme_path();
  const ::opi_api::storage::v1::NvmePath& nvme_path() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmePath* release_nvme_path();
  ::opi_api::storage::v1::NvmePath* mutable_nvme_path();
  void set_allocated_nvme_path(::opi_api::storage::v1::NvmePath* nvme_path);
  private:
  const ::opi_api::storage::v1::NvmePath& _internal_nvme_path() const;
  ::opi_api::storage::v1::NvmePath* _internal_mutable_nvme_path();
  public:
  void unsafe_arena_set_allocated_nvme_path(
      ::opi_api::storage::v1::NvmePath* nvme_path);
  ::opi_api::storage::v1::NvmePath* unsafe_arena_release_nvme_path();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNvmePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::NvmePath* nvme_path_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ListNvmePathsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmePathsRequest) */ {
 public:
  inline ListNvmePathsRequest() : ListNvmePathsRequest(nullptr) {}
  ~ListNvmePathsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNvmePathsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmePathsRequest(const ListNvmePathsRequest& from);
  ListNvmePathsRequest(ListNvmePathsRequest&& from) noexcept
    : ListNvmePathsRequest() {
    *this = ::std::move(from);
  }

  inline ListNvmePathsRequest& operator=(const ListNvmePathsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmePathsRequest& operator=(ListNvmePathsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmePathsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmePathsRequest* internal_default_instance() {
    return reinterpret_cast<const ListNvmePathsRequest*>(
               &_ListNvmePathsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListNvmePathsRequest& a, ListNvmePathsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmePathsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmePathsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmePathsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmePathsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmePathsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmePathsRequest& from) {
    ListNvmePathsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmePathsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmePathsRequest";
  }
  protected:
  explicit ListNvmePathsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmePathsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class ListNvmePathsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmePathsResponse) */ {
 public:
  inline ListNvmePathsResponse() : ListNvmePathsResponse(nullptr) {}
  ~ListNvmePathsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNvmePathsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmePathsResponse(const ListNvmePathsResponse& from);
  ListNvmePathsResponse(ListNvmePathsResponse&& from) noexcept
    : ListNvmePathsResponse() {
    *this = ::std::move(from);
  }

  inline ListNvmePathsResponse& operator=(const ListNvmePathsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmePathsResponse& operator=(ListNvmePathsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmePathsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmePathsResponse* internal_default_instance() {
    return reinterpret_cast<const ListNvmePathsResponse*>(
               &_ListNvmePathsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListNvmePathsResponse& a, ListNvmePathsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmePathsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmePathsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmePathsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmePathsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmePathsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmePathsResponse& from) {
    ListNvmePathsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmePathsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmePathsResponse";
  }
  protected:
  explicit ListNvmePathsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmePathsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  int nvme_paths_size() const;
  private:
  int _internal_nvme_paths_size() const;
  public:
  void clear_nvme_paths();
  ::opi_api::storage::v1::NvmePath* mutable_nvme_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmePath >*
      mutable_nvme_paths();
  private:
  const ::opi_api::storage::v1::NvmePath& _internal_nvme_paths(int index) const;
  ::opi_api::storage::v1::NvmePath* _internal_add_nvme_paths();
  public:
  const ::opi_api::storage::v1::NvmePath& nvme_paths(int index) const;
  ::opi_api::storage::v1::NvmePath* add_nvme_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmePath >&
      nvme_paths() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmePathsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmePath > nvme_paths_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class GetNvmePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNvmePathRequest) */ {
 public:
  inline GetNvmePathRequest() : GetNvmePathRequest(nullptr) {}
  ~GetNvmePathRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNvmePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNvmePathRequest(const GetNvmePathRequest& from);
  GetNvmePathRequest(GetNvmePathRequest&& from) noexcept
    : GetNvmePathRequest() {
    *this = ::std::move(from);
  }

  inline GetNvmePathRequest& operator=(const GetNvmePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNvmePathRequest& operator=(GetNvmePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNvmePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNvmePathRequest* internal_default_instance() {
    return reinterpret_cast<const GetNvmePathRequest*>(
               &_GetNvmePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetNvmePathRequest& a, GetNvmePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNvmePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNvmePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNvmePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNvmePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNvmePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNvmePathRequest& from) {
    GetNvmePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNvmePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNvmePathRequest";
  }
  protected:
  explicit GetNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNvmePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmePathRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmePathRequest) */ {
 public:
  inline StatsNvmePathRequest() : StatsNvmePathRequest(nullptr) {}
  ~StatsNvmePathRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmePathRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmePathRequest(const StatsNvmePathRequest& from);
  StatsNvmePathRequest(StatsNvmePathRequest&& from) noexcept
    : StatsNvmePathRequest() {
    *this = ::std::move(from);
  }

  inline StatsNvmePathRequest& operator=(const StatsNvmePathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmePathRequest& operator=(StatsNvmePathRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmePathRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmePathRequest* internal_default_instance() {
    return reinterpret_cast<const StatsNvmePathRequest*>(
               &_StatsNvmePathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StatsNvmePathRequest& a, StatsNvmePathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmePathRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmePathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmePathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmePathRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmePathRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmePathRequest& from) {
    StatsNvmePathRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmePathRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmePathRequest";
  }
  protected:
  explicit StatsNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmePathRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmePathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmePathResponse) */ {
 public:
  inline StatsNvmePathResponse() : StatsNvmePathResponse(nullptr) {}
  ~StatsNvmePathResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmePathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmePathResponse(const StatsNvmePathResponse& from);
  StatsNvmePathResponse(StatsNvmePathResponse&& from) noexcept
    : StatsNvmePathResponse() {
    *this = ::std::move(from);
  }

  inline StatsNvmePathResponse& operator=(const StatsNvmePathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmePathResponse& operator=(StatsNvmePathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmePathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmePathResponse* internal_default_instance() {
    return reinterpret_cast<const StatsNvmePathResponse*>(
               &_StatsNvmePathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StatsNvmePathResponse& a, StatsNvmePathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmePathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmePathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmePathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmePathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmePathResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmePathResponse& from) {
    StatsNvmePathResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmePathResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmePathResponse";
  }
  protected:
  explicit StatsNvmePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmePathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::VolumeStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backend_5fnvme_5ftcp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NvmeRemoteController

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void NvmeRemoteController::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NvmeRemoteController::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteController.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeRemoteController::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteController.name)
}
inline std::string* NvmeRemoteController::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeRemoteController.name)
  return _s;
}
inline const std::string& NvmeRemoteController::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NvmeRemoteController::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeRemoteController::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeRemoteController::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeRemoteController.name)
  return _impl_.name_.Release();
}
inline void NvmeRemoteController::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeRemoteController.name)
}

// .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
inline void NvmeRemoteController::clear_multipath() {
  _impl_.multipath_ = 0;
}
inline ::opi_api::storage::v1::NvmeMultipath NvmeRemoteController::_internal_multipath() const {
  return static_cast< ::opi_api::storage::v1::NvmeMultipath >(_impl_.multipath_);
}
inline ::opi_api::storage::v1::NvmeMultipath NvmeRemoteController::multipath() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteController.multipath)
  return _internal_multipath();
}
inline void NvmeRemoteController::_internal_set_multipath(::opi_api::storage::v1::NvmeMultipath value) {
  
  _impl_.multipath_ = value;
}
inline void NvmeRemoteController::set_multipath(::opi_api::storage::v1::NvmeMultipath value) {
  _internal_set_multipath(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteController.multipath)
}

// int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeRemoteController::clear_io_queues_count() {
  _impl_.io_queues_count_ = int64_t{0};
}
inline int64_t NvmeRemoteController::_internal_io_queues_count() const {
  return _impl_.io_queues_count_;
}
inline int64_t NvmeRemoteController::io_queues_count() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteController.io_queues_count)
  return _internal_io_queues_count();
}
inline void NvmeRemoteController::_internal_set_io_queues_count(int64_t value) {
  
  _impl_.io_queues_count_ = value;
}
inline void NvmeRemoteController::set_io_queues_count(int64_t value) {
  _internal_set_io_queues_count(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteController.io_queues_count)
}

// int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeRemoteController::clear_queue_size() {
  _impl_.queue_size_ = int64_t{0};
}
inline int64_t NvmeRemoteController::_internal_queue_size() const {
  return _impl_.queue_size_;
}
inline int64_t NvmeRemoteController::queue_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteController.queue_size)
  return _internal_queue_size();
}
inline void NvmeRemoteController::_internal_set_queue_size(int64_t value) {
  
  _impl_.queue_size_ = value;
}
inline void NvmeRemoteController::set_queue_size(int64_t value) {
  _internal_set_queue_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteController.queue_size)
}

// .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeRemoteController::_internal_has_tcp() const {
  return this != internal_default_instance() && _impl_.tcp_ != nullptr;
}
inline bool NvmeRemoteController::has_tcp() const {
  return _internal_has_tcp();
}
inline void NvmeRemoteController::clear_tcp() {
  if (GetArenaForAllocation() == nullptr && _impl_.tcp_ != nullptr) {
    delete _impl_.tcp_;
  }
  _impl_.tcp_ = nullptr;
}
inline const ::opi_api::storage::v1::TcpController& NvmeRemoteController::_internal_tcp() const {
  const ::opi_api::storage::v1::TcpController* p = _impl_.tcp_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::TcpController&>(
      ::opi_api::storage::v1::_TcpController_default_instance_);
}
inline const ::opi_api::storage::v1::TcpController& NvmeRemoteController::tcp() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteController.tcp)
  return _internal_tcp();
}
inline void NvmeRemoteController::unsafe_arena_set_allocated_tcp(
    ::opi_api::storage::v1::TcpController* tcp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tcp_);
  }
  _impl_.tcp_ = tcp;
  if (tcp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeRemoteController.tcp)
}
inline ::opi_api::storage::v1::TcpController* NvmeRemoteController::release_tcp() {
  
  ::opi_api::storage::v1::TcpController* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::TcpController* NvmeRemoteController::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeRemoteController.tcp)
  
  ::opi_api::storage::v1::TcpController* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::TcpController* NvmeRemoteController::_internal_mutable_tcp() {
  
  if (_impl_.tcp_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::TcpController>(GetArenaForAllocation());
    _impl_.tcp_ = p;
  }
  return _impl_.tcp_;
}
inline ::opi_api::storage::v1::TcpController* NvmeRemoteController::mutable_tcp() {
  ::opi_api::storage::v1::TcpController* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeRemoteController.tcp)
  return _msg;
}
inline void NvmeRemoteController::set_allocated_tcp(::opi_api::storage::v1::TcpController* tcp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tcp_;
  }
  if (tcp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tcp);
    if (message_arena != submessage_arena) {
      tcp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeRemoteController.tcp)
}

// -------------------------------------------------------------------

// TcpController

// bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
inline void TcpController::clear_hdgst() {
  _impl_.hdgst_ = false;
}
inline bool TcpController::_internal_hdgst() const {
  return _impl_.hdgst_;
}
inline bool TcpController::hdgst() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.TcpController.hdgst)
  return _internal_hdgst();
}
inline void TcpController::_internal_set_hdgst(bool value) {
  
  _impl_.hdgst_ = value;
}
inline void TcpController::set_hdgst(bool value) {
  _internal_set_hdgst(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.TcpController.hdgst)
}

// bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void TcpController::clear_ddgst() {
  _impl_.ddgst_ = false;
}
inline bool TcpController::_internal_ddgst() const {
  return _impl_.ddgst_;
}
inline bool TcpController::ddgst() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.TcpController.ddgst)
  return _internal_ddgst();
}
inline void TcpController::_internal_set_ddgst(bool value) {
  
  _impl_.ddgst_ = value;
}
inline void TcpController::set_ddgst(bool value) {
  _internal_set_ddgst(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.TcpController.ddgst)
}

// bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void TcpController::clear_psk() {
  _impl_.psk_.ClearToEmpty();
}
inline const std::string& TcpController::psk() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.TcpController.psk)
  return _internal_psk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TcpController::set_psk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.psk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.TcpController.psk)
}
inline std::string* TcpController::mutable_psk() {
  std::string* _s = _internal_mutable_psk();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.TcpController.psk)
  return _s;
}
inline const std::string& TcpController::_internal_psk() const {
  return _impl_.psk_.Get();
}
inline void TcpController::_internal_set_psk(const std::string& value) {
  
  _impl_.psk_.Set(value, GetArenaForAllocation());
}
inline std::string* TcpController::_internal_mutable_psk() {
  
  return _impl_.psk_.Mutable(GetArenaForAllocation());
}
inline std::string* TcpController::release_psk() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.TcpController.psk)
  return _impl_.psk_.Release();
}
inline void TcpController::set_allocated_psk(std::string* psk) {
  if (psk != nullptr) {
    
  } else {
    
  }
  _impl_.psk_.SetAllocated(psk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.psk_.IsDefault()) {
    _impl_.psk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.TcpController.psk)
}

// -------------------------------------------------------------------

// NvmePath

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void NvmePath::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NvmePath::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmePath.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmePath::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmePath.name)
}
inline std::string* NvmePath::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmePath.name)
  return _s;
}
inline const std::string& NvmePath::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NvmePath::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmePath::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmePath::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmePath.name)
  return _impl_.name_.Release();
}
inline void NvmePath::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmePath.name)
}

// string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void NvmePath::clear_controller_name_ref() {
  _impl_.controller_name_ref_.ClearToEmpty();
}
inline const std::string& NvmePath::controller_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmePath.controller_name_ref)
  return _internal_controller_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmePath::set_controller_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.controller_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmePath.controller_name_ref)
}
inline std::string* NvmePath::mutable_controller_name_ref() {
  std::string* _s = _internal_mutable_controller_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmePath.controller_name_ref)
  return _s;
}
inline const std::string& NvmePath::_internal_controller_name_ref() const {
  return _impl_.controller_name_ref_.Get();
}
inline void NvmePath::_internal_set_controller_name_ref(const std::string& value) {
  
  _impl_.controller_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmePath::_internal_mutable_controller_name_ref() {
  
  return _impl_.controller_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmePath::release_controller_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmePath.controller_name_ref)
  return _impl_.controller_name_ref_.Release();
}
inline void NvmePath::set_allocated_controller_name_ref(std::string* controller_name_ref) {
  if (controller_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.controller_name_ref_.SetAllocated(controller_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_name_ref_.IsDefault()) {
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmePath.controller_name_ref)
}

// .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
inline void NvmePath::clear_trtype() {
  _impl_.trtype_ = 0;
}
inline ::opi_api::storage::v1::NvmeTransportType NvmePath::_internal_trtype() const {
  return static_cast< ::opi_api::storage::v1::NvmeTransportType >(_impl_.trtype_);
}
inline ::opi_api::storage::v1::NvmeTransportType NvmePath::trtype() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmePath.trtype)
  return _internal_trtype();
}
inline void NvmePath::_internal_set_trtype(::opi_api::storage::v1::NvmeTransportType value) {
  
  _impl_.trtype_ = value;
}
inline void NvmePath::set_trtype(::opi_api::storage::v1::NvmeTransportType value) {
  _internal_set_trtype(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmePath.trtype)
}

// string traddr = 4 [(.google.api.field_behavior) = REQUIRED];
inline void NvmePath::clear_traddr() {
  _impl_.traddr_.ClearToEmpty();
}
inline const std::string& NvmePath::traddr() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmePath.traddr)
  return _internal_traddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmePath::set_traddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.traddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmePath.traddr)
}
inline std::string* NvmePath::mutable_traddr() {
  std::string* _s = _internal_mutable_traddr();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmePath.traddr)
  return _s;
}
inline const std::string& NvmePath::_internal_traddr() const {
  return _impl_.traddr_.Get();
}
inline void NvmePath::_internal_set_traddr(const std::string& value) {
  
  _impl_.traddr_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmePath::_internal_mutable_traddr() {
  
  return _impl_.traddr_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmePath::release_traddr() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmePath.traddr)
  return _impl_.traddr_.Release();
}
inline void NvmePath::set_allocated_traddr(std::string* traddr) {
  if (traddr != nullptr) {
    
  } else {
    
  }
  _impl_.traddr_.SetAllocated(traddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.traddr_.IsDefault()) {
    _impl_.traddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmePath.traddr)
}

// .opi_api.storage.v1.FabricsPath fabrics = 5 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmePath::_internal_has_fabrics() const {
  return this != internal_default_instance() && _impl_.fabrics_ != nullptr;
}
inline bool NvmePath::has_fabrics() const {
  return _internal_has_fabrics();
}
inline void NvmePath::clear_fabrics() {
  if (GetArenaForAllocation() == nullptr && _impl_.fabrics_ != nullptr) {
    delete _impl_.fabrics_;
  }
  _impl_.fabrics_ = nullptr;
}
inline const ::opi_api::storage::v1::FabricsPath& NvmePath::_internal_fabrics() const {
  const ::opi_api::storage::v1::FabricsPath* p = _impl_.fabrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::FabricsPath&>(
      ::opi_api::storage::v1::_FabricsPath_default_instance_);
}
inline const ::opi_api::storage::v1::FabricsPath& NvmePath::fabrics() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmePath.fabrics)
  return _internal_fabrics();
}
inline void NvmePath::unsafe_arena_set_allocated_fabrics(
    ::opi_api::storage::v1::FabricsPath* fabrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fabrics_);
  }
  _impl_.fabrics_ = fabrics;
  if (fabrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmePath.fabrics)
}
inline ::opi_api::storage::v1::FabricsPath* NvmePath::release_fabrics() {
  
  ::opi_api::storage::v1::FabricsPath* temp = _impl_.fabrics_;
  _impl_.fabrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::FabricsPath* NvmePath::unsafe_arena_release_fabrics() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmePath.fabrics)
  
  ::opi_api::storage::v1::FabricsPath* temp = _impl_.fabrics_;
  _impl_.fabrics_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::FabricsPath* NvmePath::_internal_mutable_fabrics() {
  
  if (_impl_.fabrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::FabricsPath>(GetArenaForAllocation());
    _impl_.fabrics_ = p;
  }
  return _impl_.fabrics_;
}
inline ::opi_api::storage::v1::FabricsPath* NvmePath::mutable_fabrics() {
  ::opi_api::storage::v1::FabricsPath* _msg = _internal_mutable_fabrics();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmePath.fabrics)
  return _msg;
}
inline void NvmePath::set_allocated_fabrics(::opi_api::storage::v1::FabricsPath* fabrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fabrics_;
  }
  if (fabrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fabrics);
    if (message_arena != submessage_arena) {
      fabrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fabrics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fabrics_ = fabrics;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmePath.fabrics)
}

// -------------------------------------------------------------------

// FabricsPath

// int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
inline void FabricsPath::clear_trsvcid() {
  _impl_.trsvcid_ = int64_t{0};
}
inline int64_t FabricsPath::_internal_trsvcid() const {
  return _impl_.trsvcid_;
}
inline int64_t FabricsPath::trsvcid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.FabricsPath.trsvcid)
  return _internal_trsvcid();
}
inline void FabricsPath::_internal_set_trsvcid(int64_t value) {
  
  _impl_.trsvcid_ = value;
}
inline void FabricsPath::set_trsvcid(int64_t value) {
  _internal_set_trsvcid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.FabricsPath.trsvcid)
}

// string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
inline void FabricsPath::clear_subnqn() {
  _impl_.subnqn_.ClearToEmpty();
}
inline const std::string& FabricsPath::subnqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.FabricsPath.subnqn)
  return _internal_subnqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FabricsPath::set_subnqn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.subnqn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.FabricsPath.subnqn)
}
inline std::string* FabricsPath::mutable_subnqn() {
  std::string* _s = _internal_mutable_subnqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.FabricsPath.subnqn)
  return _s;
}
inline const std::string& FabricsPath::_internal_subnqn() const {
  return _impl_.subnqn_.Get();
}
inline void FabricsPath::_internal_set_subnqn(const std::string& value) {
  
  _impl_.subnqn_.Set(value, GetArenaForAllocation());
}
inline std::string* FabricsPath::_internal_mutable_subnqn() {
  
  return _impl_.subnqn_.Mutable(GetArenaForAllocation());
}
inline std::string* FabricsPath::release_subnqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.FabricsPath.subnqn)
  return _impl_.subnqn_.Release();
}
inline void FabricsPath::set_allocated_subnqn(std::string* subnqn) {
  if (subnqn != nullptr) {
    
  } else {
    
  }
  _impl_.subnqn_.SetAllocated(subnqn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subnqn_.IsDefault()) {
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.FabricsPath.subnqn)
}

// .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
inline void FabricsPath::clear_adrfam() {
  _impl_.adrfam_ = 0;
}
inline ::opi_api::storage::v1::NvmeAddressFamily FabricsPath::_internal_adrfam() const {
  return static_cast< ::opi_api::storage::v1::NvmeAddressFamily >(_impl_.adrfam_);
}
inline ::opi_api::storage::v1::NvmeAddressFamily FabricsPath::adrfam() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.FabricsPath.adrfam)
  return _internal_adrfam();
}
inline void FabricsPath::_internal_set_adrfam(::opi_api::storage::v1::NvmeAddressFamily value) {
  
  _impl_.adrfam_ = value;
}
inline void FabricsPath::set_adrfam(::opi_api::storage::v1::NvmeAddressFamily value) {
  _internal_set_adrfam(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.FabricsPath.adrfam)
}

// string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
inline void FabricsPath::clear_source_traddr() {
  _impl_.source_traddr_.ClearToEmpty();
}
inline const std::string& FabricsPath::source_traddr() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.FabricsPath.source_traddr)
  return _internal_source_traddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FabricsPath::set_source_traddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_traddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.FabricsPath.source_traddr)
}
inline std::string* FabricsPath::mutable_source_traddr() {
  std::string* _s = _internal_mutable_source_traddr();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.FabricsPath.source_traddr)
  return _s;
}
inline const std::string& FabricsPath::_internal_source_traddr() const {
  return _impl_.source_traddr_.Get();
}
inline void FabricsPath::_internal_set_source_traddr(const std::string& value) {
  
  _impl_.source_traddr_.Set(value, GetArenaForAllocation());
}
inline std::string* FabricsPath::_internal_mutable_source_traddr() {
  
  return _impl_.source_traddr_.Mutable(GetArenaForAllocation());
}
inline std::string* FabricsPath::release_source_traddr() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.FabricsPath.source_traddr)
  return _impl_.source_traddr_.Release();
}
inline void FabricsPath::set_allocated_source_traddr(std::string* source_traddr) {
  if (source_traddr != nullptr) {
    
  } else {
    
  }
  _impl_.source_traddr_.SetAllocated(source_traddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_traddr_.IsDefault()) {
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.FabricsPath.source_traddr)
}

// int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void FabricsPath::clear_source_trsvcid() {
  _impl_.source_trsvcid_ = int64_t{0};
}
inline int64_t FabricsPath::_internal_source_trsvcid() const {
  return _impl_.source_trsvcid_;
}
inline int64_t FabricsPath::source_trsvcid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.FabricsPath.source_trsvcid)
  return _internal_source_trsvcid();
}
inline void FabricsPath::_internal_set_source_trsvcid(int64_t value) {
  
  _impl_.source_trsvcid_ = value;
}
inline void FabricsPath::set_source_trsvcid(int64_t value) {
  _internal_set_source_trsvcid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.FabricsPath.source_trsvcid)
}

// string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
inline void FabricsPath::clear_hostnqn() {
  _impl_.hostnqn_.ClearToEmpty();
}
inline const std::string& FabricsPath::hostnqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.FabricsPath.hostnqn)
  return _internal_hostnqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FabricsPath::set_hostnqn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostnqn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.FabricsPath.hostnqn)
}
inline std::string* FabricsPath::mutable_hostnqn() {
  std::string* _s = _internal_mutable_hostnqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.FabricsPath.hostnqn)
  return _s;
}
inline const std::string& FabricsPath::_internal_hostnqn() const {
  return _impl_.hostnqn_.Get();
}
inline void FabricsPath::_internal_set_hostnqn(const std::string& value) {
  
  _impl_.hostnqn_.Set(value, GetArenaForAllocation());
}
inline std::string* FabricsPath::_internal_mutable_hostnqn() {
  
  return _impl_.hostnqn_.Mutable(GetArenaForAllocation());
}
inline std::string* FabricsPath::release_hostnqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.FabricsPath.hostnqn)
  return _impl_.hostnqn_.Release();
}
inline void FabricsPath::set_allocated_hostnqn(std::string* hostnqn) {
  if (hostnqn != nullptr) {
    
  } else {
    
  }
  _impl_.hostnqn_.SetAllocated(hostnqn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostnqn_.IsDefault()) {
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.FabricsPath.hostnqn)
}

// -------------------------------------------------------------------

// NvmeRemoteNamespace

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void NvmeRemoteNamespace::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NvmeRemoteNamespace::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteNamespace.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeRemoteNamespace::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteNamespace.name)
}
inline std::string* NvmeRemoteNamespace::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeRemoteNamespace.name)
  return _s;
}
inline const std::string& NvmeRemoteNamespace::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NvmeRemoteNamespace::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeRemoteNamespace::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeRemoteNamespace::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeRemoteNamespace.name)
  return _impl_.name_.Release();
}
inline void NvmeRemoteNamespace::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeRemoteNamespace.name)
}

// string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
inline void NvmeRemoteNamespace::clear_controller_name_ref() {
  _impl_.controller_name_ref_.ClearToEmpty();
}
inline const std::string& NvmeRemoteNamespace::controller_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref)
  return _internal_controller_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeRemoteNamespace::set_controller_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.controller_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref)
}
inline std::string* NvmeRemoteNamespace::mutable_controller_name_ref() {
  std::string* _s = _internal_mutable_controller_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref)
  return _s;
}
inline const std::string& NvmeRemoteNamespace::_internal_controller_name_ref() const {
  return _impl_.controller_name_ref_.Get();
}
inline void NvmeRemoteNamespace::_internal_set_controller_name_ref(const std::string& value) {
  
  _impl_.controller_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeRemoteNamespace::_internal_mutable_controller_name_ref() {
  
  return _impl_.controller_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeRemoteNamespace::release_controller_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref)
  return _impl_.controller_name_ref_.Release();
}
inline void NvmeRemoteNamespace::set_allocated_controller_name_ref(std::string* controller_name_ref) {
  if (controller_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.controller_name_ref_.SetAllocated(controller_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.controller_name_ref_.IsDefault()) {
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref)
}

// int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeRemoteNamespace::clear_nsid() {
  _impl_.nsid_ = 0;
}
inline int32_t NvmeRemoteNamespace::_internal_nsid() const {
  return _impl_.nsid_;
}
inline int32_t NvmeRemoteNamespace::nsid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteNamespace.nsid)
  return _internal_nsid();
}
inline void NvmeRemoteNamespace::_internal_set_nsid(int32_t value) {
  
  _impl_.nsid_ = value;
}
inline void NvmeRemoteNamespace::set_nsid(int32_t value) {
  _internal_set_nsid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteNamespace.nsid)
}

// string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeRemoteNamespace::clear_nguid() {
  _impl_.nguid_.ClearToEmpty();
}
inline const std::string& NvmeRemoteNamespace::nguid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteNamespace.nguid)
  return _internal_nguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeRemoteNamespace::set_nguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteNamespace.nguid)
}
inline std::string* NvmeRemoteNamespace::mutable_nguid() {
  std::string* _s = _internal_mutable_nguid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeRemoteNamespace.nguid)
  return _s;
}
inline const std::string& NvmeRemoteNamespace::_internal_nguid() const {
  return _impl_.nguid_.Get();
}
inline void NvmeRemoteNamespace::_internal_set_nguid(const std::string& value) {
  
  _impl_.nguid_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeRemoteNamespace::_internal_mutable_nguid() {
  
  return _impl_.nguid_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeRemoteNamespace::release_nguid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeRemoteNamespace.nguid)
  return _impl_.nguid_.Release();
}
inline void NvmeRemoteNamespace::set_allocated_nguid(std::string* nguid) {
  if (nguid != nullptr) {
    
  } else {
    
  }
  _impl_.nguid_.SetAllocated(nguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nguid_.IsDefault()) {
    _impl_.nguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeRemoteNamespace.nguid)
}

// int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeRemoteNamespace::clear_eui64() {
  _impl_.eui64_ = int64_t{0};
}
inline int64_t NvmeRemoteNamespace::_internal_eui64() const {
  return _impl_.eui64_;
}
inline int64_t NvmeRemoteNamespace::eui64() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteNamespace.eui64)
  return _internal_eui64();
}
inline void NvmeRemoteNamespace::_internal_set_eui64(int64_t value) {
  
  _impl_.eui64_ = value;
}
inline void NvmeRemoteNamespace::set_eui64(int64_t value) {
  _internal_set_eui64(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeRemoteNamespace.eui64)
}

// .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool NvmeRemoteNamespace::_internal_has_uuid() const {
  return this != internal_default_instance() && _impl_.uuid_ != nullptr;
}
inline bool NvmeRemoteNamespace::has_uuid() const {
  return _internal_has_uuid();
}
inline const ::opi_api::common::v1::Uuid& NvmeRemoteNamespace::_internal_uuid() const {
  const ::opi_api::common::v1::Uuid* p = _impl_.uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::Uuid&>(
      ::opi_api::common::v1::_Uuid_default_instance_);
}
inline const ::opi_api::common::v1::Uuid& NvmeRemoteNamespace::uuid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeRemoteNamespace.uuid)
  return _internal_uuid();
}
inline void NvmeRemoteNamespace::unsafe_arena_set_allocated_uuid(
    ::opi_api::common::v1::Uuid* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uuid_);
  }
  _impl_.uuid_ = uuid;
  if (uuid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeRemoteNamespace.uuid)
}
inline ::opi_api::common::v1::Uuid* NvmeRemoteNamespace::release_uuid() {
  
  ::opi_api::common::v1::Uuid* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::Uuid* NvmeRemoteNamespace::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeRemoteNamespace.uuid)
  
  ::opi_api::common::v1::Uuid* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::Uuid* NvmeRemoteNamespace::_internal_mutable_uuid() {
  
  if (_impl_.uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::Uuid>(GetArenaForAllocation());
    _impl_.uuid_ = p;
  }
  return _impl_.uuid_;
}
inline ::opi_api::common::v1::Uuid* NvmeRemoteNamespace::mutable_uuid() {
  ::opi_api::common::v1::Uuid* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeRemoteNamespace.uuid)
  return _msg;
}
inline void NvmeRemoteNamespace::set_allocated_uuid(::opi_api::common::v1::Uuid* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uuid_);
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid));
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeRemoteNamespace.uuid)
}

// -------------------------------------------------------------------

// CreateNvmeRemoteControllerRequest

// .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNvmeRemoteControllerRequest::_internal_has_nvme_remote_controller() const {
  return this != internal_default_instance() && _impl_.nvme_remote_controller_ != nullptr;
}
inline bool CreateNvmeRemoteControllerRequest::has_nvme_remote_controller() const {
  return _internal_has_nvme_remote_controller();
}
inline void CreateNvmeRemoteControllerRequest::clear_nvme_remote_controller() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeRemoteController& CreateNvmeRemoteControllerRequest::_internal_nvme_remote_controller() const {
  const ::opi_api::storage::v1::NvmeRemoteController* p = _impl_.nvme_remote_controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeRemoteController&>(
      ::opi_api::storage::v1::_NvmeRemoteController_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeRemoteController& CreateNvmeRemoteControllerRequest::nvme_remote_controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller)
  return _internal_nvme_remote_controller();
}
inline void CreateNvmeRemoteControllerRequest::unsafe_arena_set_allocated_nvme_remote_controller(
    ::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_remote_controller_);
  }
  _impl_.nvme_remote_controller_ = nvme_remote_controller;
  if (nvme_remote_controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller)
}
inline ::opi_api::storage::v1::NvmeRemoteController* CreateNvmeRemoteControllerRequest::release_nvme_remote_controller() {
  
  ::opi_api::storage::v1::NvmeRemoteController* temp = _impl_.nvme_remote_controller_;
  _impl_.nvme_remote_controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeRemoteController* CreateNvmeRemoteControllerRequest::unsafe_arena_release_nvme_remote_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller)
  
  ::opi_api::storage::v1::NvmeRemoteController* temp = _impl_.nvme_remote_controller_;
  _impl_.nvme_remote_controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeRemoteController* CreateNvmeRemoteControllerRequest::_internal_mutable_nvme_remote_controller() {
  
  if (_impl_.nvme_remote_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeRemoteController>(GetArenaForAllocation());
    _impl_.nvme_remote_controller_ = p;
  }
  return _impl_.nvme_remote_controller_;
}
inline ::opi_api::storage::v1::NvmeRemoteController* CreateNvmeRemoteControllerRequest::mutable_nvme_remote_controller() {
  ::opi_api::storage::v1::NvmeRemoteController* _msg = _internal_mutable_nvme_remote_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller)
  return _msg;
}
inline void CreateNvmeRemoteControllerRequest::set_allocated_nvme_remote_controller(::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  if (nvme_remote_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_remote_controller);
    if (message_arena != submessage_arena) {
      nvme_remote_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_remote_controller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_remote_controller_ = nvme_remote_controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller)
}

// string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateNvmeRemoteControllerRequest::clear_nvme_remote_controller_id() {
  _impl_.nvme_remote_controller_id_.ClearToEmpty();
}
inline const std::string& CreateNvmeRemoteControllerRequest::nvme_remote_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id)
  return _internal_nvme_remote_controller_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmeRemoteControllerRequest::set_nvme_remote_controller_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nvme_remote_controller_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id)
}
inline std::string* CreateNvmeRemoteControllerRequest::mutable_nvme_remote_controller_id() {
  std::string* _s = _internal_mutable_nvme_remote_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id)
  return _s;
}
inline const std::string& CreateNvmeRemoteControllerRequest::_internal_nvme_remote_controller_id() const {
  return _impl_.nvme_remote_controller_id_.Get();
}
inline void CreateNvmeRemoteControllerRequest::_internal_set_nvme_remote_controller_id(const std::string& value) {
  
  _impl_.nvme_remote_controller_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmeRemoteControllerRequest::_internal_mutable_nvme_remote_controller_id() {
  
  return _impl_.nvme_remote_controller_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmeRemoteControllerRequest::release_nvme_remote_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id)
  return _impl_.nvme_remote_controller_id_.Release();
}
inline void CreateNvmeRemoteControllerRequest::set_allocated_nvme_remote_controller_id(std::string* nvme_remote_controller_id) {
  if (nvme_remote_controller_id != nullptr) {
    
  } else {
    
  }
  _impl_.nvme_remote_controller_id_.SetAllocated(nvme_remote_controller_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nvme_remote_controller_id_.IsDefault()) {
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id)
}

// -------------------------------------------------------------------

// DeleteNvmeRemoteControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNvmeRemoteControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteNvmeRemoteControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNvmeRemoteControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name)
}
inline std::string* DeleteNvmeRemoteControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name)
  return _s;
}
inline const std::string& DeleteNvmeRemoteControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteNvmeRemoteControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteNvmeRemoteControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteNvmeRemoteControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteNvmeRemoteControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name)
}

// bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void DeleteNvmeRemoteControllerRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool DeleteNvmeRemoteControllerRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool DeleteNvmeRemoteControllerRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteNvmeRemoteControllerRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void DeleteNvmeRemoteControllerRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateNvmeRemoteControllerRequest

// .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateNvmeRemoteControllerRequest::_internal_has_nvme_remote_controller() const {
  return this != internal_default_instance() && _impl_.nvme_remote_controller_ != nullptr;
}
inline bool UpdateNvmeRemoteControllerRequest::has_nvme_remote_controller() const {
  return _internal_has_nvme_remote_controller();
}
inline void UpdateNvmeRemoteControllerRequest::clear_nvme_remote_controller() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeRemoteController& UpdateNvmeRemoteControllerRequest::_internal_nvme_remote_controller() const {
  const ::opi_api::storage::v1::NvmeRemoteController* p = _impl_.nvme_remote_controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeRemoteController&>(
      ::opi_api::storage::v1::_NvmeRemoteController_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeRemoteController& UpdateNvmeRemoteControllerRequest::nvme_remote_controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.nvme_remote_controller)
  return _internal_nvme_remote_controller();
}
inline void UpdateNvmeRemoteControllerRequest::unsafe_arena_set_allocated_nvme_remote_controller(
    ::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_remote_controller_);
  }
  _impl_.nvme_remote_controller_ = nvme_remote_controller;
  if (nvme_remote_controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.nvme_remote_controller)
}
inline ::opi_api::storage::v1::NvmeRemoteController* UpdateNvmeRemoteControllerRequest::release_nvme_remote_controller() {
  
  ::opi_api::storage::v1::NvmeRemoteController* temp = _impl_.nvme_remote_controller_;
  _impl_.nvme_remote_controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeRemoteController* UpdateNvmeRemoteControllerRequest::unsafe_arena_release_nvme_remote_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.nvme_remote_controller)
  
  ::opi_api::storage::v1::NvmeRemoteController* temp = _impl_.nvme_remote_controller_;
  _impl_.nvme_remote_controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeRemoteController* UpdateNvmeRemoteControllerRequest::_internal_mutable_nvme_remote_controller() {
  
  if (_impl_.nvme_remote_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeRemoteController>(GetArenaForAllocation());
    _impl_.nvme_remote_controller_ = p;
  }
  return _impl_.nvme_remote_controller_;
}
inline ::opi_api::storage::v1::NvmeRemoteController* UpdateNvmeRemoteControllerRequest::mutable_nvme_remote_controller() {
  ::opi_api::storage::v1::NvmeRemoteController* _msg = _internal_mutable_nvme_remote_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.nvme_remote_controller)
  return _msg;
}
inline void UpdateNvmeRemoteControllerRequest::set_allocated_nvme_remote_controller(::opi_api::storage::v1::NvmeRemoteController* nvme_remote_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  if (nvme_remote_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_remote_controller);
    if (message_arena != submessage_arena) {
      nvme_remote_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_remote_controller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_remote_controller_ = nvme_remote_controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.nvme_remote_controller)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateNvmeRemoteControllerRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateNvmeRemoteControllerRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeRemoteControllerRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeRemoteControllerRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNvmeRemoteControllerRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeRemoteControllerRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeRemoteControllerRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeRemoteControllerRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeRemoteControllerRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.update_mask)
  return _msg;
}
inline void UpdateNvmeRemoteControllerRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.update_mask)
}

// bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateNvmeRemoteControllerRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool UpdateNvmeRemoteControllerRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool UpdateNvmeRemoteControllerRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateNvmeRemoteControllerRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void UpdateNvmeRemoteControllerRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListNvmeRemoteControllersRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNvmeRemoteControllersRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListNvmeRemoteControllersRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeRemoteControllersRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent)
}
inline std::string* ListNvmeRemoteControllersRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent)
  return _s;
}
inline const std::string& ListNvmeRemoteControllersRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListNvmeRemoteControllersRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteControllersRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteControllersRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListNvmeRemoteControllersRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent)
}

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeRemoteControllersRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListNvmeRemoteControllersRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListNvmeRemoteControllersRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_size)
  return _internal_page_size();
}
inline void ListNvmeRemoteControllersRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListNvmeRemoteControllersRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeRemoteControllersRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeRemoteControllersRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeRemoteControllersRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token)
}
inline std::string* ListNvmeRemoteControllersRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token)
  return _s;
}
inline const std::string& ListNvmeRemoteControllersRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListNvmeRemoteControllersRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteControllersRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteControllersRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListNvmeRemoteControllersRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token)
}

// -------------------------------------------------------------------

// ListNvmeRemoteControllersResponse

// repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
inline int ListNvmeRemoteControllersResponse::_internal_nvme_remote_controllers_size() const {
  return _impl_.nvme_remote_controllers_.size();
}
inline int ListNvmeRemoteControllersResponse::nvme_remote_controllers_size() const {
  return _internal_nvme_remote_controllers_size();
}
inline void ListNvmeRemoteControllersResponse::clear_nvme_remote_controllers() {
  _impl_.nvme_remote_controllers_.Clear();
}
inline ::opi_api::storage::v1::NvmeRemoteController* ListNvmeRemoteControllersResponse::mutable_nvme_remote_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteControllersResponse.nvme_remote_controllers)
  return _impl_.nvme_remote_controllers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteController >*
ListNvmeRemoteControllersResponse::mutable_nvme_remote_controllers() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNvmeRemoteControllersResponse.nvme_remote_controllers)
  return &_impl_.nvme_remote_controllers_;
}
inline const ::opi_api::storage::v1::NvmeRemoteController& ListNvmeRemoteControllersResponse::_internal_nvme_remote_controllers(int index) const {
  return _impl_.nvme_remote_controllers_.Get(index);
}
inline const ::opi_api::storage::v1::NvmeRemoteController& ListNvmeRemoteControllersResponse::nvme_remote_controllers(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteControllersResponse.nvme_remote_controllers)
  return _internal_nvme_remote_controllers(index);
}
inline ::opi_api::storage::v1::NvmeRemoteController* ListNvmeRemoteControllersResponse::_internal_add_nvme_remote_controllers() {
  return _impl_.nvme_remote_controllers_.Add();
}
inline ::opi_api::storage::v1::NvmeRemoteController* ListNvmeRemoteControllersResponse::add_nvme_remote_controllers() {
  ::opi_api::storage::v1::NvmeRemoteController* _add = _internal_add_nvme_remote_controllers();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNvmeRemoteControllersResponse.nvme_remote_controllers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteController >&
ListNvmeRemoteControllersResponse::nvme_remote_controllers() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNvmeRemoteControllersResponse.nvme_remote_controllers)
  return _impl_.nvme_remote_controllers_;
}

// string next_page_token = 2;
inline void ListNvmeRemoteControllersResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeRemoteControllersResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeRemoteControllersResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token)
}
inline std::string* ListNvmeRemoteControllersResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token)
  return _s;
}
inline const std::string& ListNvmeRemoteControllersResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListNvmeRemoteControllersResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteControllersResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteControllersResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListNvmeRemoteControllersResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNvmeRemoteControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNvmeRemoteControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNvmeRemoteControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNvmeRemoteControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNvmeRemoteControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNvmeRemoteControllerRequest.name)
}
inline std::string* GetNvmeRemoteControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNvmeRemoteControllerRequest.name)
  return _s;
}
inline const std::string& GetNvmeRemoteControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetNvmeRemoteControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNvmeRemoteControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNvmeRemoteControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNvmeRemoteControllerRequest.name)
  return _impl_.name_.Release();
}
inline void GetNvmeRemoteControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNvmeRemoteControllerRequest.name)
}

// -------------------------------------------------------------------

// ResetNvmeRemoteControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ResetNvmeRemoteControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ResetNvmeRemoteControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResetNvmeRemoteControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name)
}
inline std::string* ResetNvmeRemoteControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name)
  return _s;
}
inline const std::string& ResetNvmeRemoteControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ResetNvmeRemoteControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetNvmeRemoteControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetNvmeRemoteControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name)
  return _impl_.name_.Release();
}
inline void ResetNvmeRemoteControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeRemoteControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsNvmeRemoteControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StatsNvmeRemoteControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsNvmeRemoteControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name)
}
inline std::string* StatsNvmeRemoteControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name)
  return _s;
}
inline const std::string& StatsNvmeRemoteControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatsNvmeRemoteControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatsNvmeRemoteControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatsNvmeRemoteControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name)
  return _impl_.name_.Release();
}
inline void StatsNvmeRemoteControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeRemoteControllerResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsNvmeRemoteControllerResponse::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool StatsNvmeRemoteControllerResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeRemoteControllerResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeRemoteControllerResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeRemoteControllerResponse.stats)
  return _internal_stats();
}
inline void StatsNvmeRemoteControllerResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsNvmeRemoteControllerResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeRemoteControllerResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeRemoteControllerResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeRemoteControllerResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeRemoteControllerResponse::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeRemoteControllerResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeRemoteControllerResponse.stats)
  return _msg;
}
inline void StatsNvmeRemoteControllerResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeRemoteControllerResponse.stats)
}

// -------------------------------------------------------------------

// ListNvmeRemoteNamespacesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNvmeRemoteNamespacesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListNvmeRemoteNamespacesRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeRemoteNamespacesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent)
}
inline std::string* ListNvmeRemoteNamespacesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent)
  return _s;
}
inline const std::string& ListNvmeRemoteNamespacesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListNvmeRemoteNamespacesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteNamespacesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteNamespacesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListNvmeRemoteNamespacesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent)
}

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeRemoteNamespacesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListNvmeRemoteNamespacesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListNvmeRemoteNamespacesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_size)
  return _internal_page_size();
}
inline void ListNvmeRemoteNamespacesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListNvmeRemoteNamespacesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeRemoteNamespacesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeRemoteNamespacesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeRemoteNamespacesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token)
}
inline std::string* ListNvmeRemoteNamespacesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token)
  return _s;
}
inline const std::string& ListNvmeRemoteNamespacesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListNvmeRemoteNamespacesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteNamespacesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteNamespacesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListNvmeRemoteNamespacesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token)
}

// -------------------------------------------------------------------

// ListNvmeRemoteNamespacesResponse

// repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
inline int ListNvmeRemoteNamespacesResponse::_internal_nvme_remote_namespaces_size() const {
  return _impl_.nvme_remote_namespaces_.size();
}
inline int ListNvmeRemoteNamespacesResponse::nvme_remote_namespaces_size() const {
  return _internal_nvme_remote_namespaces_size();
}
inline void ListNvmeRemoteNamespacesResponse::clear_nvme_remote_namespaces() {
  _impl_.nvme_remote_namespaces_.Clear();
}
inline ::opi_api::storage::v1::NvmeRemoteNamespace* ListNvmeRemoteNamespacesResponse::mutable_nvme_remote_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.nvme_remote_namespaces)
  return _impl_.nvme_remote_namespaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteNamespace >*
ListNvmeRemoteNamespacesResponse::mutable_nvme_remote_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.nvme_remote_namespaces)
  return &_impl_.nvme_remote_namespaces_;
}
inline const ::opi_api::storage::v1::NvmeRemoteNamespace& ListNvmeRemoteNamespacesResponse::_internal_nvme_remote_namespaces(int index) const {
  return _impl_.nvme_remote_namespaces_.Get(index);
}
inline const ::opi_api::storage::v1::NvmeRemoteNamespace& ListNvmeRemoteNamespacesResponse::nvme_remote_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.nvme_remote_namespaces)
  return _internal_nvme_remote_namespaces(index);
}
inline ::opi_api::storage::v1::NvmeRemoteNamespace* ListNvmeRemoteNamespacesResponse::_internal_add_nvme_remote_namespaces() {
  return _impl_.nvme_remote_namespaces_.Add();
}
inline ::opi_api::storage::v1::NvmeRemoteNamespace* ListNvmeRemoteNamespacesResponse::add_nvme_remote_namespaces() {
  ::opi_api::storage::v1::NvmeRemoteNamespace* _add = _internal_add_nvme_remote_namespaces();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.nvme_remote_namespaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeRemoteNamespace >&
ListNvmeRemoteNamespacesResponse::nvme_remote_namespaces() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.nvme_remote_namespaces)
  return _impl_.nvme_remote_namespaces_;
}

// string next_page_token = 2;
inline void ListNvmeRemoteNamespacesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeRemoteNamespacesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeRemoteNamespacesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token)
}
inline std::string* ListNvmeRemoteNamespacesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token)
  return _s;
}
inline const std::string& ListNvmeRemoteNamespacesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListNvmeRemoteNamespacesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteNamespacesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeRemoteNamespacesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListNvmeRemoteNamespacesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNvmeRemoteNamespaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNvmeRemoteNamespaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNvmeRemoteNamespaceRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNvmeRemoteNamespaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name)
}
inline std::string* GetNvmeRemoteNamespaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name)
  return _s;
}
inline const std::string& GetNvmeRemoteNamespaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetNvmeRemoteNamespaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNvmeRemoteNamespaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNvmeRemoteNamespaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name)
  return _impl_.name_.Release();
}
inline void GetNvmeRemoteNamespaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name)
}

// -------------------------------------------------------------------

// CreateNvmePathRequest

// .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNvmePathRequest::_internal_has_nvme_path() const {
  return this != internal_default_instance() && _impl_.nvme_path_ != nullptr;
}
inline bool CreateNvmePathRequest::has_nvme_path() const {
  return _internal_has_nvme_path();
}
inline void CreateNvmePathRequest::clear_nvme_path() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmePath& CreateNvmePathRequest::_internal_nvme_path() const {
  const ::opi_api::storage::v1::NvmePath* p = _impl_.nvme_path_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmePath&>(
      ::opi_api::storage::v1::_NvmePath_default_instance_);
}
inline const ::opi_api::storage::v1::NvmePath& CreateNvmePathRequest::nvme_path() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmePathRequest.nvme_path)
  return _internal_nvme_path();
}
inline void CreateNvmePathRequest::unsafe_arena_set_allocated_nvme_path(
    ::opi_api::storage::v1::NvmePath* nvme_path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_path_);
  }
  _impl_.nvme_path_ = nvme_path;
  if (nvme_path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNvmePathRequest.nvme_path)
}
inline ::opi_api::storage::v1::NvmePath* CreateNvmePathRequest::release_nvme_path() {
  
  ::opi_api::storage::v1::NvmePath* temp = _impl_.nvme_path_;
  _impl_.nvme_path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmePath* CreateNvmePathRequest::unsafe_arena_release_nvme_path() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmePathRequest.nvme_path)
  
  ::opi_api::storage::v1::NvmePath* temp = _impl_.nvme_path_;
  _impl_.nvme_path_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmePath* CreateNvmePathRequest::_internal_mutable_nvme_path() {
  
  if (_impl_.nvme_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmePath>(GetArenaForAllocation());
    _impl_.nvme_path_ = p;
  }
  return _impl_.nvme_path_;
}
inline ::opi_api::storage::v1::NvmePath* CreateNvmePathRequest::mutable_nvme_path() {
  ::opi_api::storage::v1::NvmePath* _msg = _internal_mutable_nvme_path();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmePathRequest.nvme_path)
  return _msg;
}
inline void CreateNvmePathRequest::set_allocated_nvme_path(::opi_api::storage::v1::NvmePath* nvme_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_path_;
  }
  if (nvme_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_path);
    if (message_arena != submessage_arena) {
      nvme_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_path, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_path_ = nvme_path;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmePathRequest.nvme_path)
}

// string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateNvmePathRequest::clear_nvme_path_id() {
  _impl_.nvme_path_id_.ClearToEmpty();
}
inline const std::string& CreateNvmePathRequest::nvme_path_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id)
  return _internal_nvme_path_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmePathRequest::set_nvme_path_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nvme_path_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id)
}
inline std::string* CreateNvmePathRequest::mutable_nvme_path_id() {
  std::string* _s = _internal_mutable_nvme_path_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id)
  return _s;
}
inline const std::string& CreateNvmePathRequest::_internal_nvme_path_id() const {
  return _impl_.nvme_path_id_.Get();
}
inline void CreateNvmePathRequest::_internal_set_nvme_path_id(const std::string& value) {
  
  _impl_.nvme_path_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmePathRequest::_internal_mutable_nvme_path_id() {
  
  return _impl_.nvme_path_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmePathRequest::release_nvme_path_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id)
  return _impl_.nvme_path_id_.Release();
}
inline void CreateNvmePathRequest::set_allocated_nvme_path_id(std::string* nvme_path_id) {
  if (nvme_path_id != nullptr) {
    
  } else {
    
  }
  _impl_.nvme_path_id_.SetAllocated(nvme_path_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nvme_path_id_.IsDefault()) {
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id)
}

// -------------------------------------------------------------------

// DeleteNvmePathRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNvmePathRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteNvmePathRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmePathRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNvmePathRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmePathRequest.name)
}
inline std::string* DeleteNvmePathRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNvmePathRequest.name)
  return _s;
}
inline const std::string& DeleteNvmePathRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteNvmePathRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteNvmePathRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteNvmePathRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNvmePathRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteNvmePathRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNvmePathRequest.name)
}

// bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void DeleteNvmePathRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool DeleteNvmePathRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool DeleteNvmePathRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmePathRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteNvmePathRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void DeleteNvmePathRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmePathRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateNvmePathRequest

// .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateNvmePathRequest::_internal_has_nvme_path() const {
  return this != internal_default_instance() && _impl_.nvme_path_ != nullptr;
}
inline bool UpdateNvmePathRequest::has_nvme_path() const {
  return _internal_has_nvme_path();
}
inline void UpdateNvmePathRequest::clear_nvme_path() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmePath& UpdateNvmePathRequest::_internal_nvme_path() const {
  const ::opi_api::storage::v1::NvmePath* p = _impl_.nvme_path_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmePath&>(
      ::opi_api::storage::v1::_NvmePath_default_instance_);
}
inline const ::opi_api::storage::v1::NvmePath& UpdateNvmePathRequest::nvme_path() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmePathRequest.nvme_path)
  return _internal_nvme_path();
}
inline void UpdateNvmePathRequest::unsafe_arena_set_allocated_nvme_path(
    ::opi_api::storage::v1::NvmePath* nvme_path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_path_);
  }
  _impl_.nvme_path_ = nvme_path;
  if (nvme_path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmePathRequest.nvme_path)
}
inline ::opi_api::storage::v1::NvmePath* UpdateNvmePathRequest::release_nvme_path() {
  
  ::opi_api::storage::v1::NvmePath* temp = _impl_.nvme_path_;
  _impl_.nvme_path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmePath* UpdateNvmePathRequest::unsafe_arena_release_nvme_path() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmePathRequest.nvme_path)
  
  ::opi_api::storage::v1::NvmePath* temp = _impl_.nvme_path_;
  _impl_.nvme_path_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmePath* UpdateNvmePathRequest::_internal_mutable_nvme_path() {
  
  if (_impl_.nvme_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmePath>(GetArenaForAllocation());
    _impl_.nvme_path_ = p;
  }
  return _impl_.nvme_path_;
}
inline ::opi_api::storage::v1::NvmePath* UpdateNvmePathRequest::mutable_nvme_path() {
  ::opi_api::storage::v1::NvmePath* _msg = _internal_mutable_nvme_path();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmePathRequest.nvme_path)
  return _msg;
}
inline void UpdateNvmePathRequest::set_allocated_nvme_path(::opi_api::storage::v1::NvmePath* nvme_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_path_;
  }
  if (nvme_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_path);
    if (message_arena != submessage_arena) {
      nvme_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_path, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_path_ = nvme_path;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmePathRequest.nvme_path)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateNvmePathRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateNvmePathRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmePathRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmePathRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmePathRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNvmePathRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmePathRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmePathRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmePathRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmePathRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmePathRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmePathRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmePathRequest.update_mask)
  return _msg;
}
inline void UpdateNvmePathRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmePathRequest.update_mask)
}

// bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateNvmePathRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool UpdateNvmePathRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool UpdateNvmePathRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmePathRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateNvmePathRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void UpdateNvmePathRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateNvmePathRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListNvmePathsRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNvmePathsRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListNvmePathsRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmePathsRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmePathsRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmePathsRequest.parent)
}
inline std::string* ListNvmePathsRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmePathsRequest.parent)
  return _s;
}
inline const std::string& ListNvmePathsRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListNvmePathsRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmePathsRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmePathsRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmePathsRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListNvmePathsRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmePathsRequest.parent)
}

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmePathsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListNvmePathsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListNvmePathsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmePathsRequest.page_size)
  return _internal_page_size();
}
inline void ListNvmePathsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListNvmePathsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmePathsRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmePathsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListNvmePathsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmePathsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmePathsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmePathsRequest.page_token)
}
inline std::string* ListNvmePathsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmePathsRequest.page_token)
  return _s;
}
inline const std::string& ListNvmePathsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListNvmePathsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmePathsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmePathsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmePathsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListNvmePathsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmePathsRequest.page_token)
}

// -------------------------------------------------------------------

// ListNvmePathsResponse

// repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
inline int ListNvmePathsResponse::_internal_nvme_paths_size() const {
  return _impl_.nvme_paths_.size();
}
inline int ListNvmePathsResponse::nvme_paths_size() const {
  return _internal_nvme_paths_size();
}
inline void ListNvmePathsResponse::clear_nvme_paths() {
  _impl_.nvme_paths_.Clear();
}
inline ::opi_api::storage::v1::NvmePath* ListNvmePathsResponse::mutable_nvme_paths(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmePathsResponse.nvme_paths)
  return _impl_.nvme_paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmePath >*
ListNvmePathsResponse::mutable_nvme_paths() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNvmePathsResponse.nvme_paths)
  return &_impl_.nvme_paths_;
}
inline const ::opi_api::storage::v1::NvmePath& ListNvmePathsResponse::_internal_nvme_paths(int index) const {
  return _impl_.nvme_paths_.Get(index);
}
inline const ::opi_api::storage::v1::NvmePath& ListNvmePathsResponse::nvme_paths(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmePathsResponse.nvme_paths)
  return _internal_nvme_paths(index);
}
inline ::opi_api::storage::v1::NvmePath* ListNvmePathsResponse::_internal_add_nvme_paths() {
  return _impl_.nvme_paths_.Add();
}
inline ::opi_api::storage::v1::NvmePath* ListNvmePathsResponse::add_nvme_paths() {
  ::opi_api::storage::v1::NvmePath* _add = _internal_add_nvme_paths();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNvmePathsResponse.nvme_paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmePath >&
ListNvmePathsResponse::nvme_paths() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNvmePathsResponse.nvme_paths)
  return _impl_.nvme_paths_;
}

// string next_page_token = 2;
inline void ListNvmePathsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListNvmePathsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmePathsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmePathsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmePathsResponse.next_page_token)
}
inline std::string* ListNvmePathsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmePathsResponse.next_page_token)
  return _s;
}
inline const std::string& ListNvmePathsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListNvmePathsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmePathsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmePathsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmePathsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListNvmePathsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmePathsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNvmePathRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNvmePathRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNvmePathRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNvmePathRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNvmePathRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNvmePathRequest.name)
}
inline std::string* GetNvmePathRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNvmePathRequest.name)
  return _s;
}
inline const std::string& GetNvmePathRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetNvmePathRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNvmePathRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNvmePathRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNvmePathRequest.name)
  return _impl_.name_.Release();
}
inline void GetNvmePathRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNvmePathRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmePathRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsNvmePathRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StatsNvmePathRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmePathRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsNvmePathRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsNvmePathRequest.name)
}
inline std::string* StatsNvmePathRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmePathRequest.name)
  return _s;
}
inline const std::string& StatsNvmePathRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatsNvmePathRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatsNvmePathRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatsNvmePathRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmePathRequest.name)
  return _impl_.name_.Release();
}
inline void StatsNvmePathRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmePathRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmePathResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsNvmePathResponse::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool StatsNvmePathResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmePathResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmePathResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmePathResponse.stats)
  return _internal_stats();
}
inline void StatsNvmePathResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsNvmePathResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmePathResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmePathResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmePathResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmePathResponse::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmePathResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmePathResponse.stats)
  return _msg;
}
inline void StatsNvmePathResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmePathResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::storage::v1::NvmeMultipath> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NvmeMultipath>() {
  return ::opi_api::storage::v1::NvmeMultipath_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_backend_5fnvme_5ftcp_2eproto
