// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: frontend_nvme.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "opicommon.pb.h"
#include "uuid.pb.h"
#include "google/api/client.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/field_mask.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_frontend_5fnvme_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_frontend_5fnvme_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_frontend_5fnvme_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class CreateNvmeControllerRequest;
struct CreateNvmeControllerRequestDefaultTypeInternal;
extern CreateNvmeControllerRequestDefaultTypeInternal _CreateNvmeControllerRequest_default_instance_;
class CreateNvmeNamespaceRequest;
struct CreateNvmeNamespaceRequestDefaultTypeInternal;
extern CreateNvmeNamespaceRequestDefaultTypeInternal _CreateNvmeNamespaceRequest_default_instance_;
class CreateNvmeSubsystemRequest;
struct CreateNvmeSubsystemRequestDefaultTypeInternal;
extern CreateNvmeSubsystemRequestDefaultTypeInternal _CreateNvmeSubsystemRequest_default_instance_;
class DeleteNvmeControllerRequest;
struct DeleteNvmeControllerRequestDefaultTypeInternal;
extern DeleteNvmeControllerRequestDefaultTypeInternal _DeleteNvmeControllerRequest_default_instance_;
class DeleteNvmeNamespaceRequest;
struct DeleteNvmeNamespaceRequestDefaultTypeInternal;
extern DeleteNvmeNamespaceRequestDefaultTypeInternal _DeleteNvmeNamespaceRequest_default_instance_;
class DeleteNvmeSubsystemRequest;
struct DeleteNvmeSubsystemRequestDefaultTypeInternal;
extern DeleteNvmeSubsystemRequestDefaultTypeInternal _DeleteNvmeSubsystemRequest_default_instance_;
class GetNvmeControllerRequest;
struct GetNvmeControllerRequestDefaultTypeInternal;
extern GetNvmeControllerRequestDefaultTypeInternal _GetNvmeControllerRequest_default_instance_;
class GetNvmeNamespaceRequest;
struct GetNvmeNamespaceRequestDefaultTypeInternal;
extern GetNvmeNamespaceRequestDefaultTypeInternal _GetNvmeNamespaceRequest_default_instance_;
class GetNvmeSubsystemRequest;
struct GetNvmeSubsystemRequestDefaultTypeInternal;
extern GetNvmeSubsystemRequestDefaultTypeInternal _GetNvmeSubsystemRequest_default_instance_;
class ListNvmeControllersRequest;
struct ListNvmeControllersRequestDefaultTypeInternal;
extern ListNvmeControllersRequestDefaultTypeInternal _ListNvmeControllersRequest_default_instance_;
class ListNvmeControllersResponse;
struct ListNvmeControllersResponseDefaultTypeInternal;
extern ListNvmeControllersResponseDefaultTypeInternal _ListNvmeControllersResponse_default_instance_;
class ListNvmeNamespacesRequest;
struct ListNvmeNamespacesRequestDefaultTypeInternal;
extern ListNvmeNamespacesRequestDefaultTypeInternal _ListNvmeNamespacesRequest_default_instance_;
class ListNvmeNamespacesResponse;
struct ListNvmeNamespacesResponseDefaultTypeInternal;
extern ListNvmeNamespacesResponseDefaultTypeInternal _ListNvmeNamespacesResponse_default_instance_;
class ListNvmeSubsystemsRequest;
struct ListNvmeSubsystemsRequestDefaultTypeInternal;
extern ListNvmeSubsystemsRequestDefaultTypeInternal _ListNvmeSubsystemsRequest_default_instance_;
class ListNvmeSubsystemsResponse;
struct ListNvmeSubsystemsResponseDefaultTypeInternal;
extern ListNvmeSubsystemsResponseDefaultTypeInternal _ListNvmeSubsystemsResponse_default_instance_;
class NvmeController;
struct NvmeControllerDefaultTypeInternal;
extern NvmeControllerDefaultTypeInternal _NvmeController_default_instance_;
class NvmeControllerSpec;
struct NvmeControllerSpecDefaultTypeInternal;
extern NvmeControllerSpecDefaultTypeInternal _NvmeControllerSpec_default_instance_;
class NvmeControllerStatus;
struct NvmeControllerStatusDefaultTypeInternal;
extern NvmeControllerStatusDefaultTypeInternal _NvmeControllerStatus_default_instance_;
class NvmeNamespace;
struct NvmeNamespaceDefaultTypeInternal;
extern NvmeNamespaceDefaultTypeInternal _NvmeNamespace_default_instance_;
class NvmeNamespaceSpec;
struct NvmeNamespaceSpecDefaultTypeInternal;
extern NvmeNamespaceSpecDefaultTypeInternal _NvmeNamespaceSpec_default_instance_;
class NvmeNamespaceStatus;
struct NvmeNamespaceStatusDefaultTypeInternal;
extern NvmeNamespaceStatusDefaultTypeInternal _NvmeNamespaceStatus_default_instance_;
class NvmeSubsystem;
struct NvmeSubsystemDefaultTypeInternal;
extern NvmeSubsystemDefaultTypeInternal _NvmeSubsystem_default_instance_;
class NvmeSubsystemSpec;
struct NvmeSubsystemSpecDefaultTypeInternal;
extern NvmeSubsystemSpecDefaultTypeInternal _NvmeSubsystemSpec_default_instance_;
class NvmeSubsystemStatus;
struct NvmeSubsystemStatusDefaultTypeInternal;
extern NvmeSubsystemStatusDefaultTypeInternal _NvmeSubsystemStatus_default_instance_;
class StatsNvmeControllerRequest;
struct StatsNvmeControllerRequestDefaultTypeInternal;
extern StatsNvmeControllerRequestDefaultTypeInternal _StatsNvmeControllerRequest_default_instance_;
class StatsNvmeControllerResponse;
struct StatsNvmeControllerResponseDefaultTypeInternal;
extern StatsNvmeControllerResponseDefaultTypeInternal _StatsNvmeControllerResponse_default_instance_;
class StatsNvmeNamespaceRequest;
struct StatsNvmeNamespaceRequestDefaultTypeInternal;
extern StatsNvmeNamespaceRequestDefaultTypeInternal _StatsNvmeNamespaceRequest_default_instance_;
class StatsNvmeNamespaceResponse;
struct StatsNvmeNamespaceResponseDefaultTypeInternal;
extern StatsNvmeNamespaceResponseDefaultTypeInternal _StatsNvmeNamespaceResponse_default_instance_;
class StatsNvmeSubsystemRequest;
struct StatsNvmeSubsystemRequestDefaultTypeInternal;
extern StatsNvmeSubsystemRequestDefaultTypeInternal _StatsNvmeSubsystemRequest_default_instance_;
class StatsNvmeSubsystemResponse;
struct StatsNvmeSubsystemResponseDefaultTypeInternal;
extern StatsNvmeSubsystemResponseDefaultTypeInternal _StatsNvmeSubsystemResponse_default_instance_;
class UpdateNvmeControllerRequest;
struct UpdateNvmeControllerRequestDefaultTypeInternal;
extern UpdateNvmeControllerRequestDefaultTypeInternal _UpdateNvmeControllerRequest_default_instance_;
class UpdateNvmeNamespaceRequest;
struct UpdateNvmeNamespaceRequestDefaultTypeInternal;
extern UpdateNvmeNamespaceRequestDefaultTypeInternal _UpdateNvmeNamespaceRequest_default_instance_;
class UpdateNvmeSubsystemRequest;
struct UpdateNvmeSubsystemRequestDefaultTypeInternal;
extern UpdateNvmeSubsystemRequestDefaultTypeInternal _UpdateNvmeSubsystemRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::CreateNvmeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNvmeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNvmeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNvmeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::CreateNvmeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateNvmeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNvmeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNvmeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNvmeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNvmeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteNvmeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteNvmeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNvmeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNvmeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNvmeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNvmeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::GetNvmeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetNvmeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeControllersRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeControllersRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeControllersResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeControllersResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeNamespacesRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeNamespacesRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeNamespacesResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeNamespacesResponse>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeSubsystemsRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeSubsystemsRequest>(Arena*);
template<> ::opi_api::storage::v1::ListNvmeSubsystemsResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListNvmeSubsystemsResponse>(Arena*);
template<> ::opi_api::storage::v1::NvmeController* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeController>(Arena*);
template<> ::opi_api::storage::v1::NvmeControllerSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeControllerSpec>(Arena*);
template<> ::opi_api::storage::v1::NvmeControllerStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeControllerStatus>(Arena*);
template<> ::opi_api::storage::v1::NvmeNamespace* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespace>(Arena*);
template<> ::opi_api::storage::v1::NvmeNamespaceSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespaceSpec>(Arena*);
template<> ::opi_api::storage::v1::NvmeNamespaceStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespaceStatus>(Arena*);
template<> ::opi_api::storage::v1::NvmeSubsystem* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystem>(Arena*);
template<> ::opi_api::storage::v1::NvmeSubsystemSpec* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystemSpec>(Arena*);
template<> ::opi_api::storage::v1::NvmeSubsystemStatus* Arena::CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystemStatus>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeControllerResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeControllerResponse>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeNamespaceResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeNamespaceResponse>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeSubsystemRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsNvmeSubsystemResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsNvmeSubsystemResponse>(Arena*);
template<> ::opi_api::storage::v1::UpdateNvmeControllerRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNvmeControllerRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNvmeNamespaceRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNvmeNamespaceRequest>(Arena*);
template<> ::opi_api::storage::v1::UpdateNvmeSubsystemRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateNvmeSubsystemRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

enum NvmeNamespacePciState : int {
  NVME_NAMESPACE_PCI_STATE_UNSPECIFIED = 0,
  NVME_NAMESPACE_PCI_STATE_DISABLED = 1,
  NVME_NAMESPACE_PCI_STATE_ENABLED = 2,
  NVME_NAMESPACE_PCI_STATE_DELETING = 3,
  NvmeNamespacePciState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NvmeNamespacePciState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NvmeNamespacePciState_IsValid(int value);
constexpr NvmeNamespacePciState NvmeNamespacePciState_MIN = NVME_NAMESPACE_PCI_STATE_UNSPECIFIED;
constexpr NvmeNamespacePciState NvmeNamespacePciState_MAX = NVME_NAMESPACE_PCI_STATE_DELETING;
constexpr int NvmeNamespacePciState_ARRAYSIZE = NvmeNamespacePciState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeNamespacePciState_descriptor();
template<typename T>
inline const std::string& NvmeNamespacePciState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NvmeNamespacePciState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NvmeNamespacePciState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NvmeNamespacePciState_descriptor(), enum_t_value);
}
inline bool NvmeNamespacePciState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NvmeNamespacePciState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NvmeNamespacePciState>(
    NvmeNamespacePciState_descriptor(), name, value);
}
enum NvmeNamespacePciOperState : int {
  NVME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED = 0,
  NVME_NAMESPACE_PCI_OPER_STATE_ONLINE = 1,
  NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE = 2,
  NvmeNamespacePciOperState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NvmeNamespacePciOperState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NvmeNamespacePciOperState_IsValid(int value);
constexpr NvmeNamespacePciOperState NvmeNamespacePciOperState_MIN = NVME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED;
constexpr NvmeNamespacePciOperState NvmeNamespacePciOperState_MAX = NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE;
constexpr int NvmeNamespacePciOperState_ARRAYSIZE = NvmeNamespacePciOperState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeNamespacePciOperState_descriptor();
template<typename T>
inline const std::string& NvmeNamespacePciOperState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NvmeNamespacePciOperState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NvmeNamespacePciOperState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NvmeNamespacePciOperState_descriptor(), enum_t_value);
}
inline bool NvmeNamespacePciOperState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NvmeNamespacePciOperState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NvmeNamespacePciOperState>(
    NvmeNamespacePciOperState_descriptor(), name, value);
}
// ===================================================================

class NvmeSubsystem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeSubsystem) */ {
 public:
  inline NvmeSubsystem() : NvmeSubsystem(nullptr) {}
  ~NvmeSubsystem() override;
  explicit PROTOBUF_CONSTEXPR NvmeSubsystem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeSubsystem(const NvmeSubsystem& from);
  NvmeSubsystem(NvmeSubsystem&& from) noexcept
    : NvmeSubsystem() {
    *this = ::std::move(from);
  }

  inline NvmeSubsystem& operator=(const NvmeSubsystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeSubsystem& operator=(NvmeSubsystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeSubsystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeSubsystem* internal_default_instance() {
    return reinterpret_cast<const NvmeSubsystem*>(
               &_NvmeSubsystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NvmeSubsystem& a, NvmeSubsystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeSubsystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeSubsystem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeSubsystem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeSubsystem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeSubsystem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeSubsystem& from) {
    NvmeSubsystem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeSubsystem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeSubsystem";
  }
  protected:
  explicit NvmeSubsystem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.storage.v1.NvmeSubsystemSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NvmeSubsystemSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeSubsystemSpec* release_spec();
  ::opi_api::storage::v1::NvmeSubsystemSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NvmeSubsystemSpec* spec);
  private:
  const ::opi_api::storage::v1::NvmeSubsystemSpec& _internal_spec() const;
  ::opi_api::storage::v1::NvmeSubsystemSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NvmeSubsystemSpec* spec);
  ::opi_api::storage::v1::NvmeSubsystemSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NvmeSubsystemStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NvmeSubsystemStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeSubsystemStatus* release_status();
  ::opi_api::storage::v1::NvmeSubsystemStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NvmeSubsystemStatus* status);
  private:
  const ::opi_api::storage::v1::NvmeSubsystemStatus& _internal_status() const;
  ::opi_api::storage::v1::NvmeSubsystemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NvmeSubsystemStatus* status);
  ::opi_api::storage::v1::NvmeSubsystemStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeSubsystem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::storage::v1::NvmeSubsystemSpec* spec_;
    ::opi_api::storage::v1::NvmeSubsystemStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeSubsystemSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeSubsystemSpec) */ {
 public:
  inline NvmeSubsystemSpec() : NvmeSubsystemSpec(nullptr) {}
  ~NvmeSubsystemSpec() override;
  explicit PROTOBUF_CONSTEXPR NvmeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeSubsystemSpec(const NvmeSubsystemSpec& from);
  NvmeSubsystemSpec(NvmeSubsystemSpec&& from) noexcept
    : NvmeSubsystemSpec() {
    *this = ::std::move(from);
  }

  inline NvmeSubsystemSpec& operator=(const NvmeSubsystemSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeSubsystemSpec& operator=(NvmeSubsystemSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeSubsystemSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeSubsystemSpec* internal_default_instance() {
    return reinterpret_cast<const NvmeSubsystemSpec*>(
               &_NvmeSubsystemSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NvmeSubsystemSpec& a, NvmeSubsystemSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeSubsystemSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeSubsystemSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeSubsystemSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeSubsystemSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeSubsystemSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeSubsystemSpec& from) {
    NvmeSubsystemSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeSubsystemSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeSubsystemSpec";
  }
  protected:
  explicit NvmeSubsystemSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNqnFieldNumber = 1,
    kSerialNumberFieldNumber = 2,
    kModelNumberFieldNumber = 3,
    kHostnqnFieldNumber = 5,
    kPskFieldNumber = 6,
    kMaxNamespacesFieldNumber = 4,
  };
  // string nqn = 1 [(.google.api.field_behavior) = REQUIRED];
  void clear_nqn();
  const std::string& nqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nqn();
  PROTOBUF_NODISCARD std::string* release_nqn();
  void set_allocated_nqn(std::string* nqn);
  private:
  const std::string& _internal_nqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nqn(const std::string& value);
  std::string* _internal_mutable_nqn();
  public:

  // string serial_number = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  PROTOBUF_NODISCARD std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // string model_number = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_model_number();
  const std::string& model_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_number();
  PROTOBUF_NODISCARD std::string* release_model_number();
  void set_allocated_model_number(std::string* model_number);
  private:
  const std::string& _internal_model_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_number(const std::string& value);
  std::string* _internal_mutable_model_number();
  public:

  // string hostnqn = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_hostnqn();
  const std::string& hostnqn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostnqn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostnqn();
  PROTOBUF_NODISCARD std::string* release_hostnqn();
  void set_allocated_hostnqn(std::string* hostnqn);
  private:
  const std::string& _internal_hostnqn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostnqn(const std::string& value);
  std::string* _internal_mutable_hostnqn();
  public:

  // bytes psk = 6 [(.google.api.field_behavior) = OPTIONAL];
  void clear_psk();
  const std::string& psk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_psk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_psk();
  PROTOBUF_NODISCARD std::string* release_psk();
  void set_allocated_psk(std::string* psk);
  private:
  const std::string& _internal_psk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_psk(const std::string& value);
  std::string* _internal_mutable_psk();
  public:

  // int64 max_namespaces = 4 [(.google.api.field_behavior) = OPTIONAL];
  void clear_max_namespaces();
  int64_t max_namespaces() const;
  void set_max_namespaces(int64_t value);
  private:
  int64_t _internal_max_namespaces() const;
  void _internal_set_max_namespaces(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeSubsystemSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nqn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostnqn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr psk_;
    int64_t max_namespaces_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeSubsystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeSubsystemStatus) */ {
 public:
  inline NvmeSubsystemStatus() : NvmeSubsystemStatus(nullptr) {}
  ~NvmeSubsystemStatus() override;
  explicit PROTOBUF_CONSTEXPR NvmeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeSubsystemStatus(const NvmeSubsystemStatus& from);
  NvmeSubsystemStatus(NvmeSubsystemStatus&& from) noexcept
    : NvmeSubsystemStatus() {
    *this = ::std::move(from);
  }

  inline NvmeSubsystemStatus& operator=(const NvmeSubsystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeSubsystemStatus& operator=(NvmeSubsystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeSubsystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeSubsystemStatus* internal_default_instance() {
    return reinterpret_cast<const NvmeSubsystemStatus*>(
               &_NvmeSubsystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NvmeSubsystemStatus& a, NvmeSubsystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeSubsystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeSubsystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeSubsystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeSubsystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeSubsystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeSubsystemStatus& from) {
    NvmeSubsystemStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeSubsystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeSubsystemStatus";
  }
  protected:
  explicit NvmeSubsystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirmwareRevisionFieldNumber = 1,
    kFruGuidFieldNumber = 2,
  };
  // string firmware_revision = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_firmware_revision();
  const std::string& firmware_revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_firmware_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_firmware_revision();
  PROTOBUF_NODISCARD std::string* release_firmware_revision();
  void set_allocated_firmware_revision(std::string* firmware_revision);
  private:
  const std::string& _internal_firmware_revision() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_revision(const std::string& value);
  std::string* _internal_mutable_firmware_revision();
  public:

  // bytes fru_guid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_fru_guid();
  const std::string& fru_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fru_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fru_guid();
  PROTOBUF_NODISCARD std::string* release_fru_guid();
  void set_allocated_fru_guid(std::string* fru_guid);
  private:
  const std::string& _internal_fru_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fru_guid(const std::string& value);
  std::string* _internal_mutable_fru_guid();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeSubsystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_revision_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fru_guid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeController final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeController) */ {
 public:
  inline NvmeController() : NvmeController(nullptr) {}
  ~NvmeController() override;
  explicit PROTOBUF_CONSTEXPR NvmeController(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeController(const NvmeController& from);
  NvmeController(NvmeController&& from) noexcept
    : NvmeController() {
    *this = ::std::move(from);
  }

  inline NvmeController& operator=(const NvmeController& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeController& operator=(NvmeController&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeController& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeController* internal_default_instance() {
    return reinterpret_cast<const NvmeController*>(
               &_NvmeController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NvmeController& a, NvmeController& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeController>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeController& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeController& from) {
    NvmeController::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeController* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeController";
  }
  protected:
  explicit NvmeController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.storage.v1.NvmeControllerSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NvmeControllerSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeControllerSpec* release_spec();
  ::opi_api::storage::v1::NvmeControllerSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NvmeControllerSpec* spec);
  private:
  const ::opi_api::storage::v1::NvmeControllerSpec& _internal_spec() const;
  ::opi_api::storage::v1::NvmeControllerSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NvmeControllerSpec* spec);
  ::opi_api::storage::v1::NvmeControllerSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NvmeControllerStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NvmeControllerStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeControllerStatus* release_status();
  ::opi_api::storage::v1::NvmeControllerStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NvmeControllerStatus* status);
  private:
  const ::opi_api::storage::v1::NvmeControllerStatus& _internal_status() const;
  ::opi_api::storage::v1::NvmeControllerStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NvmeControllerStatus* status);
  ::opi_api::storage::v1::NvmeControllerStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::storage::v1::NvmeControllerSpec* spec_;
    ::opi_api::storage::v1::NvmeControllerStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeControllerSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeControllerSpec) */ {
 public:
  inline NvmeControllerSpec() : NvmeControllerSpec(nullptr) {}
  ~NvmeControllerSpec() override;
  explicit PROTOBUF_CONSTEXPR NvmeControllerSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeControllerSpec(const NvmeControllerSpec& from);
  NvmeControllerSpec(NvmeControllerSpec&& from) noexcept
    : NvmeControllerSpec() {
    *this = ::std::move(from);
  }

  inline NvmeControllerSpec& operator=(const NvmeControllerSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeControllerSpec& operator=(NvmeControllerSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeControllerSpec& default_instance() {
    return *internal_default_instance();
  }
  enum EndpointCase {
    kPcieId = 3,
    kFabricsId = 4,
    ENDPOINT_NOT_SET = 0,
  };

  static inline const NvmeControllerSpec* internal_default_instance() {
    return reinterpret_cast<const NvmeControllerSpec*>(
               &_NvmeControllerSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NvmeControllerSpec& a, NvmeControllerSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeControllerSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeControllerSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeControllerSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeControllerSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeControllerSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeControllerSpec& from) {
    NvmeControllerSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeControllerSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeControllerSpec";
  }
  protected:
  explicit NvmeControllerSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinLimitFieldNumber = 10,
    kMaxLimitFieldNumber = 11,
    kNvmeControllerIdFieldNumber = 1,
    kTrtypeFieldNumber = 2,
    kMaxNsqFieldNumber = 5,
    kMaxNcqFieldNumber = 6,
    kSqesFieldNumber = 7,
    kCqesFieldNumber = 8,
    kMaxNamespacesFieldNumber = 9,
    kPcieIdFieldNumber = 3,
    kFabricsIdFieldNumber = 4,
  };
  // .opi_api.storage.v1.QosLimit min_limit = 10 [(.google.api.field_behavior) = OPTIONAL];
  bool has_min_limit() const;
  private:
  bool _internal_has_min_limit() const;
  public:
  void clear_min_limit();
  const ::opi_api::storage::v1::QosLimit& min_limit() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosLimit* release_min_limit();
  ::opi_api::storage::v1::QosLimit* mutable_min_limit();
  void set_allocated_min_limit(::opi_api::storage::v1::QosLimit* min_limit);
  private:
  const ::opi_api::storage::v1::QosLimit& _internal_min_limit() const;
  ::opi_api::storage::v1::QosLimit* _internal_mutable_min_limit();
  public:
  void unsafe_arena_set_allocated_min_limit(
      ::opi_api::storage::v1::QosLimit* min_limit);
  ::opi_api::storage::v1::QosLimit* unsafe_arena_release_min_limit();

  // .opi_api.storage.v1.QosLimit max_limit = 11 [(.google.api.field_behavior) = OPTIONAL];
  bool has_max_limit() const;
  private:
  bool _internal_has_max_limit() const;
  public:
  void clear_max_limit();
  const ::opi_api::storage::v1::QosLimit& max_limit() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosLimit* release_max_limit();
  ::opi_api::storage::v1::QosLimit* mutable_max_limit();
  void set_allocated_max_limit(::opi_api::storage::v1::QosLimit* max_limit);
  private:
  const ::opi_api::storage::v1::QosLimit& _internal_max_limit() const;
  ::opi_api::storage::v1::QosLimit* _internal_mutable_max_limit();
  public:
  void unsafe_arena_set_allocated_max_limit(
      ::opi_api::storage::v1::QosLimit* max_limit);
  ::opi_api::storage::v1::QosLimit* unsafe_arena_release_max_limit();

  // optional int32 nvme_controller_id = 1 [(.google.api.field_behavior) = OPTIONAL];
  bool has_nvme_controller_id() const;
  private:
  bool _internal_has_nvme_controller_id() const;
  public:
  void clear_nvme_controller_id();
  int32_t nvme_controller_id() const;
  void set_nvme_controller_id(int32_t value);
  private:
  int32_t _internal_nvme_controller_id() const;
  void _internal_set_nvme_controller_id(int32_t value);
  public:

  // .opi_api.storage.v1.NvmeTransportType trtype = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_trtype();
  ::opi_api::storage::v1::NvmeTransportType trtype() const;
  void set_trtype(::opi_api::storage::v1::NvmeTransportType value);
  private:
  ::opi_api::storage::v1::NvmeTransportType _internal_trtype() const;
  void _internal_set_trtype(::opi_api::storage::v1::NvmeTransportType value);
  public:

  // int32 max_nsq = 5 [(.google.api.field_behavior) = OPTIONAL];
  void clear_max_nsq();
  int32_t max_nsq() const;
  void set_max_nsq(int32_t value);
  private:
  int32_t _internal_max_nsq() const;
  void _internal_set_max_nsq(int32_t value);
  public:

  // int32 max_ncq = 6 [(.google.api.field_behavior) = OPTIONAL];
  void clear_max_ncq();
  int32_t max_ncq() const;
  void set_max_ncq(int32_t value);
  private:
  int32_t _internal_max_ncq() const;
  void _internal_set_max_ncq(int32_t value);
  public:

  // int32 sqes = 7 [(.google.api.field_behavior) = OPTIONAL];
  void clear_sqes();
  int32_t sqes() const;
  void set_sqes(int32_t value);
  private:
  int32_t _internal_sqes() const;
  void _internal_set_sqes(int32_t value);
  public:

  // int32 cqes = 8 [(.google.api.field_behavior) = OPTIONAL];
  void clear_cqes();
  int32_t cqes() const;
  void set_cqes(int32_t value);
  private:
  int32_t _internal_cqes() const;
  void _internal_set_cqes(int32_t value);
  public:

  // int32 max_namespaces = 9 [(.google.api.field_behavior) = OPTIONAL];
  void clear_max_namespaces();
  int32_t max_namespaces() const;
  void set_max_namespaces(int32_t value);
  private:
  int32_t _internal_max_namespaces() const;
  void _internal_set_max_namespaces(int32_t value);
  public:

  // .opi_api.storage.v1.PciEndpoint pcie_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  bool has_pcie_id() const;
  private:
  bool _internal_has_pcie_id() const;
  public:
  void clear_pcie_id();
  const ::opi_api::storage::v1::PciEndpoint& pcie_id() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::PciEndpoint* release_pcie_id();
  ::opi_api::storage::v1::PciEndpoint* mutable_pcie_id();
  void set_allocated_pcie_id(::opi_api::storage::v1::PciEndpoint* pcie_id);
  private:
  const ::opi_api::storage::v1::PciEndpoint& _internal_pcie_id() const;
  ::opi_api::storage::v1::PciEndpoint* _internal_mutable_pcie_id();
  public:
  void unsafe_arena_set_allocated_pcie_id(
      ::opi_api::storage::v1::PciEndpoint* pcie_id);
  ::opi_api::storage::v1::PciEndpoint* unsafe_arena_release_pcie_id();

  // .opi_api.storage.v1.FabricsEndpoint fabrics_id = 4 [(.google.api.field_behavior) = OPTIONAL];
  bool has_fabrics_id() const;
  private:
  bool _internal_has_fabrics_id() const;
  public:
  void clear_fabrics_id();
  const ::opi_api::storage::v1::FabricsEndpoint& fabrics_id() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::FabricsEndpoint* release_fabrics_id();
  ::opi_api::storage::v1::FabricsEndpoint* mutable_fabrics_id();
  void set_allocated_fabrics_id(::opi_api::storage::v1::FabricsEndpoint* fabrics_id);
  private:
  const ::opi_api::storage::v1::FabricsEndpoint& _internal_fabrics_id() const;
  ::opi_api::storage::v1::FabricsEndpoint* _internal_mutable_fabrics_id();
  public:
  void unsafe_arena_set_allocated_fabrics_id(
      ::opi_api::storage::v1::FabricsEndpoint* fabrics_id);
  ::opi_api::storage::v1::FabricsEndpoint* unsafe_arena_release_fabrics_id();

  void clear_endpoint();
  EndpointCase endpoint_case() const;
  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeControllerSpec)
 private:
  class _Internal;
  void set_has_pcie_id();
  void set_has_fabrics_id();

  inline bool has_endpoint() const;
  inline void clear_has_endpoint();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::opi_api::storage::v1::QosLimit* min_limit_;
    ::opi_api::storage::v1::QosLimit* max_limit_;
    int32_t nvme_controller_id_;
    int trtype_;
    int32_t max_nsq_;
    int32_t max_ncq_;
    int32_t sqes_;
    int32_t cqes_;
    int32_t max_namespaces_;
    union EndpointUnion {
      constexpr EndpointUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::opi_api::storage::v1::PciEndpoint* pcie_id_;
      ::opi_api::storage::v1::FabricsEndpoint* fabrics_id_;
    } endpoint_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeControllerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeControllerStatus) */ {
 public:
  inline NvmeControllerStatus() : NvmeControllerStatus(nullptr) {}
  ~NvmeControllerStatus() override;
  explicit PROTOBUF_CONSTEXPR NvmeControllerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeControllerStatus(const NvmeControllerStatus& from);
  NvmeControllerStatus(NvmeControllerStatus&& from) noexcept
    : NvmeControllerStatus() {
    *this = ::std::move(from);
  }

  inline NvmeControllerStatus& operator=(const NvmeControllerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeControllerStatus& operator=(NvmeControllerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeControllerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeControllerStatus* internal_default_instance() {
    return reinterpret_cast<const NvmeControllerStatus*>(
               &_NvmeControllerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NvmeControllerStatus& a, NvmeControllerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeControllerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeControllerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeControllerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeControllerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeControllerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeControllerStatus& from) {
    NvmeControllerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeControllerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeControllerStatus";
  }
  protected:
  explicit NvmeControllerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveFieldNumber = 1,
  };
  // bool active = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeControllerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeNamespace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeNamespace) */ {
 public:
  inline NvmeNamespace() : NvmeNamespace(nullptr) {}
  ~NvmeNamespace() override;
  explicit PROTOBUF_CONSTEXPR NvmeNamespace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeNamespace(const NvmeNamespace& from);
  NvmeNamespace(NvmeNamespace&& from) noexcept
    : NvmeNamespace() {
    *this = ::std::move(from);
  }

  inline NvmeNamespace& operator=(const NvmeNamespace& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeNamespace& operator=(NvmeNamespace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeNamespace& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeNamespace* internal_default_instance() {
    return reinterpret_cast<const NvmeNamespace*>(
               &_NvmeNamespace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NvmeNamespace& a, NvmeNamespace& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeNamespace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeNamespace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeNamespace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeNamespace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeNamespace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeNamespace& from) {
    NvmeNamespace::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeNamespace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeNamespace";
  }
  protected:
  explicit NvmeNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSpecFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .opi_api.storage.v1.NvmeNamespaceSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::opi_api::storage::v1::NvmeNamespaceSpec& spec() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeNamespaceSpec* release_spec();
  ::opi_api::storage::v1::NvmeNamespaceSpec* mutable_spec();
  void set_allocated_spec(::opi_api::storage::v1::NvmeNamespaceSpec* spec);
  private:
  const ::opi_api::storage::v1::NvmeNamespaceSpec& _internal_spec() const;
  ::opi_api::storage::v1::NvmeNamespaceSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::opi_api::storage::v1::NvmeNamespaceSpec* spec);
  ::opi_api::storage::v1::NvmeNamespaceSpec* unsafe_arena_release_spec();

  // .opi_api.storage.v1.NvmeNamespaceStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::opi_api::storage::v1::NvmeNamespaceStatus& status() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeNamespaceStatus* release_status();
  ::opi_api::storage::v1::NvmeNamespaceStatus* mutable_status();
  void set_allocated_status(::opi_api::storage::v1::NvmeNamespaceStatus* status);
  private:
  const ::opi_api::storage::v1::NvmeNamespaceStatus& _internal_status() const;
  ::opi_api::storage::v1::NvmeNamespaceStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::opi_api::storage::v1::NvmeNamespaceStatus* status);
  ::opi_api::storage::v1::NvmeNamespaceStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeNamespace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::opi_api::storage::v1::NvmeNamespaceSpec* spec_;
    ::opi_api::storage::v1::NvmeNamespaceStatus* status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeNamespaceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeNamespaceSpec) */ {
 public:
  inline NvmeNamespaceSpec() : NvmeNamespaceSpec(nullptr) {}
  ~NvmeNamespaceSpec() override;
  explicit PROTOBUF_CONSTEXPR NvmeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeNamespaceSpec(const NvmeNamespaceSpec& from);
  NvmeNamespaceSpec(NvmeNamespaceSpec&& from) noexcept
    : NvmeNamespaceSpec() {
    *this = ::std::move(from);
  }

  inline NvmeNamespaceSpec& operator=(const NvmeNamespaceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeNamespaceSpec& operator=(NvmeNamespaceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeNamespaceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeNamespaceSpec* internal_default_instance() {
    return reinterpret_cast<const NvmeNamespaceSpec*>(
               &_NvmeNamespaceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NvmeNamespaceSpec& a, NvmeNamespaceSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeNamespaceSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeNamespaceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeNamespaceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeNamespaceSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeNamespaceSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeNamespaceSpec& from) {
    NvmeNamespaceSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeNamespaceSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeNamespaceSpec";
  }
  protected:
  explicit NvmeNamespaceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNguidFieldNumber = 3,
    kVolumeNameRefFieldNumber = 6,
    kUuidFieldNumber = 5,
    kEui64FieldNumber = 4,
    kHostNsidFieldNumber = 2,
  };
  // string nguid = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_nguid();
  const std::string& nguid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nguid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nguid();
  PROTOBUF_NODISCARD std::string* release_nguid();
  void set_allocated_nguid(std::string* nguid);
  private:
  const std::string& _internal_nguid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nguid(const std::string& value);
  std::string* _internal_mutable_nguid();
  public:

  // string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
  void clear_volume_name_ref();
  const std::string& volume_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_volume_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_volume_name_ref();
  PROTOBUF_NODISCARD std::string* release_volume_name_ref();
  void set_allocated_volume_name_ref(std::string* volume_name_ref);
  private:
  const std::string& _internal_volume_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_name_ref(const std::string& value);
  std::string* _internal_mutable_volume_name_ref();
  public:

  // .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OPTIONAL];
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const ::opi_api::common::v1::Uuid& uuid() const;
  PROTOBUF_NODISCARD ::opi_api::common::v1::Uuid* release_uuid();
  ::opi_api::common::v1::Uuid* mutable_uuid();
  void set_allocated_uuid(::opi_api::common::v1::Uuid* uuid);
  private:
  const ::opi_api::common::v1::Uuid& _internal_uuid() const;
  ::opi_api::common::v1::Uuid* _internal_mutable_uuid();
  public:
  void unsafe_arena_set_allocated_uuid(
      ::opi_api::common::v1::Uuid* uuid);
  ::opi_api::common::v1::Uuid* unsafe_arena_release_uuid();

  // int64 eui64 = 4 [(.google.api.field_behavior) = OPTIONAL];
  void clear_eui64();
  int64_t eui64() const;
  void set_eui64(int64_t value);
  private:
  int64_t _internal_eui64() const;
  void _internal_set_eui64(int64_t value);
  public:

  // int32 host_nsid = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_host_nsid();
  int32_t host_nsid() const;
  void set_host_nsid(int32_t value);
  private:
  int32_t _internal_host_nsid() const;
  void _internal_set_host_nsid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeNamespaceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nguid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_name_ref_;
    ::opi_api::common::v1::Uuid* uuid_;
    int64_t eui64_;
    int32_t host_nsid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class NvmeNamespaceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.NvmeNamespaceStatus) */ {
 public:
  inline NvmeNamespaceStatus() : NvmeNamespaceStatus(nullptr) {}
  ~NvmeNamespaceStatus() override;
  explicit PROTOBUF_CONSTEXPR NvmeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NvmeNamespaceStatus(const NvmeNamespaceStatus& from);
  NvmeNamespaceStatus(NvmeNamespaceStatus&& from) noexcept
    : NvmeNamespaceStatus() {
    *this = ::std::move(from);
  }

  inline NvmeNamespaceStatus& operator=(const NvmeNamespaceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NvmeNamespaceStatus& operator=(NvmeNamespaceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NvmeNamespaceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NvmeNamespaceStatus* internal_default_instance() {
    return reinterpret_cast<const NvmeNamespaceStatus*>(
               &_NvmeNamespaceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NvmeNamespaceStatus& a, NvmeNamespaceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NvmeNamespaceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NvmeNamespaceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NvmeNamespaceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NvmeNamespaceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NvmeNamespaceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NvmeNamespaceStatus& from) {
    NvmeNamespaceStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NvmeNamespaceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.NvmeNamespaceStatus";
  }
  protected:
  explicit NvmeNamespaceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPciStateFieldNumber = 1,
    kPciOperStateFieldNumber = 2,
  };
  // .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_pci_state();
  ::opi_api::storage::v1::NvmeNamespacePciState pci_state() const;
  void set_pci_state(::opi_api::storage::v1::NvmeNamespacePciState value);
  private:
  ::opi_api::storage::v1::NvmeNamespacePciState _internal_pci_state() const;
  void _internal_set_pci_state(::opi_api::storage::v1::NvmeNamespacePciState value);
  public:

  // .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_pci_oper_state();
  ::opi_api::storage::v1::NvmeNamespacePciOperState pci_oper_state() const;
  void set_pci_oper_state(::opi_api::storage::v1::NvmeNamespacePciOperState value);
  private:
  ::opi_api::storage::v1::NvmeNamespacePciOperState _internal_pci_oper_state() const;
  void _internal_set_pci_oper_state(::opi_api::storage::v1::NvmeNamespacePciOperState value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.NvmeNamespaceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int pci_state_;
    int pci_oper_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class CreateNvmeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNvmeSubsystemRequest) */ {
 public:
  inline CreateNvmeSubsystemRequest() : CreateNvmeSubsystemRequest(nullptr) {}
  ~CreateNvmeSubsystemRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNvmeSubsystemRequest(const CreateNvmeSubsystemRequest& from);
  CreateNvmeSubsystemRequest(CreateNvmeSubsystemRequest&& from) noexcept
    : CreateNvmeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline CreateNvmeSubsystemRequest& operator=(const CreateNvmeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNvmeSubsystemRequest& operator=(CreateNvmeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNvmeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNvmeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNvmeSubsystemRequest*>(
               &_CreateNvmeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateNvmeSubsystemRequest& a, CreateNvmeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNvmeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNvmeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNvmeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNvmeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNvmeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNvmeSubsystemRequest& from) {
    CreateNvmeSubsystemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNvmeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNvmeSubsystemRequest";
  }
  protected:
  explicit CreateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeSubsystemIdFieldNumber = 2,
    kNvmeSubsystemFieldNumber = 1,
  };
  // string nvme_subsystem_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_nvme_subsystem_id();
  const std::string& nvme_subsystem_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nvme_subsystem_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nvme_subsystem_id();
  PROTOBUF_NODISCARD std::string* release_nvme_subsystem_id();
  void set_allocated_nvme_subsystem_id(std::string* nvme_subsystem_id);
  private:
  const std::string& _internal_nvme_subsystem_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nvme_subsystem_id(const std::string& value);
  std::string* _internal_mutable_nvme_subsystem_id();
  public:

  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_subsystem() const;
  private:
  bool _internal_has_nvme_subsystem() const;
  public:
  void clear_nvme_subsystem();
  const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeSubsystem* release_nvme_subsystem();
  ::opi_api::storage::v1::NvmeSubsystem* mutable_nvme_subsystem();
  void set_allocated_nvme_subsystem(::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem);
  private:
  const ::opi_api::storage::v1::NvmeSubsystem& _internal_nvme_subsystem() const;
  ::opi_api::storage::v1::NvmeSubsystem* _internal_mutable_nvme_subsystem();
  public:
  void unsafe_arena_set_allocated_nvme_subsystem(
      ::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem);
  ::opi_api::storage::v1::NvmeSubsystem* unsafe_arena_release_nvme_subsystem();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNvmeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nvme_subsystem_id_;
    ::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class DeleteNvmeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNvmeSubsystemRequest) */ {
 public:
  inline DeleteNvmeSubsystemRequest() : DeleteNvmeSubsystemRequest(nullptr) {}
  ~DeleteNvmeSubsystemRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNvmeSubsystemRequest(const DeleteNvmeSubsystemRequest& from);
  DeleteNvmeSubsystemRequest(DeleteNvmeSubsystemRequest&& from) noexcept
    : DeleteNvmeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNvmeSubsystemRequest& operator=(const DeleteNvmeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNvmeSubsystemRequest& operator=(DeleteNvmeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNvmeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNvmeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNvmeSubsystemRequest*>(
               &_DeleteNvmeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteNvmeSubsystemRequest& a, DeleteNvmeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNvmeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNvmeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNvmeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNvmeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNvmeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteNvmeSubsystemRequest& from) {
    DeleteNvmeSubsystemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNvmeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNvmeSubsystemRequest";
  }
  protected:
  explicit DeleteNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNvmeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class UpdateNvmeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNvmeSubsystemRequest) */ {
 public:
  inline UpdateNvmeSubsystemRequest() : UpdateNvmeSubsystemRequest(nullptr) {}
  ~UpdateNvmeSubsystemRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNvmeSubsystemRequest(const UpdateNvmeSubsystemRequest& from);
  UpdateNvmeSubsystemRequest(UpdateNvmeSubsystemRequest&& from) noexcept
    : UpdateNvmeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNvmeSubsystemRequest& operator=(const UpdateNvmeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNvmeSubsystemRequest& operator=(UpdateNvmeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNvmeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNvmeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNvmeSubsystemRequest*>(
               &_UpdateNvmeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateNvmeSubsystemRequest& a, UpdateNvmeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNvmeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNvmeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNvmeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNvmeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNvmeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateNvmeSubsystemRequest& from) {
    UpdateNvmeSubsystemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNvmeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNvmeSubsystemRequest";
  }
  protected:
  explicit UpdateNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeSubsystemFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_subsystem() const;
  private:
  bool _internal_has_nvme_subsystem() const;
  public:
  void clear_nvme_subsystem();
  const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystem() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeSubsystem* release_nvme_subsystem();
  ::opi_api::storage::v1::NvmeSubsystem* mutable_nvme_subsystem();
  void set_allocated_nvme_subsystem(::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem);
  private:
  const ::opi_api::storage::v1::NvmeSubsystem& _internal_nvme_subsystem() const;
  ::opi_api::storage::v1::NvmeSubsystem* _internal_mutable_nvme_subsystem();
  public:
  void unsafe_arena_set_allocated_nvme_subsystem(
      ::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem);
  ::opi_api::storage::v1::NvmeSubsystem* unsafe_arena_release_nvme_subsystem();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNvmeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeSubsystemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeSubsystemsRequest) */ {
 public:
  inline ListNvmeSubsystemsRequest() : ListNvmeSubsystemsRequest(nullptr) {}
  ~ListNvmeSubsystemsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeSubsystemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeSubsystemsRequest(const ListNvmeSubsystemsRequest& from);
  ListNvmeSubsystemsRequest(ListNvmeSubsystemsRequest&& from) noexcept
    : ListNvmeSubsystemsRequest() {
    *this = ::std::move(from);
  }

  inline ListNvmeSubsystemsRequest& operator=(const ListNvmeSubsystemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeSubsystemsRequest& operator=(ListNvmeSubsystemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeSubsystemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeSubsystemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListNvmeSubsystemsRequest*>(
               &_ListNvmeSubsystemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListNvmeSubsystemsRequest& a, ListNvmeSubsystemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeSubsystemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeSubsystemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeSubsystemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeSubsystemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeSubsystemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeSubsystemsRequest& from) {
    ListNvmeSubsystemsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeSubsystemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeSubsystemsRequest";
  }
  protected:
  explicit ListNvmeSubsystemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeSubsystemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeSubsystemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeSubsystemsResponse) */ {
 public:
  inline ListNvmeSubsystemsResponse() : ListNvmeSubsystemsResponse(nullptr) {}
  ~ListNvmeSubsystemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeSubsystemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeSubsystemsResponse(const ListNvmeSubsystemsResponse& from);
  ListNvmeSubsystemsResponse(ListNvmeSubsystemsResponse&& from) noexcept
    : ListNvmeSubsystemsResponse() {
    *this = ::std::move(from);
  }

  inline ListNvmeSubsystemsResponse& operator=(const ListNvmeSubsystemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeSubsystemsResponse& operator=(ListNvmeSubsystemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeSubsystemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeSubsystemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListNvmeSubsystemsResponse*>(
               &_ListNvmeSubsystemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListNvmeSubsystemsResponse& a, ListNvmeSubsystemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeSubsystemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeSubsystemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeSubsystemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeSubsystemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeSubsystemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeSubsystemsResponse& from) {
    ListNvmeSubsystemsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeSubsystemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeSubsystemsResponse";
  }
  protected:
  explicit ListNvmeSubsystemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeSubsystemsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
  int nvme_subsystems_size() const;
  private:
  int _internal_nvme_subsystems_size() const;
  public:
  void clear_nvme_subsystems();
  ::opi_api::storage::v1::NvmeSubsystem* mutable_nvme_subsystems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeSubsystem >*
      mutable_nvme_subsystems();
  private:
  const ::opi_api::storage::v1::NvmeSubsystem& _internal_nvme_subsystems(int index) const;
  ::opi_api::storage::v1::NvmeSubsystem* _internal_add_nvme_subsystems();
  public:
  const ::opi_api::storage::v1::NvmeSubsystem& nvme_subsystems(int index) const;
  ::opi_api::storage::v1::NvmeSubsystem* add_nvme_subsystems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeSubsystem >&
      nvme_subsystems() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeSubsystemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeSubsystem > nvme_subsystems_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class GetNvmeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNvmeSubsystemRequest) */ {
 public:
  inline GetNvmeSubsystemRequest() : GetNvmeSubsystemRequest(nullptr) {}
  ~GetNvmeSubsystemRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNvmeSubsystemRequest(const GetNvmeSubsystemRequest& from);
  GetNvmeSubsystemRequest(GetNvmeSubsystemRequest&& from) noexcept
    : GetNvmeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline GetNvmeSubsystemRequest& operator=(const GetNvmeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNvmeSubsystemRequest& operator=(GetNvmeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNvmeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNvmeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const GetNvmeSubsystemRequest*>(
               &_GetNvmeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetNvmeSubsystemRequest& a, GetNvmeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNvmeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNvmeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNvmeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNvmeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNvmeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNvmeSubsystemRequest& from) {
    GetNvmeSubsystemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNvmeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNvmeSubsystemRequest";
  }
  protected:
  explicit GetNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNvmeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeSubsystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeSubsystemRequest) */ {
 public:
  inline StatsNvmeSubsystemRequest() : StatsNvmeSubsystemRequest(nullptr) {}
  ~StatsNvmeSubsystemRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeSubsystemRequest(const StatsNvmeSubsystemRequest& from);
  StatsNvmeSubsystemRequest(StatsNvmeSubsystemRequest&& from) noexcept
    : StatsNvmeSubsystemRequest() {
    *this = ::std::move(from);
  }

  inline StatsNvmeSubsystemRequest& operator=(const StatsNvmeSubsystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeSubsystemRequest& operator=(StatsNvmeSubsystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeSubsystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeSubsystemRequest* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeSubsystemRequest*>(
               &_StatsNvmeSubsystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StatsNvmeSubsystemRequest& a, StatsNvmeSubsystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeSubsystemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeSubsystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeSubsystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeSubsystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeSubsystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeSubsystemRequest& from) {
    StatsNvmeSubsystemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeSubsystemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeSubsystemRequest";
  }
  protected:
  explicit StatsNvmeSubsystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeSubsystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeSubsystemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeSubsystemResponse) */ {
 public:
  inline StatsNvmeSubsystemResponse() : StatsNvmeSubsystemResponse(nullptr) {}
  ~StatsNvmeSubsystemResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeSubsystemResponse(const StatsNvmeSubsystemResponse& from);
  StatsNvmeSubsystemResponse(StatsNvmeSubsystemResponse&& from) noexcept
    : StatsNvmeSubsystemResponse() {
    *this = ::std::move(from);
  }

  inline StatsNvmeSubsystemResponse& operator=(const StatsNvmeSubsystemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeSubsystemResponse& operator=(StatsNvmeSubsystemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeSubsystemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeSubsystemResponse* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeSubsystemResponse*>(
               &_StatsNvmeSubsystemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StatsNvmeSubsystemResponse& a, StatsNvmeSubsystemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeSubsystemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeSubsystemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeSubsystemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeSubsystemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeSubsystemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeSubsystemResponse& from) {
    StatsNvmeSubsystemResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeSubsystemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeSubsystemResponse";
  }
  protected:
  explicit StatsNvmeSubsystemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeSubsystemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::VolumeStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class CreateNvmeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNvmeControllerRequest) */ {
 public:
  inline CreateNvmeControllerRequest() : CreateNvmeControllerRequest(nullptr) {}
  ~CreateNvmeControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNvmeControllerRequest(const CreateNvmeControllerRequest& from);
  CreateNvmeControllerRequest(CreateNvmeControllerRequest&& from) noexcept
    : CreateNvmeControllerRequest() {
    *this = ::std::move(from);
  }

  inline CreateNvmeControllerRequest& operator=(const CreateNvmeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNvmeControllerRequest& operator=(CreateNvmeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNvmeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNvmeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNvmeControllerRequest*>(
               &_CreateNvmeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateNvmeControllerRequest& a, CreateNvmeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNvmeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNvmeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNvmeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNvmeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNvmeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNvmeControllerRequest& from) {
    CreateNvmeControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNvmeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNvmeControllerRequest";
  }
  protected:
  explicit CreateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kNvmeControllerIdFieldNumber = 3,
    kNvmeControllerFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string nvme_controller_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_nvme_controller_id();
  const std::string& nvme_controller_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nvme_controller_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nvme_controller_id();
  PROTOBUF_NODISCARD std::string* release_nvme_controller_id();
  void set_allocated_nvme_controller_id(std::string* nvme_controller_id);
  private:
  const std::string& _internal_nvme_controller_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nvme_controller_id(const std::string& value);
  std::string* _internal_mutable_nvme_controller_id();
  public:

  // .opi_api.storage.v1.NvmeController nvme_controller = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_controller() const;
  private:
  bool _internal_has_nvme_controller() const;
  public:
  void clear_nvme_controller();
  const ::opi_api::storage::v1::NvmeController& nvme_controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeController* release_nvme_controller();
  ::opi_api::storage::v1::NvmeController* mutable_nvme_controller();
  void set_allocated_nvme_controller(::opi_api::storage::v1::NvmeController* nvme_controller);
  private:
  const ::opi_api::storage::v1::NvmeController& _internal_nvme_controller() const;
  ::opi_api::storage::v1::NvmeController* _internal_mutable_nvme_controller();
  public:
  void unsafe_arena_set_allocated_nvme_controller(
      ::opi_api::storage::v1::NvmeController* nvme_controller);
  ::opi_api::storage::v1::NvmeController* unsafe_arena_release_nvme_controller();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNvmeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nvme_controller_id_;
    ::opi_api::storage::v1::NvmeController* nvme_controller_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class DeleteNvmeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNvmeControllerRequest) */ {
 public:
  inline DeleteNvmeControllerRequest() : DeleteNvmeControllerRequest(nullptr) {}
  ~DeleteNvmeControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNvmeControllerRequest(const DeleteNvmeControllerRequest& from);
  DeleteNvmeControllerRequest(DeleteNvmeControllerRequest&& from) noexcept
    : DeleteNvmeControllerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNvmeControllerRequest& operator=(const DeleteNvmeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNvmeControllerRequest& operator=(DeleteNvmeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNvmeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNvmeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNvmeControllerRequest*>(
               &_DeleteNvmeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteNvmeControllerRequest& a, DeleteNvmeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNvmeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNvmeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNvmeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNvmeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNvmeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteNvmeControllerRequest& from) {
    DeleteNvmeControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNvmeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNvmeControllerRequest";
  }
  protected:
  explicit DeleteNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNvmeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class UpdateNvmeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNvmeControllerRequest) */ {
 public:
  inline UpdateNvmeControllerRequest() : UpdateNvmeControllerRequest(nullptr) {}
  ~UpdateNvmeControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNvmeControllerRequest(const UpdateNvmeControllerRequest& from);
  UpdateNvmeControllerRequest(UpdateNvmeControllerRequest&& from) noexcept
    : UpdateNvmeControllerRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNvmeControllerRequest& operator=(const UpdateNvmeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNvmeControllerRequest& operator=(UpdateNvmeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNvmeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNvmeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNvmeControllerRequest*>(
               &_UpdateNvmeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateNvmeControllerRequest& a, UpdateNvmeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNvmeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNvmeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNvmeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNvmeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNvmeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateNvmeControllerRequest& from) {
    UpdateNvmeControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNvmeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNvmeControllerRequest";
  }
  protected:
  explicit UpdateNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeControllerFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_controller() const;
  private:
  bool _internal_has_nvme_controller() const;
  public:
  void clear_nvme_controller();
  const ::opi_api::storage::v1::NvmeController& nvme_controller() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeController* release_nvme_controller();
  ::opi_api::storage::v1::NvmeController* mutable_nvme_controller();
  void set_allocated_nvme_controller(::opi_api::storage::v1::NvmeController* nvme_controller);
  private:
  const ::opi_api::storage::v1::NvmeController& _internal_nvme_controller() const;
  ::opi_api::storage::v1::NvmeController* _internal_mutable_nvme_controller();
  public:
  void unsafe_arena_set_allocated_nvme_controller(
      ::opi_api::storage::v1::NvmeController* nvme_controller);
  ::opi_api::storage::v1::NvmeController* unsafe_arena_release_nvme_controller();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNvmeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::NvmeController* nvme_controller_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeControllersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeControllersRequest) */ {
 public:
  inline ListNvmeControllersRequest() : ListNvmeControllersRequest(nullptr) {}
  ~ListNvmeControllersRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeControllersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeControllersRequest(const ListNvmeControllersRequest& from);
  ListNvmeControllersRequest(ListNvmeControllersRequest&& from) noexcept
    : ListNvmeControllersRequest() {
    *this = ::std::move(from);
  }

  inline ListNvmeControllersRequest& operator=(const ListNvmeControllersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeControllersRequest& operator=(ListNvmeControllersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeControllersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeControllersRequest* internal_default_instance() {
    return reinterpret_cast<const ListNvmeControllersRequest*>(
               &_ListNvmeControllersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListNvmeControllersRequest& a, ListNvmeControllersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeControllersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeControllersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeControllersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeControllersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeControllersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeControllersRequest& from) {
    ListNvmeControllersRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeControllersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeControllersRequest";
  }
  protected:
  explicit ListNvmeControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeControllersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeControllersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeControllersResponse) */ {
 public:
  inline ListNvmeControllersResponse() : ListNvmeControllersResponse(nullptr) {}
  ~ListNvmeControllersResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeControllersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeControllersResponse(const ListNvmeControllersResponse& from);
  ListNvmeControllersResponse(ListNvmeControllersResponse&& from) noexcept
    : ListNvmeControllersResponse() {
    *this = ::std::move(from);
  }

  inline ListNvmeControllersResponse& operator=(const ListNvmeControllersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeControllersResponse& operator=(ListNvmeControllersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeControllersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeControllersResponse* internal_default_instance() {
    return reinterpret_cast<const ListNvmeControllersResponse*>(
               &_ListNvmeControllersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ListNvmeControllersResponse& a, ListNvmeControllersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeControllersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeControllersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeControllersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeControllersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeControllersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeControllersResponse& from) {
    ListNvmeControllersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeControllersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeControllersResponse";
  }
  protected:
  explicit ListNvmeControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeControllersFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
  int nvme_controllers_size() const;
  private:
  int _internal_nvme_controllers_size() const;
  public:
  void clear_nvme_controllers();
  ::opi_api::storage::v1::NvmeController* mutable_nvme_controllers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeController >*
      mutable_nvme_controllers();
  private:
  const ::opi_api::storage::v1::NvmeController& _internal_nvme_controllers(int index) const;
  ::opi_api::storage::v1::NvmeController* _internal_add_nvme_controllers();
  public:
  const ::opi_api::storage::v1::NvmeController& nvme_controllers(int index) const;
  ::opi_api::storage::v1::NvmeController* add_nvme_controllers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeController >&
      nvme_controllers() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeControllersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeController > nvme_controllers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class GetNvmeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNvmeControllerRequest) */ {
 public:
  inline GetNvmeControllerRequest() : GetNvmeControllerRequest(nullptr) {}
  ~GetNvmeControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNvmeControllerRequest(const GetNvmeControllerRequest& from);
  GetNvmeControllerRequest(GetNvmeControllerRequest&& from) noexcept
    : GetNvmeControllerRequest() {
    *this = ::std::move(from);
  }

  inline GetNvmeControllerRequest& operator=(const GetNvmeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNvmeControllerRequest& operator=(GetNvmeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNvmeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNvmeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const GetNvmeControllerRequest*>(
               &_GetNvmeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetNvmeControllerRequest& a, GetNvmeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNvmeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNvmeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNvmeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNvmeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNvmeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNvmeControllerRequest& from) {
    GetNvmeControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNvmeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNvmeControllerRequest";
  }
  protected:
  explicit GetNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNvmeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeControllerRequest) */ {
 public:
  inline StatsNvmeControllerRequest() : StatsNvmeControllerRequest(nullptr) {}
  ~StatsNvmeControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeControllerRequest(const StatsNvmeControllerRequest& from);
  StatsNvmeControllerRequest(StatsNvmeControllerRequest&& from) noexcept
    : StatsNvmeControllerRequest() {
    *this = ::std::move(from);
  }

  inline StatsNvmeControllerRequest& operator=(const StatsNvmeControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeControllerRequest& operator=(StatsNvmeControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeControllerRequest* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeControllerRequest*>(
               &_StatsNvmeControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StatsNvmeControllerRequest& a, StatsNvmeControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeControllerRequest& from) {
    StatsNvmeControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeControllerRequest";
  }
  protected:
  explicit StatsNvmeControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeControllerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeControllerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeControllerResponse) */ {
 public:
  inline StatsNvmeControllerResponse() : StatsNvmeControllerResponse(nullptr) {}
  ~StatsNvmeControllerResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeControllerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeControllerResponse(const StatsNvmeControllerResponse& from);
  StatsNvmeControllerResponse(StatsNvmeControllerResponse&& from) noexcept
    : StatsNvmeControllerResponse() {
    *this = ::std::move(from);
  }

  inline StatsNvmeControllerResponse& operator=(const StatsNvmeControllerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeControllerResponse& operator=(StatsNvmeControllerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeControllerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeControllerResponse* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeControllerResponse*>(
               &_StatsNvmeControllerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StatsNvmeControllerResponse& a, StatsNvmeControllerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeControllerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeControllerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeControllerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeControllerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeControllerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeControllerResponse& from) {
    StatsNvmeControllerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeControllerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeControllerResponse";
  }
  protected:
  explicit StatsNvmeControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeControllerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::VolumeStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class CreateNvmeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateNvmeNamespaceRequest) */ {
 public:
  inline CreateNvmeNamespaceRequest() : CreateNvmeNamespaceRequest(nullptr) {}
  ~CreateNvmeNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNvmeNamespaceRequest(const CreateNvmeNamespaceRequest& from);
  CreateNvmeNamespaceRequest(CreateNvmeNamespaceRequest&& from) noexcept
    : CreateNvmeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline CreateNvmeNamespaceRequest& operator=(const CreateNvmeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNvmeNamespaceRequest& operator=(CreateNvmeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNvmeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNvmeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNvmeNamespaceRequest*>(
               &_CreateNvmeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateNvmeNamespaceRequest& a, CreateNvmeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNvmeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNvmeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNvmeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNvmeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNvmeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNvmeNamespaceRequest& from) {
    CreateNvmeNamespaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNvmeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateNvmeNamespaceRequest";
  }
  protected:
  explicit CreateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kNvmeNamespaceIdFieldNumber = 3,
    kNvmeNamespaceFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string nvme_namespace_id = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_nvme_namespace_id();
  const std::string& nvme_namespace_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nvme_namespace_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nvme_namespace_id();
  PROTOBUF_NODISCARD std::string* release_nvme_namespace_id();
  void set_allocated_nvme_namespace_id(std::string* nvme_namespace_id);
  private:
  const std::string& _internal_nvme_namespace_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nvme_namespace_id(const std::string& value);
  std::string* _internal_mutable_nvme_namespace_id();
  public:

  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_namespace() const;
  private:
  bool _internal_has_nvme_namespace() const;
  public:
  void clear_nvme_namespace();
  const ::opi_api::storage::v1::NvmeNamespace& nvme_namespace() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeNamespace* release_nvme_namespace();
  ::opi_api::storage::v1::NvmeNamespace* mutable_nvme_namespace();
  void set_allocated_nvme_namespace(::opi_api::storage::v1::NvmeNamespace* nvme_namespace);
  private:
  const ::opi_api::storage::v1::NvmeNamespace& _internal_nvme_namespace() const;
  ::opi_api::storage::v1::NvmeNamespace* _internal_mutable_nvme_namespace();
  public:
  void unsafe_arena_set_allocated_nvme_namespace(
      ::opi_api::storage::v1::NvmeNamespace* nvme_namespace);
  ::opi_api::storage::v1::NvmeNamespace* unsafe_arena_release_nvme_namespace();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateNvmeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nvme_namespace_id_;
    ::opi_api::storage::v1::NvmeNamespace* nvme_namespace_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class DeleteNvmeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteNvmeNamespaceRequest) */ {
 public:
  inline DeleteNvmeNamespaceRequest() : DeleteNvmeNamespaceRequest(nullptr) {}
  ~DeleteNvmeNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNvmeNamespaceRequest(const DeleteNvmeNamespaceRequest& from);
  DeleteNvmeNamespaceRequest(DeleteNvmeNamespaceRequest&& from) noexcept
    : DeleteNvmeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteNvmeNamespaceRequest& operator=(const DeleteNvmeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNvmeNamespaceRequest& operator=(DeleteNvmeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNvmeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNvmeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteNvmeNamespaceRequest*>(
               &_DeleteNvmeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DeleteNvmeNamespaceRequest& a, DeleteNvmeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNvmeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNvmeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNvmeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNvmeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNvmeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteNvmeNamespaceRequest& from) {
    DeleteNvmeNamespaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNvmeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteNvmeNamespaceRequest";
  }
  protected:
  explicit DeleteNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteNvmeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class UpdateNvmeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateNvmeNamespaceRequest) */ {
 public:
  inline UpdateNvmeNamespaceRequest() : UpdateNvmeNamespaceRequest(nullptr) {}
  ~UpdateNvmeNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNvmeNamespaceRequest(const UpdateNvmeNamespaceRequest& from);
  UpdateNvmeNamespaceRequest(UpdateNvmeNamespaceRequest&& from) noexcept
    : UpdateNvmeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNvmeNamespaceRequest& operator=(const UpdateNvmeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNvmeNamespaceRequest& operator=(UpdateNvmeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNvmeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNvmeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNvmeNamespaceRequest*>(
               &_UpdateNvmeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateNvmeNamespaceRequest& a, UpdateNvmeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNvmeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNvmeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNvmeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNvmeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNvmeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateNvmeNamespaceRequest& from) {
    UpdateNvmeNamespaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNvmeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateNvmeNamespaceRequest";
  }
  protected:
  explicit UpdateNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeNamespaceFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_nvme_namespace() const;
  private:
  bool _internal_has_nvme_namespace() const;
  public:
  void clear_nvme_namespace();
  const ::opi_api::storage::v1::NvmeNamespace& nvme_namespace() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::NvmeNamespace* release_nvme_namespace();
  ::opi_api::storage::v1::NvmeNamespace* mutable_nvme_namespace();
  void set_allocated_nvme_namespace(::opi_api::storage::v1::NvmeNamespace* nvme_namespace);
  private:
  const ::opi_api::storage::v1::NvmeNamespace& _internal_nvme_namespace() const;
  ::opi_api::storage::v1::NvmeNamespace* _internal_mutable_nvme_namespace();
  public:
  void unsafe_arena_set_allocated_nvme_namespace(
      ::opi_api::storage::v1::NvmeNamespace* nvme_namespace);
  ::opi_api::storage::v1::NvmeNamespace* unsafe_arena_release_nvme_namespace();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateNvmeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::NvmeNamespace* nvme_namespace_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeNamespacesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeNamespacesRequest) */ {
 public:
  inline ListNvmeNamespacesRequest() : ListNvmeNamespacesRequest(nullptr) {}
  ~ListNvmeNamespacesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeNamespacesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeNamespacesRequest(const ListNvmeNamespacesRequest& from);
  ListNvmeNamespacesRequest(ListNvmeNamespacesRequest&& from) noexcept
    : ListNvmeNamespacesRequest() {
    *this = ::std::move(from);
  }

  inline ListNvmeNamespacesRequest& operator=(const ListNvmeNamespacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeNamespacesRequest& operator=(ListNvmeNamespacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeNamespacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeNamespacesRequest* internal_default_instance() {
    return reinterpret_cast<const ListNvmeNamespacesRequest*>(
               &_ListNvmeNamespacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListNvmeNamespacesRequest& a, ListNvmeNamespacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeNamespacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeNamespacesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeNamespacesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeNamespacesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeNamespacesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeNamespacesRequest& from) {
    ListNvmeNamespacesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeNamespacesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeNamespacesRequest";
  }
  protected:
  explicit ListNvmeNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeNamespacesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class ListNvmeNamespacesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListNvmeNamespacesResponse) */ {
 public:
  inline ListNvmeNamespacesResponse() : ListNvmeNamespacesResponse(nullptr) {}
  ~ListNvmeNamespacesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListNvmeNamespacesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNvmeNamespacesResponse(const ListNvmeNamespacesResponse& from);
  ListNvmeNamespacesResponse(ListNvmeNamespacesResponse&& from) noexcept
    : ListNvmeNamespacesResponse() {
    *this = ::std::move(from);
  }

  inline ListNvmeNamespacesResponse& operator=(const ListNvmeNamespacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNvmeNamespacesResponse& operator=(ListNvmeNamespacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNvmeNamespacesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNvmeNamespacesResponse* internal_default_instance() {
    return reinterpret_cast<const ListNvmeNamespacesResponse*>(
               &_ListNvmeNamespacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ListNvmeNamespacesResponse& a, ListNvmeNamespacesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNvmeNamespacesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNvmeNamespacesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNvmeNamespacesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNvmeNamespacesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNvmeNamespacesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNvmeNamespacesResponse& from) {
    ListNvmeNamespacesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNvmeNamespacesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListNvmeNamespacesResponse";
  }
  protected:
  explicit ListNvmeNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNvmeNamespacesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
  int nvme_namespaces_size() const;
  private:
  int _internal_nvme_namespaces_size() const;
  public:
  void clear_nvme_namespaces();
  ::opi_api::storage::v1::NvmeNamespace* mutable_nvme_namespaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeNamespace >*
      mutable_nvme_namespaces();
  private:
  const ::opi_api::storage::v1::NvmeNamespace& _internal_nvme_namespaces(int index) const;
  ::opi_api::storage::v1::NvmeNamespace* _internal_add_nvme_namespaces();
  public:
  const ::opi_api::storage::v1::NvmeNamespace& nvme_namespaces(int index) const;
  ::opi_api::storage::v1::NvmeNamespace* add_nvme_namespaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeNamespace >&
      nvme_namespaces() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListNvmeNamespacesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeNamespace > nvme_namespaces_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class GetNvmeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetNvmeNamespaceRequest) */ {
 public:
  inline GetNvmeNamespaceRequest() : GetNvmeNamespaceRequest(nullptr) {}
  ~GetNvmeNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR GetNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNvmeNamespaceRequest(const GetNvmeNamespaceRequest& from);
  GetNvmeNamespaceRequest(GetNvmeNamespaceRequest&& from) noexcept
    : GetNvmeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline GetNvmeNamespaceRequest& operator=(const GetNvmeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNvmeNamespaceRequest& operator=(GetNvmeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNvmeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNvmeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const GetNvmeNamespaceRequest*>(
               &_GetNvmeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetNvmeNamespaceRequest& a, GetNvmeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNvmeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNvmeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNvmeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNvmeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNvmeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNvmeNamespaceRequest& from) {
    GetNvmeNamespaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNvmeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetNvmeNamespaceRequest";
  }
  protected:
  explicit GetNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetNvmeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeNamespaceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeNamespaceRequest) */ {
 public:
  inline StatsNvmeNamespaceRequest() : StatsNvmeNamespaceRequest(nullptr) {}
  ~StatsNvmeNamespaceRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeNamespaceRequest(const StatsNvmeNamespaceRequest& from);
  StatsNvmeNamespaceRequest(StatsNvmeNamespaceRequest&& from) noexcept
    : StatsNvmeNamespaceRequest() {
    *this = ::std::move(from);
  }

  inline StatsNvmeNamespaceRequest& operator=(const StatsNvmeNamespaceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeNamespaceRequest& operator=(StatsNvmeNamespaceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeNamespaceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeNamespaceRequest* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeNamespaceRequest*>(
               &_StatsNvmeNamespaceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(StatsNvmeNamespaceRequest& a, StatsNvmeNamespaceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeNamespaceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeNamespaceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeNamespaceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeNamespaceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeNamespaceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeNamespaceRequest& from) {
    StatsNvmeNamespaceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeNamespaceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeNamespaceRequest";
  }
  protected:
  explicit StatsNvmeNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeNamespaceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// -------------------------------------------------------------------

class StatsNvmeNamespaceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsNvmeNamespaceResponse) */ {
 public:
  inline StatsNvmeNamespaceResponse() : StatsNvmeNamespaceResponse(nullptr) {}
  ~StatsNvmeNamespaceResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsNvmeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsNvmeNamespaceResponse(const StatsNvmeNamespaceResponse& from);
  StatsNvmeNamespaceResponse(StatsNvmeNamespaceResponse&& from) noexcept
    : StatsNvmeNamespaceResponse() {
    *this = ::std::move(from);
  }

  inline StatsNvmeNamespaceResponse& operator=(const StatsNvmeNamespaceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsNvmeNamespaceResponse& operator=(StatsNvmeNamespaceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsNvmeNamespaceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsNvmeNamespaceResponse* internal_default_instance() {
    return reinterpret_cast<const StatsNvmeNamespaceResponse*>(
               &_StatsNvmeNamespaceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(StatsNvmeNamespaceResponse& a, StatsNvmeNamespaceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsNvmeNamespaceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsNvmeNamespaceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsNvmeNamespaceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsNvmeNamespaceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsNvmeNamespaceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsNvmeNamespaceResponse& from) {
    StatsNvmeNamespaceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsNvmeNamespaceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsNvmeNamespaceResponse";
  }
  protected:
  explicit StatsNvmeNamespaceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsNvmeNamespaceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::VolumeStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_frontend_5fnvme_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NvmeSubsystem

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void NvmeSubsystem::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NvmeSubsystem::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystem::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystem.name)
}
inline std::string* NvmeSubsystem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystem.name)
  return _s;
}
inline const std::string& NvmeSubsystem::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NvmeSubsystem::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystem::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystem::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystem.name)
  return _impl_.name_.Release();
}
inline void NvmeSubsystem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystem.name)
}

// .opi_api.storage.v1.NvmeSubsystemSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool NvmeSubsystem::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool NvmeSubsystem::has_spec() const {
  return _internal_has_spec();
}
inline void NvmeSubsystem::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeSubsystemSpec& NvmeSubsystem::_internal_spec() const {
  const ::opi_api::storage::v1::NvmeSubsystemSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeSubsystemSpec&>(
      ::opi_api::storage::v1::_NvmeSubsystemSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeSubsystemSpec& NvmeSubsystem::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystem.spec)
  return _internal_spec();
}
inline void NvmeSubsystem::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NvmeSubsystemSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeSubsystem.spec)
}
inline ::opi_api::storage::v1::NvmeSubsystemSpec* NvmeSubsystem::release_spec() {
  
  ::opi_api::storage::v1::NvmeSubsystemSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystemSpec* NvmeSubsystem::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystem.spec)
  
  ::opi_api::storage::v1::NvmeSubsystemSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystemSpec* NvmeSubsystem::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystemSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::opi_api::storage::v1::NvmeSubsystemSpec* NvmeSubsystem::mutable_spec() {
  ::opi_api::storage::v1::NvmeSubsystemSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystem.spec)
  return _msg;
}
inline void NvmeSubsystem::set_allocated_spec(::opi_api::storage::v1::NvmeSubsystemSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystem.spec)
}

// .opi_api.storage.v1.NvmeSubsystemStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool NvmeSubsystem::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool NvmeSubsystem::has_status() const {
  return _internal_has_status();
}
inline void NvmeSubsystem::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeSubsystemStatus& NvmeSubsystem::_internal_status() const {
  const ::opi_api::storage::v1::NvmeSubsystemStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeSubsystemStatus&>(
      ::opi_api::storage::v1::_NvmeSubsystemStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeSubsystemStatus& NvmeSubsystem::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystem.status)
  return _internal_status();
}
inline void NvmeSubsystem::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NvmeSubsystemStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeSubsystem.status)
}
inline ::opi_api::storage::v1::NvmeSubsystemStatus* NvmeSubsystem::release_status() {
  
  ::opi_api::storage::v1::NvmeSubsystemStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystemStatus* NvmeSubsystem::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystem.status)
  
  ::opi_api::storage::v1::NvmeSubsystemStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystemStatus* NvmeSubsystem::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystemStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::opi_api::storage::v1::NvmeSubsystemStatus* NvmeSubsystem::mutable_status() {
  ::opi_api::storage::v1::NvmeSubsystemStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystem.status)
  return _msg;
}
inline void NvmeSubsystem::set_allocated_status(::opi_api::storage::v1::NvmeSubsystemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystem.status)
}

// -------------------------------------------------------------------

// NvmeSubsystemSpec

// string nqn = 1 [(.google.api.field_behavior) = REQUIRED];
inline void NvmeSubsystemSpec::clear_nqn() {
  _impl_.nqn_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemSpec::nqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemSpec.nqn)
  return _internal_nqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemSpec::set_nqn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nqn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemSpec.nqn)
}
inline std::string* NvmeSubsystemSpec::mutable_nqn() {
  std::string* _s = _internal_mutable_nqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemSpec.nqn)
  return _s;
}
inline const std::string& NvmeSubsystemSpec::_internal_nqn() const {
  return _impl_.nqn_.Get();
}
inline void NvmeSubsystemSpec::_internal_set_nqn(const std::string& value) {
  
  _impl_.nqn_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::_internal_mutable_nqn() {
  
  return _impl_.nqn_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::release_nqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemSpec.nqn)
  return _impl_.nqn_.Release();
}
inline void NvmeSubsystemSpec::set_allocated_nqn(std::string* nqn) {
  if (nqn != nullptr) {
    
  } else {
    
  }
  _impl_.nqn_.SetAllocated(nqn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nqn_.IsDefault()) {
    _impl_.nqn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemSpec.nqn)
}

// string serial_number = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeSubsystemSpec::clear_serial_number() {
  _impl_.serial_number_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemSpec::serial_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemSpec.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemSpec::set_serial_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serial_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemSpec.serial_number)
}
inline std::string* NvmeSubsystemSpec::mutable_serial_number() {
  std::string* _s = _internal_mutable_serial_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemSpec.serial_number)
  return _s;
}
inline const std::string& NvmeSubsystemSpec::_internal_serial_number() const {
  return _impl_.serial_number_.Get();
}
inline void NvmeSubsystemSpec::_internal_set_serial_number(const std::string& value) {
  
  _impl_.serial_number_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::_internal_mutable_serial_number() {
  
  return _impl_.serial_number_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::release_serial_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemSpec.serial_number)
  return _impl_.serial_number_.Release();
}
inline void NvmeSubsystemSpec::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    
  } else {
    
  }
  _impl_.serial_number_.SetAllocated(serial_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_number_.IsDefault()) {
    _impl_.serial_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemSpec.serial_number)
}

// string model_number = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeSubsystemSpec::clear_model_number() {
  _impl_.model_number_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemSpec::model_number() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemSpec.model_number)
  return _internal_model_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemSpec::set_model_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemSpec.model_number)
}
inline std::string* NvmeSubsystemSpec::mutable_model_number() {
  std::string* _s = _internal_mutable_model_number();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemSpec.model_number)
  return _s;
}
inline const std::string& NvmeSubsystemSpec::_internal_model_number() const {
  return _impl_.model_number_.Get();
}
inline void NvmeSubsystemSpec::_internal_set_model_number(const std::string& value) {
  
  _impl_.model_number_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::_internal_mutable_model_number() {
  
  return _impl_.model_number_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::release_model_number() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemSpec.model_number)
  return _impl_.model_number_.Release();
}
inline void NvmeSubsystemSpec::set_allocated_model_number(std::string* model_number) {
  if (model_number != nullptr) {
    
  } else {
    
  }
  _impl_.model_number_.SetAllocated(model_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_number_.IsDefault()) {
    _impl_.model_number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemSpec.model_number)
}

// int64 max_namespaces = 4 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeSubsystemSpec::clear_max_namespaces() {
  _impl_.max_namespaces_ = int64_t{0};
}
inline int64_t NvmeSubsystemSpec::_internal_max_namespaces() const {
  return _impl_.max_namespaces_;
}
inline int64_t NvmeSubsystemSpec::max_namespaces() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemSpec.max_namespaces)
  return _internal_max_namespaces();
}
inline void NvmeSubsystemSpec::_internal_set_max_namespaces(int64_t value) {
  
  _impl_.max_namespaces_ = value;
}
inline void NvmeSubsystemSpec::set_max_namespaces(int64_t value) {
  _internal_set_max_namespaces(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemSpec.max_namespaces)
}

// string hostnqn = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeSubsystemSpec::clear_hostnqn() {
  _impl_.hostnqn_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemSpec::hostnqn() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemSpec.hostnqn)
  return _internal_hostnqn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemSpec::set_hostnqn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostnqn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemSpec.hostnqn)
}
inline std::string* NvmeSubsystemSpec::mutable_hostnqn() {
  std::string* _s = _internal_mutable_hostnqn();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemSpec.hostnqn)
  return _s;
}
inline const std::string& NvmeSubsystemSpec::_internal_hostnqn() const {
  return _impl_.hostnqn_.Get();
}
inline void NvmeSubsystemSpec::_internal_set_hostnqn(const std::string& value) {
  
  _impl_.hostnqn_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::_internal_mutable_hostnqn() {
  
  return _impl_.hostnqn_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::release_hostnqn() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemSpec.hostnqn)
  return _impl_.hostnqn_.Release();
}
inline void NvmeSubsystemSpec::set_allocated_hostnqn(std::string* hostnqn) {
  if (hostnqn != nullptr) {
    
  } else {
    
  }
  _impl_.hostnqn_.SetAllocated(hostnqn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostnqn_.IsDefault()) {
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemSpec.hostnqn)
}

// bytes psk = 6 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeSubsystemSpec::clear_psk() {
  _impl_.psk_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemSpec::psk() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemSpec.psk)
  return _internal_psk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemSpec::set_psk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.psk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemSpec.psk)
}
inline std::string* NvmeSubsystemSpec::mutable_psk() {
  std::string* _s = _internal_mutable_psk();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemSpec.psk)
  return _s;
}
inline const std::string& NvmeSubsystemSpec::_internal_psk() const {
  return _impl_.psk_.Get();
}
inline void NvmeSubsystemSpec::_internal_set_psk(const std::string& value) {
  
  _impl_.psk_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::_internal_mutable_psk() {
  
  return _impl_.psk_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemSpec::release_psk() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemSpec.psk)
  return _impl_.psk_.Release();
}
inline void NvmeSubsystemSpec::set_allocated_psk(std::string* psk) {
  if (psk != nullptr) {
    
  } else {
    
  }
  _impl_.psk_.SetAllocated(psk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.psk_.IsDefault()) {
    _impl_.psk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemSpec.psk)
}

// -------------------------------------------------------------------

// NvmeSubsystemStatus

// string firmware_revision = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeSubsystemStatus::clear_firmware_revision() {
  _impl_.firmware_revision_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemStatus::firmware_revision() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision)
  return _internal_firmware_revision();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemStatus::set_firmware_revision(ArgT0&& arg0, ArgT... args) {
 
 _impl_.firmware_revision_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision)
}
inline std::string* NvmeSubsystemStatus::mutable_firmware_revision() {
  std::string* _s = _internal_mutable_firmware_revision();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision)
  return _s;
}
inline const std::string& NvmeSubsystemStatus::_internal_firmware_revision() const {
  return _impl_.firmware_revision_.Get();
}
inline void NvmeSubsystemStatus::_internal_set_firmware_revision(const std::string& value) {
  
  _impl_.firmware_revision_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemStatus::_internal_mutable_firmware_revision() {
  
  return _impl_.firmware_revision_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemStatus::release_firmware_revision() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision)
  return _impl_.firmware_revision_.Release();
}
inline void NvmeSubsystemStatus::set_allocated_firmware_revision(std::string* firmware_revision) {
  if (firmware_revision != nullptr) {
    
  } else {
    
  }
  _impl_.firmware_revision_.SetAllocated(firmware_revision, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.firmware_revision_.IsDefault()) {
    _impl_.firmware_revision_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemStatus.firmware_revision)
}

// bytes fru_guid = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeSubsystemStatus::clear_fru_guid() {
  _impl_.fru_guid_.ClearToEmpty();
}
inline const std::string& NvmeSubsystemStatus::fru_guid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeSubsystemStatus.fru_guid)
  return _internal_fru_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeSubsystemStatus::set_fru_guid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fru_guid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeSubsystemStatus.fru_guid)
}
inline std::string* NvmeSubsystemStatus::mutable_fru_guid() {
  std::string* _s = _internal_mutable_fru_guid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeSubsystemStatus.fru_guid)
  return _s;
}
inline const std::string& NvmeSubsystemStatus::_internal_fru_guid() const {
  return _impl_.fru_guid_.Get();
}
inline void NvmeSubsystemStatus::_internal_set_fru_guid(const std::string& value) {
  
  _impl_.fru_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeSubsystemStatus::_internal_mutable_fru_guid() {
  
  return _impl_.fru_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeSubsystemStatus::release_fru_guid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeSubsystemStatus.fru_guid)
  return _impl_.fru_guid_.Release();
}
inline void NvmeSubsystemStatus::set_allocated_fru_guid(std::string* fru_guid) {
  if (fru_guid != nullptr) {
    
  } else {
    
  }
  _impl_.fru_guid_.SetAllocated(fru_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fru_guid_.IsDefault()) {
    _impl_.fru_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeSubsystemStatus.fru_guid)
}

// -------------------------------------------------------------------

// NvmeController

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void NvmeController::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NvmeController::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeController.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeController::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeController.name)
}
inline std::string* NvmeController::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeController.name)
  return _s;
}
inline const std::string& NvmeController::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NvmeController::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeController::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeController::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeController.name)
  return _impl_.name_.Release();
}
inline void NvmeController::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeController.name)
}

// .opi_api.storage.v1.NvmeControllerSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool NvmeController::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool NvmeController::has_spec() const {
  return _internal_has_spec();
}
inline void NvmeController::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeControllerSpec& NvmeController::_internal_spec() const {
  const ::opi_api::storage::v1::NvmeControllerSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeControllerSpec&>(
      ::opi_api::storage::v1::_NvmeControllerSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeControllerSpec& NvmeController::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeController.spec)
  return _internal_spec();
}
inline void NvmeController::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NvmeControllerSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeController.spec)
}
inline ::opi_api::storage::v1::NvmeControllerSpec* NvmeController::release_spec() {
  
  ::opi_api::storage::v1::NvmeControllerSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeControllerSpec* NvmeController::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeController.spec)
  
  ::opi_api::storage::v1::NvmeControllerSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeControllerSpec* NvmeController::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeControllerSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::opi_api::storage::v1::NvmeControllerSpec* NvmeController::mutable_spec() {
  ::opi_api::storage::v1::NvmeControllerSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeController.spec)
  return _msg;
}
inline void NvmeController::set_allocated_spec(::opi_api::storage::v1::NvmeControllerSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeController.spec)
}

// .opi_api.storage.v1.NvmeControllerStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool NvmeController::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool NvmeController::has_status() const {
  return _internal_has_status();
}
inline void NvmeController::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeControllerStatus& NvmeController::_internal_status() const {
  const ::opi_api::storage::v1::NvmeControllerStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeControllerStatus&>(
      ::opi_api::storage::v1::_NvmeControllerStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeControllerStatus& NvmeController::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeController.status)
  return _internal_status();
}
inline void NvmeController::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NvmeControllerStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeController.status)
}
inline ::opi_api::storage::v1::NvmeControllerStatus* NvmeController::release_status() {
  
  ::opi_api::storage::v1::NvmeControllerStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeControllerStatus* NvmeController::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeController.status)
  
  ::opi_api::storage::v1::NvmeControllerStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeControllerStatus* NvmeController::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeControllerStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::opi_api::storage::v1::NvmeControllerStatus* NvmeController::mutable_status() {
  ::opi_api::storage::v1::NvmeControllerStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeController.status)
  return _msg;
}
inline void NvmeController::set_allocated_status(::opi_api::storage::v1::NvmeControllerStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeController.status)
}

// -------------------------------------------------------------------

// NvmeControllerSpec

// optional int32 nvme_controller_id = 1 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeControllerSpec::_internal_has_nvme_controller_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NvmeControllerSpec::has_nvme_controller_id() const {
  return _internal_has_nvme_controller_id();
}
inline void NvmeControllerSpec::clear_nvme_controller_id() {
  _impl_.nvme_controller_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t NvmeControllerSpec::_internal_nvme_controller_id() const {
  return _impl_.nvme_controller_id_;
}
inline int32_t NvmeControllerSpec::nvme_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.nvme_controller_id)
  return _internal_nvme_controller_id();
}
inline void NvmeControllerSpec::_internal_set_nvme_controller_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nvme_controller_id_ = value;
}
inline void NvmeControllerSpec::set_nvme_controller_id(int32_t value) {
  _internal_set_nvme_controller_id(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.nvme_controller_id)
}

// .opi_api.storage.v1.NvmeTransportType trtype = 2 [(.google.api.field_behavior) = REQUIRED];
inline void NvmeControllerSpec::clear_trtype() {
  _impl_.trtype_ = 0;
}
inline ::opi_api::storage::v1::NvmeTransportType NvmeControllerSpec::_internal_trtype() const {
  return static_cast< ::opi_api::storage::v1::NvmeTransportType >(_impl_.trtype_);
}
inline ::opi_api::storage::v1::NvmeTransportType NvmeControllerSpec::trtype() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.trtype)
  return _internal_trtype();
}
inline void NvmeControllerSpec::_internal_set_trtype(::opi_api::storage::v1::NvmeTransportType value) {
  
  _impl_.trtype_ = value;
}
inline void NvmeControllerSpec::set_trtype(::opi_api::storage::v1::NvmeTransportType value) {
  _internal_set_trtype(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.trtype)
}

// .opi_api.storage.v1.PciEndpoint pcie_id = 3 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeControllerSpec::_internal_has_pcie_id() const {
  return endpoint_case() == kPcieId;
}
inline bool NvmeControllerSpec::has_pcie_id() const {
  return _internal_has_pcie_id();
}
inline void NvmeControllerSpec::set_has_pcie_id() {
  _impl_._oneof_case_[0] = kPcieId;
}
inline ::opi_api::storage::v1::PciEndpoint* NvmeControllerSpec::release_pcie_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeControllerSpec.pcie_id)
  if (_internal_has_pcie_id()) {
    clear_has_endpoint();
    ::opi_api::storage::v1::PciEndpoint* temp = _impl_.endpoint_.pcie_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.endpoint_.pcie_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::storage::v1::PciEndpoint& NvmeControllerSpec::_internal_pcie_id() const {
  return _internal_has_pcie_id()
      ? *_impl_.endpoint_.pcie_id_
      : reinterpret_cast< ::opi_api::storage::v1::PciEndpoint&>(::opi_api::storage::v1::_PciEndpoint_default_instance_);
}
inline const ::opi_api::storage::v1::PciEndpoint& NvmeControllerSpec::pcie_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.pcie_id)
  return _internal_pcie_id();
}
inline ::opi_api::storage::v1::PciEndpoint* NvmeControllerSpec::unsafe_arena_release_pcie_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.storage.v1.NvmeControllerSpec.pcie_id)
  if (_internal_has_pcie_id()) {
    clear_has_endpoint();
    ::opi_api::storage::v1::PciEndpoint* temp = _impl_.endpoint_.pcie_id_;
    _impl_.endpoint_.pcie_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NvmeControllerSpec::unsafe_arena_set_allocated_pcie_id(::opi_api::storage::v1::PciEndpoint* pcie_id) {
  clear_endpoint();
  if (pcie_id) {
    set_has_pcie_id();
    _impl_.endpoint_.pcie_id_ = pcie_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeControllerSpec.pcie_id)
}
inline ::opi_api::storage::v1::PciEndpoint* NvmeControllerSpec::_internal_mutable_pcie_id() {
  if (!_internal_has_pcie_id()) {
    clear_endpoint();
    set_has_pcie_id();
    _impl_.endpoint_.pcie_id_ = CreateMaybeMessage< ::opi_api::storage::v1::PciEndpoint >(GetArenaForAllocation());
  }
  return _impl_.endpoint_.pcie_id_;
}
inline ::opi_api::storage::v1::PciEndpoint* NvmeControllerSpec::mutable_pcie_id() {
  ::opi_api::storage::v1::PciEndpoint* _msg = _internal_mutable_pcie_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeControllerSpec.pcie_id)
  return _msg;
}

// .opi_api.storage.v1.FabricsEndpoint fabrics_id = 4 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeControllerSpec::_internal_has_fabrics_id() const {
  return endpoint_case() == kFabricsId;
}
inline bool NvmeControllerSpec::has_fabrics_id() const {
  return _internal_has_fabrics_id();
}
inline void NvmeControllerSpec::set_has_fabrics_id() {
  _impl_._oneof_case_[0] = kFabricsId;
}
inline ::opi_api::storage::v1::FabricsEndpoint* NvmeControllerSpec::release_fabrics_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeControllerSpec.fabrics_id)
  if (_internal_has_fabrics_id()) {
    clear_has_endpoint();
    ::opi_api::storage::v1::FabricsEndpoint* temp = _impl_.endpoint_.fabrics_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.endpoint_.fabrics_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opi_api::storage::v1::FabricsEndpoint& NvmeControllerSpec::_internal_fabrics_id() const {
  return _internal_has_fabrics_id()
      ? *_impl_.endpoint_.fabrics_id_
      : reinterpret_cast< ::opi_api::storage::v1::FabricsEndpoint&>(::opi_api::storage::v1::_FabricsEndpoint_default_instance_);
}
inline const ::opi_api::storage::v1::FabricsEndpoint& NvmeControllerSpec::fabrics_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.fabrics_id)
  return _internal_fabrics_id();
}
inline ::opi_api::storage::v1::FabricsEndpoint* NvmeControllerSpec::unsafe_arena_release_fabrics_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opi_api.storage.v1.NvmeControllerSpec.fabrics_id)
  if (_internal_has_fabrics_id()) {
    clear_has_endpoint();
    ::opi_api::storage::v1::FabricsEndpoint* temp = _impl_.endpoint_.fabrics_id_;
    _impl_.endpoint_.fabrics_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NvmeControllerSpec::unsafe_arena_set_allocated_fabrics_id(::opi_api::storage::v1::FabricsEndpoint* fabrics_id) {
  clear_endpoint();
  if (fabrics_id) {
    set_has_fabrics_id();
    _impl_.endpoint_.fabrics_id_ = fabrics_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeControllerSpec.fabrics_id)
}
inline ::opi_api::storage::v1::FabricsEndpoint* NvmeControllerSpec::_internal_mutable_fabrics_id() {
  if (!_internal_has_fabrics_id()) {
    clear_endpoint();
    set_has_fabrics_id();
    _impl_.endpoint_.fabrics_id_ = CreateMaybeMessage< ::opi_api::storage::v1::FabricsEndpoint >(GetArenaForAllocation());
  }
  return _impl_.endpoint_.fabrics_id_;
}
inline ::opi_api::storage::v1::FabricsEndpoint* NvmeControllerSpec::mutable_fabrics_id() {
  ::opi_api::storage::v1::FabricsEndpoint* _msg = _internal_mutable_fabrics_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeControllerSpec.fabrics_id)
  return _msg;
}

// int32 max_nsq = 5 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeControllerSpec::clear_max_nsq() {
  _impl_.max_nsq_ = 0;
}
inline int32_t NvmeControllerSpec::_internal_max_nsq() const {
  return _impl_.max_nsq_;
}
inline int32_t NvmeControllerSpec::max_nsq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.max_nsq)
  return _internal_max_nsq();
}
inline void NvmeControllerSpec::_internal_set_max_nsq(int32_t value) {
  
  _impl_.max_nsq_ = value;
}
inline void NvmeControllerSpec::set_max_nsq(int32_t value) {
  _internal_set_max_nsq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.max_nsq)
}

// int32 max_ncq = 6 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeControllerSpec::clear_max_ncq() {
  _impl_.max_ncq_ = 0;
}
inline int32_t NvmeControllerSpec::_internal_max_ncq() const {
  return _impl_.max_ncq_;
}
inline int32_t NvmeControllerSpec::max_ncq() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.max_ncq)
  return _internal_max_ncq();
}
inline void NvmeControllerSpec::_internal_set_max_ncq(int32_t value) {
  
  _impl_.max_ncq_ = value;
}
inline void NvmeControllerSpec::set_max_ncq(int32_t value) {
  _internal_set_max_ncq(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.max_ncq)
}

// int32 sqes = 7 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeControllerSpec::clear_sqes() {
  _impl_.sqes_ = 0;
}
inline int32_t NvmeControllerSpec::_internal_sqes() const {
  return _impl_.sqes_;
}
inline int32_t NvmeControllerSpec::sqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.sqes)
  return _internal_sqes();
}
inline void NvmeControllerSpec::_internal_set_sqes(int32_t value) {
  
  _impl_.sqes_ = value;
}
inline void NvmeControllerSpec::set_sqes(int32_t value) {
  _internal_set_sqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.sqes)
}

// int32 cqes = 8 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeControllerSpec::clear_cqes() {
  _impl_.cqes_ = 0;
}
inline int32_t NvmeControllerSpec::_internal_cqes() const {
  return _impl_.cqes_;
}
inline int32_t NvmeControllerSpec::cqes() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.cqes)
  return _internal_cqes();
}
inline void NvmeControllerSpec::_internal_set_cqes(int32_t value) {
  
  _impl_.cqes_ = value;
}
inline void NvmeControllerSpec::set_cqes(int32_t value) {
  _internal_set_cqes(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.cqes)
}

// int32 max_namespaces = 9 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeControllerSpec::clear_max_namespaces() {
  _impl_.max_namespaces_ = 0;
}
inline int32_t NvmeControllerSpec::_internal_max_namespaces() const {
  return _impl_.max_namespaces_;
}
inline int32_t NvmeControllerSpec::max_namespaces() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.max_namespaces)
  return _internal_max_namespaces();
}
inline void NvmeControllerSpec::_internal_set_max_namespaces(int32_t value) {
  
  _impl_.max_namespaces_ = value;
}
inline void NvmeControllerSpec::set_max_namespaces(int32_t value) {
  _internal_set_max_namespaces(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerSpec.max_namespaces)
}

// .opi_api.storage.v1.QosLimit min_limit = 10 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeControllerSpec::_internal_has_min_limit() const {
  return this != internal_default_instance() && _impl_.min_limit_ != nullptr;
}
inline bool NvmeControllerSpec::has_min_limit() const {
  return _internal_has_min_limit();
}
inline const ::opi_api::storage::v1::QosLimit& NvmeControllerSpec::_internal_min_limit() const {
  const ::opi_api::storage::v1::QosLimit* p = _impl_.min_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosLimit&>(
      ::opi_api::storage::v1::_QosLimit_default_instance_);
}
inline const ::opi_api::storage::v1::QosLimit& NvmeControllerSpec::min_limit() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.min_limit)
  return _internal_min_limit();
}
inline void NvmeControllerSpec::unsafe_arena_set_allocated_min_limit(
    ::opi_api::storage::v1::QosLimit* min_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_limit_);
  }
  _impl_.min_limit_ = min_limit;
  if (min_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeControllerSpec.min_limit)
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::release_min_limit() {
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.min_limit_;
  _impl_.min_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::unsafe_arena_release_min_limit() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeControllerSpec.min_limit)
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.min_limit_;
  _impl_.min_limit_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::_internal_mutable_min_limit() {
  
  if (_impl_.min_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosLimit>(GetArenaForAllocation());
    _impl_.min_limit_ = p;
  }
  return _impl_.min_limit_;
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::mutable_min_limit() {
  ::opi_api::storage::v1::QosLimit* _msg = _internal_mutable_min_limit();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeControllerSpec.min_limit)
  return _msg;
}
inline void NvmeControllerSpec::set_allocated_min_limit(::opi_api::storage::v1::QosLimit* min_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_limit_);
  }
  if (min_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_limit));
    if (message_arena != submessage_arena) {
      min_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_limit_ = min_limit;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeControllerSpec.min_limit)
}

// .opi_api.storage.v1.QosLimit max_limit = 11 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeControllerSpec::_internal_has_max_limit() const {
  return this != internal_default_instance() && _impl_.max_limit_ != nullptr;
}
inline bool NvmeControllerSpec::has_max_limit() const {
  return _internal_has_max_limit();
}
inline const ::opi_api::storage::v1::QosLimit& NvmeControllerSpec::_internal_max_limit() const {
  const ::opi_api::storage::v1::QosLimit* p = _impl_.max_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosLimit&>(
      ::opi_api::storage::v1::_QosLimit_default_instance_);
}
inline const ::opi_api::storage::v1::QosLimit& NvmeControllerSpec::max_limit() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerSpec.max_limit)
  return _internal_max_limit();
}
inline void NvmeControllerSpec::unsafe_arena_set_allocated_max_limit(
    ::opi_api::storage::v1::QosLimit* max_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_limit_);
  }
  _impl_.max_limit_ = max_limit;
  if (max_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeControllerSpec.max_limit)
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::release_max_limit() {
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.max_limit_;
  _impl_.max_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::unsafe_arena_release_max_limit() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeControllerSpec.max_limit)
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.max_limit_;
  _impl_.max_limit_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::_internal_mutable_max_limit() {
  
  if (_impl_.max_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosLimit>(GetArenaForAllocation());
    _impl_.max_limit_ = p;
  }
  return _impl_.max_limit_;
}
inline ::opi_api::storage::v1::QosLimit* NvmeControllerSpec::mutable_max_limit() {
  ::opi_api::storage::v1::QosLimit* _msg = _internal_mutable_max_limit();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeControllerSpec.max_limit)
  return _msg;
}
inline void NvmeControllerSpec::set_allocated_max_limit(::opi_api::storage::v1::QosLimit* max_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_limit_);
  }
  if (max_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_limit));
    if (message_arena != submessage_arena) {
      max_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_limit, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_limit_ = max_limit;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeControllerSpec.max_limit)
}

inline bool NvmeControllerSpec::has_endpoint() const {
  return endpoint_case() != ENDPOINT_NOT_SET;
}
inline void NvmeControllerSpec::clear_has_endpoint() {
  _impl_._oneof_case_[0] = ENDPOINT_NOT_SET;
}
inline NvmeControllerSpec::EndpointCase NvmeControllerSpec::endpoint_case() const {
  return NvmeControllerSpec::EndpointCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NvmeControllerStatus

// bool active = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeControllerStatus::clear_active() {
  _impl_.active_ = false;
}
inline bool NvmeControllerStatus::_internal_active() const {
  return _impl_.active_;
}
inline bool NvmeControllerStatus::active() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeControllerStatus.active)
  return _internal_active();
}
inline void NvmeControllerStatus::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void NvmeControllerStatus::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeControllerStatus.active)
}

// -------------------------------------------------------------------

// NvmeNamespace

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void NvmeNamespace::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NvmeNamespace::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespace.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeNamespace::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespace.name)
}
inline std::string* NvmeNamespace::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeNamespace.name)
  return _s;
}
inline const std::string& NvmeNamespace::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NvmeNamespace::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeNamespace::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeNamespace::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeNamespace.name)
  return _impl_.name_.Release();
}
inline void NvmeNamespace::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeNamespace.name)
}

// .opi_api.storage.v1.NvmeNamespaceSpec spec = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool NvmeNamespace::_internal_has_spec() const {
  return this != internal_default_instance() && _impl_.spec_ != nullptr;
}
inline bool NvmeNamespace::has_spec() const {
  return _internal_has_spec();
}
inline void NvmeNamespace::clear_spec() {
  if (GetArenaForAllocation() == nullptr && _impl_.spec_ != nullptr) {
    delete _impl_.spec_;
  }
  _impl_.spec_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeNamespaceSpec& NvmeNamespace::_internal_spec() const {
  const ::opi_api::storage::v1::NvmeNamespaceSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeNamespaceSpec&>(
      ::opi_api::storage::v1::_NvmeNamespaceSpec_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeNamespaceSpec& NvmeNamespace::spec() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespace.spec)
  return _internal_spec();
}
inline void NvmeNamespace::unsafe_arena_set_allocated_spec(
    ::opi_api::storage::v1::NvmeNamespaceSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeNamespace.spec)
}
inline ::opi_api::storage::v1::NvmeNamespaceSpec* NvmeNamespace::release_spec() {
  
  ::opi_api::storage::v1::NvmeNamespaceSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespaceSpec* NvmeNamespace::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeNamespace.spec)
  
  ::opi_api::storage::v1::NvmeNamespaceSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespaceSpec* NvmeNamespace::_internal_mutable_spec() {
  
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespaceSpec>(GetArenaForAllocation());
    _impl_.spec_ = p;
  }
  return _impl_.spec_;
}
inline ::opi_api::storage::v1::NvmeNamespaceSpec* NvmeNamespace::mutable_spec() {
  ::opi_api::storage::v1::NvmeNamespaceSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeNamespace.spec)
  return _msg;
}
inline void NvmeNamespace::set_allocated_spec(::opi_api::storage::v1::NvmeNamespaceSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeNamespace.spec)
}

// .opi_api.storage.v1.NvmeNamespaceStatus status = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool NvmeNamespace::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool NvmeNamespace::has_status() const {
  return _internal_has_status();
}
inline void NvmeNamespace::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeNamespaceStatus& NvmeNamespace::_internal_status() const {
  const ::opi_api::storage::v1::NvmeNamespaceStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeNamespaceStatus&>(
      ::opi_api::storage::v1::_NvmeNamespaceStatus_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeNamespaceStatus& NvmeNamespace::status() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespace.status)
  return _internal_status();
}
inline void NvmeNamespace::unsafe_arena_set_allocated_status(
    ::opi_api::storage::v1::NvmeNamespaceStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeNamespace.status)
}
inline ::opi_api::storage::v1::NvmeNamespaceStatus* NvmeNamespace::release_status() {
  
  ::opi_api::storage::v1::NvmeNamespaceStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespaceStatus* NvmeNamespace::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeNamespace.status)
  
  ::opi_api::storage::v1::NvmeNamespaceStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespaceStatus* NvmeNamespace::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespaceStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::opi_api::storage::v1::NvmeNamespaceStatus* NvmeNamespace::mutable_status() {
  ::opi_api::storage::v1::NvmeNamespaceStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeNamespace.status)
  return _msg;
}
inline void NvmeNamespace::set_allocated_status(::opi_api::storage::v1::NvmeNamespaceStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeNamespace.status)
}

// -------------------------------------------------------------------

// NvmeNamespaceSpec

// int32 host_nsid = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeNamespaceSpec::clear_host_nsid() {
  _impl_.host_nsid_ = 0;
}
inline int32_t NvmeNamespaceSpec::_internal_host_nsid() const {
  return _impl_.host_nsid_;
}
inline int32_t NvmeNamespaceSpec::host_nsid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceSpec.host_nsid)
  return _internal_host_nsid();
}
inline void NvmeNamespaceSpec::_internal_set_host_nsid(int32_t value) {
  
  _impl_.host_nsid_ = value;
}
inline void NvmeNamespaceSpec::set_host_nsid(int32_t value) {
  _internal_set_host_nsid(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespaceSpec.host_nsid)
}

// string nguid = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeNamespaceSpec::clear_nguid() {
  _impl_.nguid_.ClearToEmpty();
}
inline const std::string& NvmeNamespaceSpec::nguid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceSpec.nguid)
  return _internal_nguid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeNamespaceSpec::set_nguid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nguid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespaceSpec.nguid)
}
inline std::string* NvmeNamespaceSpec::mutable_nguid() {
  std::string* _s = _internal_mutable_nguid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeNamespaceSpec.nguid)
  return _s;
}
inline const std::string& NvmeNamespaceSpec::_internal_nguid() const {
  return _impl_.nguid_.Get();
}
inline void NvmeNamespaceSpec::_internal_set_nguid(const std::string& value) {
  
  _impl_.nguid_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeNamespaceSpec::_internal_mutable_nguid() {
  
  return _impl_.nguid_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeNamespaceSpec::release_nguid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeNamespaceSpec.nguid)
  return _impl_.nguid_.Release();
}
inline void NvmeNamespaceSpec::set_allocated_nguid(std::string* nguid) {
  if (nguid != nullptr) {
    
  } else {
    
  }
  _impl_.nguid_.SetAllocated(nguid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nguid_.IsDefault()) {
    _impl_.nguid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeNamespaceSpec.nguid)
}

// int64 eui64 = 4 [(.google.api.field_behavior) = OPTIONAL];
inline void NvmeNamespaceSpec::clear_eui64() {
  _impl_.eui64_ = int64_t{0};
}
inline int64_t NvmeNamespaceSpec::_internal_eui64() const {
  return _impl_.eui64_;
}
inline int64_t NvmeNamespaceSpec::eui64() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceSpec.eui64)
  return _internal_eui64();
}
inline void NvmeNamespaceSpec::_internal_set_eui64(int64_t value) {
  
  _impl_.eui64_ = value;
}
inline void NvmeNamespaceSpec::set_eui64(int64_t value) {
  _internal_set_eui64(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespaceSpec.eui64)
}

// .opi_api.common.v1.Uuid uuid = 5 [(.google.api.field_behavior) = OPTIONAL];
inline bool NvmeNamespaceSpec::_internal_has_uuid() const {
  return this != internal_default_instance() && _impl_.uuid_ != nullptr;
}
inline bool NvmeNamespaceSpec::has_uuid() const {
  return _internal_has_uuid();
}
inline const ::opi_api::common::v1::Uuid& NvmeNamespaceSpec::_internal_uuid() const {
  const ::opi_api::common::v1::Uuid* p = _impl_.uuid_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::common::v1::Uuid&>(
      ::opi_api::common::v1::_Uuid_default_instance_);
}
inline const ::opi_api::common::v1::Uuid& NvmeNamespaceSpec::uuid() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceSpec.uuid)
  return _internal_uuid();
}
inline void NvmeNamespaceSpec::unsafe_arena_set_allocated_uuid(
    ::opi_api::common::v1::Uuid* uuid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uuid_);
  }
  _impl_.uuid_ = uuid;
  if (uuid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.NvmeNamespaceSpec.uuid)
}
inline ::opi_api::common::v1::Uuid* NvmeNamespaceSpec::release_uuid() {
  
  ::opi_api::common::v1::Uuid* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::common::v1::Uuid* NvmeNamespaceSpec::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeNamespaceSpec.uuid)
  
  ::opi_api::common::v1::Uuid* temp = _impl_.uuid_;
  _impl_.uuid_ = nullptr;
  return temp;
}
inline ::opi_api::common::v1::Uuid* NvmeNamespaceSpec::_internal_mutable_uuid() {
  
  if (_impl_.uuid_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::common::v1::Uuid>(GetArenaForAllocation());
    _impl_.uuid_ = p;
  }
  return _impl_.uuid_;
}
inline ::opi_api::common::v1::Uuid* NvmeNamespaceSpec::mutable_uuid() {
  ::opi_api::common::v1::Uuid* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeNamespaceSpec.uuid)
  return _msg;
}
inline void NvmeNamespaceSpec::set_allocated_uuid(::opi_api::common::v1::Uuid* uuid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uuid_);
  }
  if (uuid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uuid));
    if (message_arena != submessage_arena) {
      uuid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uuid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uuid_ = uuid;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeNamespaceSpec.uuid)
}

// string volume_name_ref = 6 [(.google.api.field_behavior) = REQUIRED];
inline void NvmeNamespaceSpec::clear_volume_name_ref() {
  _impl_.volume_name_ref_.ClearToEmpty();
}
inline const std::string& NvmeNamespaceSpec::volume_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref)
  return _internal_volume_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NvmeNamespaceSpec::set_volume_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.volume_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref)
}
inline std::string* NvmeNamespaceSpec::mutable_volume_name_ref() {
  std::string* _s = _internal_mutable_volume_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref)
  return _s;
}
inline const std::string& NvmeNamespaceSpec::_internal_volume_name_ref() const {
  return _impl_.volume_name_ref_.Get();
}
inline void NvmeNamespaceSpec::_internal_set_volume_name_ref(const std::string& value) {
  
  _impl_.volume_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* NvmeNamespaceSpec::_internal_mutable_volume_name_ref() {
  
  return _impl_.volume_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* NvmeNamespaceSpec::release_volume_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref)
  return _impl_.volume_name_ref_.Release();
}
inline void NvmeNamespaceSpec::set_allocated_volume_name_ref(std::string* volume_name_ref) {
  if (volume_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.volume_name_ref_.SetAllocated(volume_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.volume_name_ref_.IsDefault()) {
    _impl_.volume_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.NvmeNamespaceSpec.volume_name_ref)
}

// -------------------------------------------------------------------

// NvmeNamespaceStatus

// .opi_api.storage.v1.NvmeNamespacePciState pci_state = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeNamespaceStatus::clear_pci_state() {
  _impl_.pci_state_ = 0;
}
inline ::opi_api::storage::v1::NvmeNamespacePciState NvmeNamespaceStatus::_internal_pci_state() const {
  return static_cast< ::opi_api::storage::v1::NvmeNamespacePciState >(_impl_.pci_state_);
}
inline ::opi_api::storage::v1::NvmeNamespacePciState NvmeNamespaceStatus::pci_state() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceStatus.pci_state)
  return _internal_pci_state();
}
inline void NvmeNamespaceStatus::_internal_set_pci_state(::opi_api::storage::v1::NvmeNamespacePciState value) {
  
  _impl_.pci_state_ = value;
}
inline void NvmeNamespaceStatus::set_pci_state(::opi_api::storage::v1::NvmeNamespacePciState value) {
  _internal_set_pci_state(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespaceStatus.pci_state)
}

// .opi_api.storage.v1.NvmeNamespacePciOperState pci_oper_state = 2 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void NvmeNamespaceStatus::clear_pci_oper_state() {
  _impl_.pci_oper_state_ = 0;
}
inline ::opi_api::storage::v1::NvmeNamespacePciOperState NvmeNamespaceStatus::_internal_pci_oper_state() const {
  return static_cast< ::opi_api::storage::v1::NvmeNamespacePciOperState >(_impl_.pci_oper_state_);
}
inline ::opi_api::storage::v1::NvmeNamespacePciOperState NvmeNamespaceStatus::pci_oper_state() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.NvmeNamespaceStatus.pci_oper_state)
  return _internal_pci_oper_state();
}
inline void NvmeNamespaceStatus::_internal_set_pci_oper_state(::opi_api::storage::v1::NvmeNamespacePciOperState value) {
  
  _impl_.pci_oper_state_ = value;
}
inline void NvmeNamespaceStatus::set_pci_oper_state(::opi_api::storage::v1::NvmeNamespacePciOperState value) {
  _internal_set_pci_oper_state(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.NvmeNamespaceStatus.pci_oper_state)
}

// -------------------------------------------------------------------

// CreateNvmeSubsystemRequest

// .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNvmeSubsystemRequest::_internal_has_nvme_subsystem() const {
  return this != internal_default_instance() && _impl_.nvme_subsystem_ != nullptr;
}
inline bool CreateNvmeSubsystemRequest::has_nvme_subsystem() const {
  return _internal_has_nvme_subsystem();
}
inline void CreateNvmeSubsystemRequest::clear_nvme_subsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_subsystem_ != nullptr) {
    delete _impl_.nvme_subsystem_;
  }
  _impl_.nvme_subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeSubsystem& CreateNvmeSubsystemRequest::_internal_nvme_subsystem() const {
  const ::opi_api::storage::v1::NvmeSubsystem* p = _impl_.nvme_subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeSubsystem&>(
      ::opi_api::storage::v1::_NvmeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeSubsystem& CreateNvmeSubsystemRequest::nvme_subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem)
  return _internal_nvme_subsystem();
}
inline void CreateNvmeSubsystemRequest::unsafe_arena_set_allocated_nvme_subsystem(
    ::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_subsystem_);
  }
  _impl_.nvme_subsystem_ = nvme_subsystem;
  if (nvme_subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem)
}
inline ::opi_api::storage::v1::NvmeSubsystem* CreateNvmeSubsystemRequest::release_nvme_subsystem() {
  
  ::opi_api::storage::v1::NvmeSubsystem* temp = _impl_.nvme_subsystem_;
  _impl_.nvme_subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystem* CreateNvmeSubsystemRequest::unsafe_arena_release_nvme_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem)
  
  ::opi_api::storage::v1::NvmeSubsystem* temp = _impl_.nvme_subsystem_;
  _impl_.nvme_subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystem* CreateNvmeSubsystemRequest::_internal_mutable_nvme_subsystem() {
  
  if (_impl_.nvme_subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystem>(GetArenaForAllocation());
    _impl_.nvme_subsystem_ = p;
  }
  return _impl_.nvme_subsystem_;
}
inline ::opi_api::storage::v1::NvmeSubsystem* CreateNvmeSubsystemRequest::mutable_nvme_subsystem() {
  ::opi_api::storage::v1::NvmeSubsystem* _msg = _internal_mutable_nvme_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem)
  return _msg;
}
inline void CreateNvmeSubsystemRequest::set_allocated_nvme_subsystem(::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_subsystem_;
  }
  if (nvme_subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_subsystem);
    if (message_arena != submessage_arena) {
      nvme_subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_subsystem, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_subsystem_ = nvme_subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem)
}

// string nvme_subsystem_id = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateNvmeSubsystemRequest::clear_nvme_subsystem_id() {
  _impl_.nvme_subsystem_id_.ClearToEmpty();
}
inline const std::string& CreateNvmeSubsystemRequest::nvme_subsystem_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id)
  return _internal_nvme_subsystem_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmeSubsystemRequest::set_nvme_subsystem_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nvme_subsystem_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id)
}
inline std::string* CreateNvmeSubsystemRequest::mutable_nvme_subsystem_id() {
  std::string* _s = _internal_mutable_nvme_subsystem_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id)
  return _s;
}
inline const std::string& CreateNvmeSubsystemRequest::_internal_nvme_subsystem_id() const {
  return _impl_.nvme_subsystem_id_.Get();
}
inline void CreateNvmeSubsystemRequest::_internal_set_nvme_subsystem_id(const std::string& value) {
  
  _impl_.nvme_subsystem_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmeSubsystemRequest::_internal_mutable_nvme_subsystem_id() {
  
  return _impl_.nvme_subsystem_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmeSubsystemRequest::release_nvme_subsystem_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id)
  return _impl_.nvme_subsystem_id_.Release();
}
inline void CreateNvmeSubsystemRequest::set_allocated_nvme_subsystem_id(std::string* nvme_subsystem_id) {
  if (nvme_subsystem_id != nullptr) {
    
  } else {
    
  }
  _impl_.nvme_subsystem_id_.SetAllocated(nvme_subsystem_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nvme_subsystem_id_.IsDefault()) {
    _impl_.nvme_subsystem_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeSubsystemRequest.nvme_subsystem_id)
}

// -------------------------------------------------------------------

// DeleteNvmeSubsystemRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNvmeSubsystemRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteNvmeSubsystemRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeSubsystemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNvmeSubsystemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeSubsystemRequest.name)
}
inline std::string* DeleteNvmeSubsystemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNvmeSubsystemRequest.name)
  return _s;
}
inline const std::string& DeleteNvmeSubsystemRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteNvmeSubsystemRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteNvmeSubsystemRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteNvmeSubsystemRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNvmeSubsystemRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteNvmeSubsystemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNvmeSubsystemRequest.name)
}

// bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void DeleteNvmeSubsystemRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool DeleteNvmeSubsystemRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool DeleteNvmeSubsystemRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeSubsystemRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteNvmeSubsystemRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void DeleteNvmeSubsystemRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeSubsystemRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateNvmeSubsystemRequest

// .opi_api.storage.v1.NvmeSubsystem nvme_subsystem = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateNvmeSubsystemRequest::_internal_has_nvme_subsystem() const {
  return this != internal_default_instance() && _impl_.nvme_subsystem_ != nullptr;
}
inline bool UpdateNvmeSubsystemRequest::has_nvme_subsystem() const {
  return _internal_has_nvme_subsystem();
}
inline void UpdateNvmeSubsystemRequest::clear_nvme_subsystem() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_subsystem_ != nullptr) {
    delete _impl_.nvme_subsystem_;
  }
  _impl_.nvme_subsystem_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeSubsystem& UpdateNvmeSubsystemRequest::_internal_nvme_subsystem() const {
  const ::opi_api::storage::v1::NvmeSubsystem* p = _impl_.nvme_subsystem_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeSubsystem&>(
      ::opi_api::storage::v1::_NvmeSubsystem_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeSubsystem& UpdateNvmeSubsystemRequest::nvme_subsystem() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeSubsystemRequest.nvme_subsystem)
  return _internal_nvme_subsystem();
}
inline void UpdateNvmeSubsystemRequest::unsafe_arena_set_allocated_nvme_subsystem(
    ::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_subsystem_);
  }
  _impl_.nvme_subsystem_ = nvme_subsystem;
  if (nvme_subsystem) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeSubsystemRequest.nvme_subsystem)
}
inline ::opi_api::storage::v1::NvmeSubsystem* UpdateNvmeSubsystemRequest::release_nvme_subsystem() {
  
  ::opi_api::storage::v1::NvmeSubsystem* temp = _impl_.nvme_subsystem_;
  _impl_.nvme_subsystem_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystem* UpdateNvmeSubsystemRequest::unsafe_arena_release_nvme_subsystem() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeSubsystemRequest.nvme_subsystem)
  
  ::opi_api::storage::v1::NvmeSubsystem* temp = _impl_.nvme_subsystem_;
  _impl_.nvme_subsystem_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeSubsystem* UpdateNvmeSubsystemRequest::_internal_mutable_nvme_subsystem() {
  
  if (_impl_.nvme_subsystem_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeSubsystem>(GetArenaForAllocation());
    _impl_.nvme_subsystem_ = p;
  }
  return _impl_.nvme_subsystem_;
}
inline ::opi_api::storage::v1::NvmeSubsystem* UpdateNvmeSubsystemRequest::mutable_nvme_subsystem() {
  ::opi_api::storage::v1::NvmeSubsystem* _msg = _internal_mutable_nvme_subsystem();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeSubsystemRequest.nvme_subsystem)
  return _msg;
}
inline void UpdateNvmeSubsystemRequest::set_allocated_nvme_subsystem(::opi_api::storage::v1::NvmeSubsystem* nvme_subsystem) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_subsystem_;
  }
  if (nvme_subsystem) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_subsystem);
    if (message_arena != submessage_arena) {
      nvme_subsystem = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_subsystem, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_subsystem_ = nvme_subsystem;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeSubsystemRequest.nvme_subsystem)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateNvmeSubsystemRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateNvmeSubsystemRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeSubsystemRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeSubsystemRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeSubsystemRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNvmeSubsystemRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeSubsystemRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeSubsystemRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeSubsystemRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeSubsystemRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeSubsystemRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeSubsystemRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeSubsystemRequest.update_mask)
  return _msg;
}
inline void UpdateNvmeSubsystemRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeSubsystemRequest.update_mask)
}

// bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateNvmeSubsystemRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool UpdateNvmeSubsystemRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool UpdateNvmeSubsystemRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeSubsystemRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateNvmeSubsystemRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void UpdateNvmeSubsystemRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateNvmeSubsystemRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListNvmeSubsystemsRequest

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeSubsystemsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListNvmeSubsystemsRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListNvmeSubsystemsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_size)
  return _internal_page_size();
}
inline void ListNvmeSubsystemsRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListNvmeSubsystemsRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeSubsystemsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeSubsystemsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeSubsystemsRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token)
}
inline std::string* ListNvmeSubsystemsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token)
  return _s;
}
inline const std::string& ListNvmeSubsystemsRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListNvmeSubsystemsRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeSubsystemsRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeSubsystemsRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListNvmeSubsystemsRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeSubsystemsRequest.page_token)
}

// -------------------------------------------------------------------

// ListNvmeSubsystemsResponse

// repeated .opi_api.storage.v1.NvmeSubsystem nvme_subsystems = 1;
inline int ListNvmeSubsystemsResponse::_internal_nvme_subsystems_size() const {
  return _impl_.nvme_subsystems_.size();
}
inline int ListNvmeSubsystemsResponse::nvme_subsystems_size() const {
  return _internal_nvme_subsystems_size();
}
inline void ListNvmeSubsystemsResponse::clear_nvme_subsystems() {
  _impl_.nvme_subsystems_.Clear();
}
inline ::opi_api::storage::v1::NvmeSubsystem* ListNvmeSubsystemsResponse::mutable_nvme_subsystems(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeSubsystemsResponse.nvme_subsystems)
  return _impl_.nvme_subsystems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeSubsystem >*
ListNvmeSubsystemsResponse::mutable_nvme_subsystems() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNvmeSubsystemsResponse.nvme_subsystems)
  return &_impl_.nvme_subsystems_;
}
inline const ::opi_api::storage::v1::NvmeSubsystem& ListNvmeSubsystemsResponse::_internal_nvme_subsystems(int index) const {
  return _impl_.nvme_subsystems_.Get(index);
}
inline const ::opi_api::storage::v1::NvmeSubsystem& ListNvmeSubsystemsResponse::nvme_subsystems(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeSubsystemsResponse.nvme_subsystems)
  return _internal_nvme_subsystems(index);
}
inline ::opi_api::storage::v1::NvmeSubsystem* ListNvmeSubsystemsResponse::_internal_add_nvme_subsystems() {
  return _impl_.nvme_subsystems_.Add();
}
inline ::opi_api::storage::v1::NvmeSubsystem* ListNvmeSubsystemsResponse::add_nvme_subsystems() {
  ::opi_api::storage::v1::NvmeSubsystem* _add = _internal_add_nvme_subsystems();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNvmeSubsystemsResponse.nvme_subsystems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeSubsystem >&
ListNvmeSubsystemsResponse::nvme_subsystems() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNvmeSubsystemsResponse.nvme_subsystems)
  return _impl_.nvme_subsystems_;
}

// string next_page_token = 2;
inline void ListNvmeSubsystemsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeSubsystemsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeSubsystemsResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token)
}
inline std::string* ListNvmeSubsystemsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token)
  return _s;
}
inline const std::string& ListNvmeSubsystemsResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListNvmeSubsystemsResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeSubsystemsResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeSubsystemsResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListNvmeSubsystemsResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeSubsystemsResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNvmeSubsystemRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNvmeSubsystemRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNvmeSubsystemRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNvmeSubsystemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNvmeSubsystemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNvmeSubsystemRequest.name)
}
inline std::string* GetNvmeSubsystemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNvmeSubsystemRequest.name)
  return _s;
}
inline const std::string& GetNvmeSubsystemRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetNvmeSubsystemRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNvmeSubsystemRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNvmeSubsystemRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNvmeSubsystemRequest.name)
  return _impl_.name_.Release();
}
inline void GetNvmeSubsystemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNvmeSubsystemRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeSubsystemRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsNvmeSubsystemRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StatsNvmeSubsystemRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeSubsystemRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsNvmeSubsystemRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsNvmeSubsystemRequest.name)
}
inline std::string* StatsNvmeSubsystemRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeSubsystemRequest.name)
  return _s;
}
inline const std::string& StatsNvmeSubsystemRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatsNvmeSubsystemRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatsNvmeSubsystemRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatsNvmeSubsystemRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeSubsystemRequest.name)
  return _impl_.name_.Release();
}
inline void StatsNvmeSubsystemRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeSubsystemRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeSubsystemResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsNvmeSubsystemResponse::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool StatsNvmeSubsystemResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeSubsystemResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeSubsystemResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeSubsystemResponse.stats)
  return _internal_stats();
}
inline void StatsNvmeSubsystemResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsNvmeSubsystemResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeSubsystemResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeSubsystemResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeSubsystemResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeSubsystemResponse::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeSubsystemResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeSubsystemResponse.stats)
  return _msg;
}
inline void StatsNvmeSubsystemResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeSubsystemResponse.stats)
}

// -------------------------------------------------------------------

// CreateNvmeControllerRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateNvmeControllerRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateNvmeControllerRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeControllerRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmeControllerRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmeControllerRequest.parent)
}
inline std::string* CreateNvmeControllerRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeControllerRequest.parent)
  return _s;
}
inline const std::string& CreateNvmeControllerRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateNvmeControllerRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmeControllerRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmeControllerRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeControllerRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateNvmeControllerRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeControllerRequest.parent)
}

// .opi_api.storage.v1.NvmeController nvme_controller = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNvmeControllerRequest::_internal_has_nvme_controller() const {
  return this != internal_default_instance() && _impl_.nvme_controller_ != nullptr;
}
inline bool CreateNvmeControllerRequest::has_nvme_controller() const {
  return _internal_has_nvme_controller();
}
inline void CreateNvmeControllerRequest::clear_nvme_controller() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_controller_ != nullptr) {
    delete _impl_.nvme_controller_;
  }
  _impl_.nvme_controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeController& CreateNvmeControllerRequest::_internal_nvme_controller() const {
  const ::opi_api::storage::v1::NvmeController* p = _impl_.nvme_controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeController&>(
      ::opi_api::storage::v1::_NvmeController_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeController& CreateNvmeControllerRequest::nvme_controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller)
  return _internal_nvme_controller();
}
inline void CreateNvmeControllerRequest::unsafe_arena_set_allocated_nvme_controller(
    ::opi_api::storage::v1::NvmeController* nvme_controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_controller_);
  }
  _impl_.nvme_controller_ = nvme_controller;
  if (nvme_controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller)
}
inline ::opi_api::storage::v1::NvmeController* CreateNvmeControllerRequest::release_nvme_controller() {
  
  ::opi_api::storage::v1::NvmeController* temp = _impl_.nvme_controller_;
  _impl_.nvme_controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeController* CreateNvmeControllerRequest::unsafe_arena_release_nvme_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller)
  
  ::opi_api::storage::v1::NvmeController* temp = _impl_.nvme_controller_;
  _impl_.nvme_controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeController* CreateNvmeControllerRequest::_internal_mutable_nvme_controller() {
  
  if (_impl_.nvme_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeController>(GetArenaForAllocation());
    _impl_.nvme_controller_ = p;
  }
  return _impl_.nvme_controller_;
}
inline ::opi_api::storage::v1::NvmeController* CreateNvmeControllerRequest::mutable_nvme_controller() {
  ::opi_api::storage::v1::NvmeController* _msg = _internal_mutable_nvme_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller)
  return _msg;
}
inline void CreateNvmeControllerRequest::set_allocated_nvme_controller(::opi_api::storage::v1::NvmeController* nvme_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_controller_;
  }
  if (nvme_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_controller);
    if (message_arena != submessage_arena) {
      nvme_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_controller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_controller_ = nvme_controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller)
}

// string nvme_controller_id = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateNvmeControllerRequest::clear_nvme_controller_id() {
  _impl_.nvme_controller_id_.ClearToEmpty();
}
inline const std::string& CreateNvmeControllerRequest::nvme_controller_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id)
  return _internal_nvme_controller_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmeControllerRequest::set_nvme_controller_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nvme_controller_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id)
}
inline std::string* CreateNvmeControllerRequest::mutable_nvme_controller_id() {
  std::string* _s = _internal_mutable_nvme_controller_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id)
  return _s;
}
inline const std::string& CreateNvmeControllerRequest::_internal_nvme_controller_id() const {
  return _impl_.nvme_controller_id_.Get();
}
inline void CreateNvmeControllerRequest::_internal_set_nvme_controller_id(const std::string& value) {
  
  _impl_.nvme_controller_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmeControllerRequest::_internal_mutable_nvme_controller_id() {
  
  return _impl_.nvme_controller_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmeControllerRequest::release_nvme_controller_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id)
  return _impl_.nvme_controller_id_.Release();
}
inline void CreateNvmeControllerRequest::set_allocated_nvme_controller_id(std::string* nvme_controller_id) {
  if (nvme_controller_id != nullptr) {
    
  } else {
    
  }
  _impl_.nvme_controller_id_.SetAllocated(nvme_controller_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nvme_controller_id_.IsDefault()) {
    _impl_.nvme_controller_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeControllerRequest.nvme_controller_id)
}

// -------------------------------------------------------------------

// DeleteNvmeControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNvmeControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteNvmeControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNvmeControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeControllerRequest.name)
}
inline std::string* DeleteNvmeControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNvmeControllerRequest.name)
  return _s;
}
inline const std::string& DeleteNvmeControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteNvmeControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteNvmeControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteNvmeControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNvmeControllerRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteNvmeControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNvmeControllerRequest.name)
}

// bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void DeleteNvmeControllerRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool DeleteNvmeControllerRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool DeleteNvmeControllerRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeControllerRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteNvmeControllerRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void DeleteNvmeControllerRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeControllerRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateNvmeControllerRequest

// .opi_api.storage.v1.NvmeController nvme_controller = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateNvmeControllerRequest::_internal_has_nvme_controller() const {
  return this != internal_default_instance() && _impl_.nvme_controller_ != nullptr;
}
inline bool UpdateNvmeControllerRequest::has_nvme_controller() const {
  return _internal_has_nvme_controller();
}
inline void UpdateNvmeControllerRequest::clear_nvme_controller() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_controller_ != nullptr) {
    delete _impl_.nvme_controller_;
  }
  _impl_.nvme_controller_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeController& UpdateNvmeControllerRequest::_internal_nvme_controller() const {
  const ::opi_api::storage::v1::NvmeController* p = _impl_.nvme_controller_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeController&>(
      ::opi_api::storage::v1::_NvmeController_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeController& UpdateNvmeControllerRequest::nvme_controller() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeControllerRequest.nvme_controller)
  return _internal_nvme_controller();
}
inline void UpdateNvmeControllerRequest::unsafe_arena_set_allocated_nvme_controller(
    ::opi_api::storage::v1::NvmeController* nvme_controller) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_controller_);
  }
  _impl_.nvme_controller_ = nvme_controller;
  if (nvme_controller) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeControllerRequest.nvme_controller)
}
inline ::opi_api::storage::v1::NvmeController* UpdateNvmeControllerRequest::release_nvme_controller() {
  
  ::opi_api::storage::v1::NvmeController* temp = _impl_.nvme_controller_;
  _impl_.nvme_controller_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeController* UpdateNvmeControllerRequest::unsafe_arena_release_nvme_controller() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeControllerRequest.nvme_controller)
  
  ::opi_api::storage::v1::NvmeController* temp = _impl_.nvme_controller_;
  _impl_.nvme_controller_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeController* UpdateNvmeControllerRequest::_internal_mutable_nvme_controller() {
  
  if (_impl_.nvme_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeController>(GetArenaForAllocation());
    _impl_.nvme_controller_ = p;
  }
  return _impl_.nvme_controller_;
}
inline ::opi_api::storage::v1::NvmeController* UpdateNvmeControllerRequest::mutable_nvme_controller() {
  ::opi_api::storage::v1::NvmeController* _msg = _internal_mutable_nvme_controller();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeControllerRequest.nvme_controller)
  return _msg;
}
inline void UpdateNvmeControllerRequest::set_allocated_nvme_controller(::opi_api::storage::v1::NvmeController* nvme_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_controller_;
  }
  if (nvme_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_controller);
    if (message_arena != submessage_arena) {
      nvme_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_controller, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_controller_ = nvme_controller;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeControllerRequest.nvme_controller)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateNvmeControllerRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateNvmeControllerRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeControllerRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeControllerRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeControllerRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNvmeControllerRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeControllerRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeControllerRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeControllerRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeControllerRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeControllerRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeControllerRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeControllerRequest.update_mask)
  return _msg;
}
inline void UpdateNvmeControllerRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeControllerRequest.update_mask)
}

// bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateNvmeControllerRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool UpdateNvmeControllerRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool UpdateNvmeControllerRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeControllerRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateNvmeControllerRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void UpdateNvmeControllerRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateNvmeControllerRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListNvmeControllersRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNvmeControllersRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListNvmeControllersRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeControllersRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeControllersRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeControllersRequest.parent)
}
inline std::string* ListNvmeControllersRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeControllersRequest.parent)
  return _s;
}
inline const std::string& ListNvmeControllersRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListNvmeControllersRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeControllersRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeControllersRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeControllersRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListNvmeControllersRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeControllersRequest.parent)
}

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeControllersRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListNvmeControllersRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListNvmeControllersRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeControllersRequest.page_size)
  return _internal_page_size();
}
inline void ListNvmeControllersRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListNvmeControllersRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeControllersRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeControllersRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeControllersRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeControllersRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeControllersRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeControllersRequest.page_token)
}
inline std::string* ListNvmeControllersRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeControllersRequest.page_token)
  return _s;
}
inline const std::string& ListNvmeControllersRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListNvmeControllersRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeControllersRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeControllersRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeControllersRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListNvmeControllersRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeControllersRequest.page_token)
}

// -------------------------------------------------------------------

// ListNvmeControllersResponse

// repeated .opi_api.storage.v1.NvmeController nvme_controllers = 1;
inline int ListNvmeControllersResponse::_internal_nvme_controllers_size() const {
  return _impl_.nvme_controllers_.size();
}
inline int ListNvmeControllersResponse::nvme_controllers_size() const {
  return _internal_nvme_controllers_size();
}
inline void ListNvmeControllersResponse::clear_nvme_controllers() {
  _impl_.nvme_controllers_.Clear();
}
inline ::opi_api::storage::v1::NvmeController* ListNvmeControllersResponse::mutable_nvme_controllers(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeControllersResponse.nvme_controllers)
  return _impl_.nvme_controllers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeController >*
ListNvmeControllersResponse::mutable_nvme_controllers() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNvmeControllersResponse.nvme_controllers)
  return &_impl_.nvme_controllers_;
}
inline const ::opi_api::storage::v1::NvmeController& ListNvmeControllersResponse::_internal_nvme_controllers(int index) const {
  return _impl_.nvme_controllers_.Get(index);
}
inline const ::opi_api::storage::v1::NvmeController& ListNvmeControllersResponse::nvme_controllers(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeControllersResponse.nvme_controllers)
  return _internal_nvme_controllers(index);
}
inline ::opi_api::storage::v1::NvmeController* ListNvmeControllersResponse::_internal_add_nvme_controllers() {
  return _impl_.nvme_controllers_.Add();
}
inline ::opi_api::storage::v1::NvmeController* ListNvmeControllersResponse::add_nvme_controllers() {
  ::opi_api::storage::v1::NvmeController* _add = _internal_add_nvme_controllers();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNvmeControllersResponse.nvme_controllers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeController >&
ListNvmeControllersResponse::nvme_controllers() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNvmeControllersResponse.nvme_controllers)
  return _impl_.nvme_controllers_;
}

// string next_page_token = 2;
inline void ListNvmeControllersResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeControllersResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeControllersResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeControllersResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeControllersResponse.next_page_token)
}
inline std::string* ListNvmeControllersResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeControllersResponse.next_page_token)
  return _s;
}
inline const std::string& ListNvmeControllersResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListNvmeControllersResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeControllersResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeControllersResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeControllersResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListNvmeControllersResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeControllersResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNvmeControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNvmeControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNvmeControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNvmeControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNvmeControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNvmeControllerRequest.name)
}
inline std::string* GetNvmeControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNvmeControllerRequest.name)
  return _s;
}
inline const std::string& GetNvmeControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetNvmeControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNvmeControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNvmeControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNvmeControllerRequest.name)
  return _impl_.name_.Release();
}
inline void GetNvmeControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNvmeControllerRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeControllerRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsNvmeControllerRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StatsNvmeControllerRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeControllerRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsNvmeControllerRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsNvmeControllerRequest.name)
}
inline std::string* StatsNvmeControllerRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeControllerRequest.name)
  return _s;
}
inline const std::string& StatsNvmeControllerRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatsNvmeControllerRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatsNvmeControllerRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatsNvmeControllerRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeControllerRequest.name)
  return _impl_.name_.Release();
}
inline void StatsNvmeControllerRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeControllerRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeControllerResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsNvmeControllerResponse::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool StatsNvmeControllerResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeControllerResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeControllerResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeControllerResponse.stats)
  return _internal_stats();
}
inline void StatsNvmeControllerResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsNvmeControllerResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeControllerResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeControllerResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeControllerResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeControllerResponse::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeControllerResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeControllerResponse.stats)
  return _msg;
}
inline void StatsNvmeControllerResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeControllerResponse.stats)
}

// -------------------------------------------------------------------

// CreateNvmeNamespaceRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void CreateNvmeNamespaceRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& CreateNvmeNamespaceRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeNamespaceRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmeNamespaceRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmeNamespaceRequest.parent)
}
inline std::string* CreateNvmeNamespaceRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeNamespaceRequest.parent)
  return _s;
}
inline const std::string& CreateNvmeNamespaceRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void CreateNvmeNamespaceRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmeNamespaceRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmeNamespaceRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeNamespaceRequest.parent)
  return _impl_.parent_.Release();
}
inline void CreateNvmeNamespaceRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeNamespaceRequest.parent)
}

// .opi_api.storage.v1.NvmeNamespace nvme_namespace = 2 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateNvmeNamespaceRequest::_internal_has_nvme_namespace() const {
  return this != internal_default_instance() && _impl_.nvme_namespace_ != nullptr;
}
inline bool CreateNvmeNamespaceRequest::has_nvme_namespace() const {
  return _internal_has_nvme_namespace();
}
inline void CreateNvmeNamespaceRequest::clear_nvme_namespace() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_namespace_ != nullptr) {
    delete _impl_.nvme_namespace_;
  }
  _impl_.nvme_namespace_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeNamespace& CreateNvmeNamespaceRequest::_internal_nvme_namespace() const {
  const ::opi_api::storage::v1::NvmeNamespace* p = _impl_.nvme_namespace_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeNamespace&>(
      ::opi_api::storage::v1::_NvmeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeNamespace& CreateNvmeNamespaceRequest::nvme_namespace() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace)
  return _internal_nvme_namespace();
}
inline void CreateNvmeNamespaceRequest::unsafe_arena_set_allocated_nvme_namespace(
    ::opi_api::storage::v1::NvmeNamespace* nvme_namespace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_namespace_);
  }
  _impl_.nvme_namespace_ = nvme_namespace;
  if (nvme_namespace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace)
}
inline ::opi_api::storage::v1::NvmeNamespace* CreateNvmeNamespaceRequest::release_nvme_namespace() {
  
  ::opi_api::storage::v1::NvmeNamespace* temp = _impl_.nvme_namespace_;
  _impl_.nvme_namespace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespace* CreateNvmeNamespaceRequest::unsafe_arena_release_nvme_namespace() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace)
  
  ::opi_api::storage::v1::NvmeNamespace* temp = _impl_.nvme_namespace_;
  _impl_.nvme_namespace_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespace* CreateNvmeNamespaceRequest::_internal_mutable_nvme_namespace() {
  
  if (_impl_.nvme_namespace_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespace>(GetArenaForAllocation());
    _impl_.nvme_namespace_ = p;
  }
  return _impl_.nvme_namespace_;
}
inline ::opi_api::storage::v1::NvmeNamespace* CreateNvmeNamespaceRequest::mutable_nvme_namespace() {
  ::opi_api::storage::v1::NvmeNamespace* _msg = _internal_mutable_nvme_namespace();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace)
  return _msg;
}
inline void CreateNvmeNamespaceRequest::set_allocated_nvme_namespace(::opi_api::storage::v1::NvmeNamespace* nvme_namespace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_namespace_;
  }
  if (nvme_namespace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_namespace);
    if (message_arena != submessage_arena) {
      nvme_namespace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_namespace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_namespace_ = nvme_namespace;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace)
}

// string nvme_namespace_id = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateNvmeNamespaceRequest::clear_nvme_namespace_id() {
  _impl_.nvme_namespace_id_.ClearToEmpty();
}
inline const std::string& CreateNvmeNamespaceRequest::nvme_namespace_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id)
  return _internal_nvme_namespace_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNvmeNamespaceRequest::set_nvme_namespace_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nvme_namespace_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id)
}
inline std::string* CreateNvmeNamespaceRequest::mutable_nvme_namespace_id() {
  std::string* _s = _internal_mutable_nvme_namespace_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id)
  return _s;
}
inline const std::string& CreateNvmeNamespaceRequest::_internal_nvme_namespace_id() const {
  return _impl_.nvme_namespace_id_.Get();
}
inline void CreateNvmeNamespaceRequest::_internal_set_nvme_namespace_id(const std::string& value) {
  
  _impl_.nvme_namespace_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNvmeNamespaceRequest::_internal_mutable_nvme_namespace_id() {
  
  return _impl_.nvme_namespace_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNvmeNamespaceRequest::release_nvme_namespace_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id)
  return _impl_.nvme_namespace_id_.Release();
}
inline void CreateNvmeNamespaceRequest::set_allocated_nvme_namespace_id(std::string* nvme_namespace_id) {
  if (nvme_namespace_id != nullptr) {
    
  } else {
    
  }
  _impl_.nvme_namespace_id_.SetAllocated(nvme_namespace_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nvme_namespace_id_.IsDefault()) {
    _impl_.nvme_namespace_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateNvmeNamespaceRequest.nvme_namespace_id)
}

// -------------------------------------------------------------------

// DeleteNvmeNamespaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteNvmeNamespaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteNvmeNamespaceRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeNamespaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNvmeNamespaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeNamespaceRequest.name)
}
inline std::string* DeleteNvmeNamespaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteNvmeNamespaceRequest.name)
  return _s;
}
inline const std::string& DeleteNvmeNamespaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteNvmeNamespaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteNvmeNamespaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteNvmeNamespaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteNvmeNamespaceRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteNvmeNamespaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteNvmeNamespaceRequest.name)
}

// bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void DeleteNvmeNamespaceRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool DeleteNvmeNamespaceRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool DeleteNvmeNamespaceRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteNvmeNamespaceRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteNvmeNamespaceRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void DeleteNvmeNamespaceRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteNvmeNamespaceRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateNvmeNamespaceRequest

// .opi_api.storage.v1.NvmeNamespace nvme_namespace = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateNvmeNamespaceRequest::_internal_has_nvme_namespace() const {
  return this != internal_default_instance() && _impl_.nvme_namespace_ != nullptr;
}
inline bool UpdateNvmeNamespaceRequest::has_nvme_namespace() const {
  return _internal_has_nvme_namespace();
}
inline void UpdateNvmeNamespaceRequest::clear_nvme_namespace() {
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_namespace_ != nullptr) {
    delete _impl_.nvme_namespace_;
  }
  _impl_.nvme_namespace_ = nullptr;
}
inline const ::opi_api::storage::v1::NvmeNamespace& UpdateNvmeNamespaceRequest::_internal_nvme_namespace() const {
  const ::opi_api::storage::v1::NvmeNamespace* p = _impl_.nvme_namespace_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::NvmeNamespace&>(
      ::opi_api::storage::v1::_NvmeNamespace_default_instance_);
}
inline const ::opi_api::storage::v1::NvmeNamespace& UpdateNvmeNamespaceRequest::nvme_namespace() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeNamespaceRequest.nvme_namespace)
  return _internal_nvme_namespace();
}
inline void UpdateNvmeNamespaceRequest::unsafe_arena_set_allocated_nvme_namespace(
    ::opi_api::storage::v1::NvmeNamespace* nvme_namespace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nvme_namespace_);
  }
  _impl_.nvme_namespace_ = nvme_namespace;
  if (nvme_namespace) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeNamespaceRequest.nvme_namespace)
}
inline ::opi_api::storage::v1::NvmeNamespace* UpdateNvmeNamespaceRequest::release_nvme_namespace() {
  
  ::opi_api::storage::v1::NvmeNamespace* temp = _impl_.nvme_namespace_;
  _impl_.nvme_namespace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespace* UpdateNvmeNamespaceRequest::unsafe_arena_release_nvme_namespace() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeNamespaceRequest.nvme_namespace)
  
  ::opi_api::storage::v1::NvmeNamespace* temp = _impl_.nvme_namespace_;
  _impl_.nvme_namespace_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::NvmeNamespace* UpdateNvmeNamespaceRequest::_internal_mutable_nvme_namespace() {
  
  if (_impl_.nvme_namespace_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::NvmeNamespace>(GetArenaForAllocation());
    _impl_.nvme_namespace_ = p;
  }
  return _impl_.nvme_namespace_;
}
inline ::opi_api::storage::v1::NvmeNamespace* UpdateNvmeNamespaceRequest::mutable_nvme_namespace() {
  ::opi_api::storage::v1::NvmeNamespace* _msg = _internal_mutable_nvme_namespace();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeNamespaceRequest.nvme_namespace)
  return _msg;
}
inline void UpdateNvmeNamespaceRequest::set_allocated_nvme_namespace(::opi_api::storage::v1::NvmeNamespace* nvme_namespace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nvme_namespace_;
  }
  if (nvme_namespace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nvme_namespace);
    if (message_arena != submessage_arena) {
      nvme_namespace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nvme_namespace, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nvme_namespace_ = nvme_namespace;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeNamespaceRequest.nvme_namespace)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateNvmeNamespaceRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateNvmeNamespaceRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeNamespaceRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateNvmeNamespaceRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeNamespaceRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateNvmeNamespaceRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateNvmeNamespaceRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeNamespaceRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeNamespaceRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateNvmeNamespaceRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeNamespaceRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateNvmeNamespaceRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateNvmeNamespaceRequest.update_mask)
  return _msg;
}
inline void UpdateNvmeNamespaceRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateNvmeNamespaceRequest.update_mask)
}

// bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateNvmeNamespaceRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool UpdateNvmeNamespaceRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool UpdateNvmeNamespaceRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateNvmeNamespaceRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateNvmeNamespaceRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void UpdateNvmeNamespaceRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateNvmeNamespaceRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListNvmeNamespacesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListNvmeNamespacesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListNvmeNamespacesRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeNamespacesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeNamespacesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeNamespacesRequest.parent)
}
inline std::string* ListNvmeNamespacesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeNamespacesRequest.parent)
  return _s;
}
inline const std::string& ListNvmeNamespacesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListNvmeNamespacesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeNamespacesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeNamespacesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeNamespacesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListNvmeNamespacesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeNamespacesRequest.parent)
}

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeNamespacesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListNvmeNamespacesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListNvmeNamespacesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeNamespacesRequest.page_size)
  return _internal_page_size();
}
inline void ListNvmeNamespacesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListNvmeNamespacesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeNamespacesRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListNvmeNamespacesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeNamespacesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeNamespacesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeNamespacesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeNamespacesRequest.page_token)
}
inline std::string* ListNvmeNamespacesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeNamespacesRequest.page_token)
  return _s;
}
inline const std::string& ListNvmeNamespacesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListNvmeNamespacesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeNamespacesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeNamespacesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeNamespacesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListNvmeNamespacesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeNamespacesRequest.page_token)
}

// -------------------------------------------------------------------

// ListNvmeNamespacesResponse

// repeated .opi_api.storage.v1.NvmeNamespace nvme_namespaces = 1;
inline int ListNvmeNamespacesResponse::_internal_nvme_namespaces_size() const {
  return _impl_.nvme_namespaces_.size();
}
inline int ListNvmeNamespacesResponse::nvme_namespaces_size() const {
  return _internal_nvme_namespaces_size();
}
inline void ListNvmeNamespacesResponse::clear_nvme_namespaces() {
  _impl_.nvme_namespaces_.Clear();
}
inline ::opi_api::storage::v1::NvmeNamespace* ListNvmeNamespacesResponse::mutable_nvme_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeNamespacesResponse.nvme_namespaces)
  return _impl_.nvme_namespaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeNamespace >*
ListNvmeNamespacesResponse::mutable_nvme_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListNvmeNamespacesResponse.nvme_namespaces)
  return &_impl_.nvme_namespaces_;
}
inline const ::opi_api::storage::v1::NvmeNamespace& ListNvmeNamespacesResponse::_internal_nvme_namespaces(int index) const {
  return _impl_.nvme_namespaces_.Get(index);
}
inline const ::opi_api::storage::v1::NvmeNamespace& ListNvmeNamespacesResponse::nvme_namespaces(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeNamespacesResponse.nvme_namespaces)
  return _internal_nvme_namespaces(index);
}
inline ::opi_api::storage::v1::NvmeNamespace* ListNvmeNamespacesResponse::_internal_add_nvme_namespaces() {
  return _impl_.nvme_namespaces_.Add();
}
inline ::opi_api::storage::v1::NvmeNamespace* ListNvmeNamespacesResponse::add_nvme_namespaces() {
  ::opi_api::storage::v1::NvmeNamespace* _add = _internal_add_nvme_namespaces();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListNvmeNamespacesResponse.nvme_namespaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::NvmeNamespace >&
ListNvmeNamespacesResponse::nvme_namespaces() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListNvmeNamespacesResponse.nvme_namespaces)
  return _impl_.nvme_namespaces_;
}

// string next_page_token = 2;
inline void ListNvmeNamespacesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListNvmeNamespacesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListNvmeNamespacesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token)
}
inline std::string* ListNvmeNamespacesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token)
  return _s;
}
inline const std::string& ListNvmeNamespacesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListNvmeNamespacesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListNvmeNamespacesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListNvmeNamespacesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListNvmeNamespacesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListNvmeNamespacesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetNvmeNamespaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetNvmeNamespaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetNvmeNamespaceRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetNvmeNamespaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNvmeNamespaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetNvmeNamespaceRequest.name)
}
inline std::string* GetNvmeNamespaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetNvmeNamespaceRequest.name)
  return _s;
}
inline const std::string& GetNvmeNamespaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetNvmeNamespaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNvmeNamespaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNvmeNamespaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetNvmeNamespaceRequest.name)
  return _impl_.name_.Release();
}
inline void GetNvmeNamespaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetNvmeNamespaceRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeNamespaceRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsNvmeNamespaceRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StatsNvmeNamespaceRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeNamespaceRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsNvmeNamespaceRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsNvmeNamespaceRequest.name)
}
inline std::string* StatsNvmeNamespaceRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeNamespaceRequest.name)
  return _s;
}
inline const std::string& StatsNvmeNamespaceRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatsNvmeNamespaceRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatsNvmeNamespaceRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatsNvmeNamespaceRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeNamespaceRequest.name)
  return _impl_.name_.Release();
}
inline void StatsNvmeNamespaceRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeNamespaceRequest.name)
}

// -------------------------------------------------------------------

// StatsNvmeNamespaceResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsNvmeNamespaceResponse::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool StatsNvmeNamespaceResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeNamespaceResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsNvmeNamespaceResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsNvmeNamespaceResponse.stats)
  return _internal_stats();
}
inline void StatsNvmeNamespaceResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsNvmeNamespaceResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeNamespaceResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeNamespaceResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsNvmeNamespaceResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeNamespaceResponse::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsNvmeNamespaceResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsNvmeNamespaceResponse.stats)
  return _msg;
}
inline void StatsNvmeNamespaceResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsNvmeNamespaceResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::opi_api::storage::v1::NvmeNamespacePciState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NvmeNamespacePciState>() {
  return ::opi_api::storage::v1::NvmeNamespacePciState_descriptor();
}
template <> struct is_proto_enum< ::opi_api::storage::v1::NvmeNamespacePciOperState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::opi_api::storage::v1::NvmeNamespacePciOperState>() {
  return ::opi_api::storage::v1::NvmeNamespacePciOperState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_frontend_5fnvme_2eproto
