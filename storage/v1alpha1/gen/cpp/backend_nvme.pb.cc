// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backend_nvme.proto

#include "backend_nvme.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace opi_api {
namespace storage {
namespace v1 {
PROTOBUF_CONSTEXPR NvmeRemoteController::NvmeRemoteController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tcp_)*/nullptr
  , /*decltype(_impl_.io_queues_count_)*/int64_t{0}
  , /*decltype(_impl_.queue_size_)*/int64_t{0}
  , /*decltype(_impl_.multipath_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeRemoteControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeRemoteControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeRemoteControllerDefaultTypeInternal() {}
  union {
    NvmeRemoteController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeRemoteControllerDefaultTypeInternal _NvmeRemoteController_default_instance_;
PROTOBUF_CONSTEXPR TcpController::TcpController(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.psk_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hdgst_)*/false
  , /*decltype(_impl_.ddgst_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TcpControllerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TcpControllerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TcpControllerDefaultTypeInternal() {}
  union {
    TcpController _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TcpControllerDefaultTypeInternal _TcpController_default_instance_;
PROTOBUF_CONSTEXPR NvmePath::NvmePath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controller_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.traddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fabrics_)*/nullptr
  , /*decltype(_impl_.trtype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmePathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmePathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmePathDefaultTypeInternal() {}
  union {
    NvmePath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmePathDefaultTypeInternal _NvmePath_default_instance_;
PROTOBUF_CONSTEXPR FabricsPath::FabricsPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subnqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_traddr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hostnqn_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.trsvcid_)*/int64_t{0}
  , /*decltype(_impl_.source_trsvcid_)*/int64_t{0}
  , /*decltype(_impl_.adrfam_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FabricsPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FabricsPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FabricsPathDefaultTypeInternal() {}
  union {
    FabricsPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FabricsPathDefaultTypeInternal _FabricsPath_default_instance_;
PROTOBUF_CONSTEXPR NvmeRemoteNamespace::NvmeRemoteNamespace(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.controller_name_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nguid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.uuid_)*/nullptr
  , /*decltype(_impl_.eui64_)*/int64_t{0}
  , /*decltype(_impl_.nsid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NvmeRemoteNamespaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NvmeRemoteNamespaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NvmeRemoteNamespaceDefaultTypeInternal() {}
  union {
    NvmeRemoteNamespace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NvmeRemoteNamespaceDefaultTypeInternal _NvmeRemoteNamespace_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controller_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_remote_controller_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    CreateNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmeRemoteControllerRequestDefaultTypeInternal _CreateNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    DeleteNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmeRemoteControllerRequestDefaultTypeInternal _DeleteNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controller_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    UpdateNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmeRemoteControllerRequestDefaultTypeInternal _UpdateNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteControllersRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteControllersRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteControllersRequestDefaultTypeInternal() {}
  union {
    ListNvmeRemoteControllersRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteControllersRequestDefaultTypeInternal _ListNvmeRemoteControllersRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_controllers_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteControllersResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteControllersResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteControllersResponseDefaultTypeInternal() {}
  union {
    ListNvmeRemoteControllersResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteControllersResponseDefaultTypeInternal _ListNvmeRemoteControllersResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    GetNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeRemoteControllerRequestDefaultTypeInternal _GetNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ResetNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    ResetNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetNvmeRemoteControllerRequestDefaultTypeInternal _ResetNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeRemoteControllerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeRemoteControllerRequestDefaultTypeInternal() {}
  union {
    StatsNvmeRemoteControllerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeRemoteControllerRequestDefaultTypeInternal _StatsNvmeRemoteControllerRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmeRemoteControllerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmeRemoteControllerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmeRemoteControllerResponseDefaultTypeInternal() {}
  union {
    StatsNvmeRemoteControllerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmeRemoteControllerResponseDefaultTypeInternal _StatsNvmeRemoteControllerResponse_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteNamespacesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteNamespacesRequestDefaultTypeInternal() {}
  union {
    ListNvmeRemoteNamespacesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteNamespacesRequestDefaultTypeInternal _ListNvmeRemoteNamespacesRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_remote_namespaces_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmeRemoteNamespacesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmeRemoteNamespacesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmeRemoteNamespacesResponseDefaultTypeInternal() {}
  union {
    ListNvmeRemoteNamespacesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmeRemoteNamespacesResponseDefaultTypeInternal _ListNvmeRemoteNamespacesResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmeRemoteNamespaceRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmeRemoteNamespaceRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmeRemoteNamespaceRequestDefaultTypeInternal() {}
  union {
    GetNvmeRemoteNamespaceRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmeRemoteNamespaceRequestDefaultTypeInternal _GetNvmeRemoteNamespaceRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateNvmePathRequest::CreateNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_path_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nvme_path_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNvmePathRequestDefaultTypeInternal() {}
  union {
    CreateNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNvmePathRequestDefaultTypeInternal _CreateNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteNvmePathRequest::DeleteNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteNvmePathRequestDefaultTypeInternal() {}
  union {
    DeleteNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteNvmePathRequestDefaultTypeInternal _DeleteNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateNvmePathRequest::UpdateNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_path_)*/nullptr
  , /*decltype(_impl_.update_mask_)*/nullptr
  , /*decltype(_impl_.allow_missing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNvmePathRequestDefaultTypeInternal() {}
  union {
    UpdateNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNvmePathRequestDefaultTypeInternal _UpdateNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmePathsRequest::ListNvmePathsRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.parent_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.page_size_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmePathsRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmePathsRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmePathsRequestDefaultTypeInternal() {}
  union {
    ListNvmePathsRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmePathsRequestDefaultTypeInternal _ListNvmePathsRequest_default_instance_;
PROTOBUF_CONSTEXPR ListNvmePathsResponse::ListNvmePathsResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nvme_paths_)*/{}
  , /*decltype(_impl_.next_page_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListNvmePathsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNvmePathsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNvmePathsResponseDefaultTypeInternal() {}
  union {
    ListNvmePathsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNvmePathsResponseDefaultTypeInternal _ListNvmePathsResponse_default_instance_;
PROTOBUF_CONSTEXPR GetNvmePathRequest::GetNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetNvmePathRequestDefaultTypeInternal() {}
  union {
    GetNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetNvmePathRequestDefaultTypeInternal _GetNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmePathRequest::StatsNvmePathRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmePathRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmePathRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmePathRequestDefaultTypeInternal() {}
  union {
    StatsNvmePathRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmePathRequestDefaultTypeInternal _StatsNvmePathRequest_default_instance_;
PROTOBUF_CONSTEXPR StatsNvmePathResponse::StatsNvmePathResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stats_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatsNvmePathResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsNvmePathResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsNvmePathResponseDefaultTypeInternal() {}
  union {
    StatsNvmePathResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsNvmePathResponseDefaultTypeInternal _StatsNvmePathResponse_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
static ::_pb::Metadata file_level_metadata_backend_5fnvme_2eproto[25];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_backend_5fnvme_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_backend_5fnvme_2eproto = nullptr;

const uint32_t TableStruct_backend_5fnvme_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.multipath_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.io_queues_count_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.queue_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteController, _impl_.tcp_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _impl_.hdgst_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _impl_.ddgst_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::TcpController, _impl_.psk_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.controller_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.trtype_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.traddr_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmePath, _impl_.fabrics_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.trsvcid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.subnqn_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.adrfam_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.source_traddr_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.source_trsvcid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::FabricsPath, _impl_.hostnqn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.controller_name_ref_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.nsid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.nguid_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.eui64_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::NvmeRemoteNamespace, _impl_.uuid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _impl_.nvme_remote_controllers_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteControllersResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse, _impl_.stats_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _impl_.nvme_remote_namespaces_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.nvme_path_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::CreateNvmePathRequest, _impl_.nvme_path_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::DeleteNvmePathRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.nvme_path_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.update_mask_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::UpdateNvmePathRequest, _impl_.allow_missing_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.page_size_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsRequest, _impl_.page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _impl_.nvme_paths_),
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::ListNvmePathsResponse, _impl_.next_page_token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::GetNvmePathRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathRequest, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::opi_api::storage::v1::StatsNvmePathResponse, _impl_.stats_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::opi_api::storage::v1::NvmeRemoteController)},
  { 11, -1, -1, sizeof(::opi_api::storage::v1::TcpController)},
  { 20, -1, -1, sizeof(::opi_api::storage::v1::NvmePath)},
  { 31, -1, -1, sizeof(::opi_api::storage::v1::FabricsPath)},
  { 43, -1, -1, sizeof(::opi_api::storage::v1::NvmeRemoteNamespace)},
  { 55, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmeRemoteControllerRequest)},
  { 63, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest)},
  { 71, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest)},
  { 80, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteControllersRequest)},
  { 89, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteControllersResponse)},
  { 97, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeRemoteControllerRequest)},
  { 104, -1, -1, sizeof(::opi_api::storage::v1::ResetNvmeRemoteControllerRequest)},
  { 111, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeRemoteControllerRequest)},
  { 118, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmeRemoteControllerResponse)},
  { 125, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest)},
  { 134, -1, -1, sizeof(::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse)},
  { 142, -1, -1, sizeof(::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest)},
  { 149, -1, -1, sizeof(::opi_api::storage::v1::CreateNvmePathRequest)},
  { 157, -1, -1, sizeof(::opi_api::storage::v1::DeleteNvmePathRequest)},
  { 165, -1, -1, sizeof(::opi_api::storage::v1::UpdateNvmePathRequest)},
  { 174, -1, -1, sizeof(::opi_api::storage::v1::ListNvmePathsRequest)},
  { 183, -1, -1, sizeof(::opi_api::storage::v1::ListNvmePathsResponse)},
  { 191, -1, -1, sizeof(::opi_api::storage::v1::GetNvmePathRequest)},
  { 198, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmePathRequest)},
  { 205, -1, -1, sizeof(::opi_api::storage::v1::StatsNvmePathResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::opi_api::storage::v1::_NvmeRemoteController_default_instance_._instance,
  &::opi_api::storage::v1::_TcpController_default_instance_._instance,
  &::opi_api::storage::v1::_NvmePath_default_instance_._instance,
  &::opi_api::storage::v1::_FabricsPath_default_instance_._instance,
  &::opi_api::storage::v1::_NvmeRemoteNamespace_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteControllersRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteControllersResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ResetNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeRemoteControllerRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmeRemoteControllerResponse_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteNamespacesRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmeRemoteNamespacesResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmeRemoteNamespaceRequest_default_instance_._instance,
  &::opi_api::storage::v1::_CreateNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_DeleteNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_UpdateNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmePathsRequest_default_instance_._instance,
  &::opi_api::storage::v1::_ListNvmePathsResponse_default_instance_._instance,
  &::opi_api::storage::v1::_GetNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmePathRequest_default_instance_._instance,
  &::opi_api::storage::v1::_StatsNvmePathResponse_default_instance_._instance,
};

const char descriptor_table_protodef_backend_5fnvme_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022backend_nvme.proto\022\022opi_api.storage.v1"
  "\032\027google/api/client.proto\032\031google/api/re"
  "source.proto\032\033google/protobuf/empty.prot"
  "o\032\034google/api/annotations.proto\032\037google/"
  "api/field_behavior.proto\032 google/protobu"
  "f/field_mask.proto\032\017opicommon.proto\032\nuui"
  "d.proto\"\376\002\n\024NvmeRemoteController\022@\n\004name"
  "\030\001 \001(\tB2\340A\003\340A\005\372A)\n\'opi_api.storage.v1/Nv"
  "meRemoteController\0229\n\tmultipath\030\002 \001(\0162!."
  "opi_api.storage.v1.NvmeMultipathB\003\340A\002\022\034\n"
  "\017io_queues_count\030\003 \001(\003B\003\340A\001\022\027\n\nqueue_siz"
  "e\030\004 \001(\003B\003\340A\001\0223\n\003tcp\030\005 \001(\0132!.opi_api.stor"
  "age.v1.TcpControllerB\003\340A\001:}\352Az\n+storage."
  "opiproject.org/NvmeRemoteController\022\036nvm"
  "eRemoteControllers/{volume}*\025nvmeRemoteC"
  "ontrollers2\024nvmeRemoteController\"I\n\rTcpC"
  "ontroller\022\022\n\005hdgst\030\001 \001(\010B\003\340A\001\022\022\n\005ddgst\030\002"
  " \001(\010B\003\340A\001\022\020\n\003psk\030\003 \001(\014B\003\340A\001\"\345\002\n\010NvmePath"
  "\0224\n\004name\030\001 \001(\tB&\340A\003\340A\005\372A\035\n\033opi_api.stora"
  "ge.v1/NvmePath\022L\n\023controller_name_ref\030\002 "
  "\001(\tB/\340A\002\372A)\n\'opi_api.storage.v1/NvmeRemo"
  "teController\022:\n\006trtype\030\003 \001(\0162%.opi_api.s"
  "torage.v1.NvmeTransportTypeB\003\340A\002\022\023\n\006trad"
  "dr\030\004 \001(\tB\003\340A\002\0225\n\007fabrics\030\005 \001(\0132\037.opi_api"
  ".storage.v1.FabricsPathB\003\340A\001:M\352AJ\n\037stora"
  "ge.opiproject.org/NvmePath\022\022nvmePaths/{v"
  "olume}*\tnvmePaths2\010nvmePath\"\303\001\n\013FabricsP"
  "ath\022\024\n\007trsvcid\030\001 \001(\003B\003\340A\002\022\023\n\006subnqn\030\002 \001("
  "\tB\003\340A\002\022:\n\006adrfam\030\003 \001(\0162%.opi_api.storage"
  ".v1.NvmeAddressFamilyB\003\340A\002\022\032\n\rsource_tra"
  "ddr\030\004 \001(\tB\003\340A\001\022\033\n\016source_trsvcid\030\005 \001(\003B\003"
  "\340A\001\022\024\n\007hostnqn\030\006 \001(\tB\003\340A\001\"\206\003\n\023NvmeRemote"
  "Namespace\022\?\n\004name\030\001 \001(\tB1\340A\003\340A\005\372A(\n&opi_"
  "api.storage.v1/NvmeRemoteNamespace\022L\n\023co"
  "ntroller_name_ref\030\002 \001(\tB/\340A\003\372A)\n\'opi_api"
  ".storage.v1/NvmeRemoteController\022\021\n\004nsid"
  "\030\003 \001(\005B\003\340A\003\022\022\n\005nguid\030\004 \001(\tB\003\340A\003\022\022\n\005eui64"
  "\030\005 \001(\003B\003\340A\003\022*\n\004uuid\030\006 \001(\0132\027.opi_api.comm"
  "on.v1.UuidB\003\340A\003:y\352Av\n*storage.opiproject"
  ".org/NvmeRemoteNamespace\022\035nvmeRemoteName"
  "spaces/{volume}*\024nvmeRemoteNamespaces2\023n"
  "vmeRemoteNamespace\"\232\001\n!CreateNvmeRemoteC"
  "ontrollerRequest\022M\n\026nvme_remote_controll"
  "er\030\001 \001(\0132(.opi_api.storage.v1.NvmeRemote"
  "ControllerB\003\340A\002\022&\n\031nvme_remote_controlle"
  "r_id\030\002 \001(\tB\003\340A\001\"~\n!DeleteNvmeRemoteContr"
  "ollerRequest\022=\n\004name\030\001 \001(\tB/\340A\002\372A)\n\'opi_"
  "api.storage.v1/NvmeRemoteController\022\032\n\ra"
  "llow_missing\030\002 \001(\010B\003\340A\001\"\304\001\n!UpdateNvmeRe"
  "moteControllerRequest\022M\n\026nvme_remote_con"
  "troller\030\001 \001(\0132(.opi_api.storage.v1.NvmeR"
  "emoteControllerB\003\340A\002\0224\n\013update_mask\030\002 \001("
  "\0132\032.google.protobuf.FieldMaskB\003\340A\001\022\032\n\ral"
  "low_missing\030\003 \001(\010B\003\340A\001\"\224\001\n ListNvmeRemot"
  "eControllersRequest\022\?\n\006parent\030\001 \001(\tB/\340A\002"
  "\372A)\n\'opi_api.storage.v1/NvmeRemoteContro"
  "ller\022\026\n\tpage_size\030\002 \001(\005B\003\340A\001\022\027\n\npage_tok"
  "en\030\003 \001(\tB\003\340A\001\"\207\001\n!ListNvmeRemoteControll"
  "ersResponse\022I\n\027nvme_remote_controllers\030\001"
  " \003(\0132(.opi_api.storage.v1.NvmeRemoteCont"
  "roller\022\027\n\017next_page_token\030\002 \001(\t\"_\n\036GetNv"
  "meRemoteControllerRequest\022=\n\004name\030\001 \001(\tB"
  "/\340A\002\372A)\n\'opi_api.storage.v1/NvmeRemoteCo"
  "ntroller\"a\n ResetNvmeRemoteControllerReq"
  "uest\022=\n\004name\030\001 \001(\tB/\340A\002\372A)\n\'opi_api.stor"
  "age.v1/NvmeRemoteController\"a\n StatsNvme"
  "RemoteControllerRequest\022=\n\004name\030\001 \001(\tB/\340"
  "A\002\372A)\n\'opi_api.storage.v1/NvmeRemoteCont"
  "roller\"S\n!StatsNvmeRemoteControllerRespo"
  "nse\022.\n\005stats\030\001 \001(\0132\037.opi_api.storage.v1."
  "VolumeStats\"\222\001\n\037ListNvmeRemoteNamespaces"
  "Request\022>\n\006parent\030\001 \001(\tB.\340A\002\372A(\n&opi_api"
  ".storage.v1/NvmeRemoteNamespace\022\026\n\tpage_"
  "size\030\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 \001(\tB\003\340A\001"
  "\"\204\001\n ListNvmeRemoteNamespacesResponse\022G\n"
  "\026nvme_remote_namespaces\030\001 \003(\0132\'.opi_api."
  "storage.v1.NvmeRemoteNamespace\022\027\n\017next_p"
  "age_token\030\002 \001(\t\"]\n\035GetNvmeRemoteNamespac"
  "eRequest\022<\n\004name\030\001 \001(\tB.\340A\002\372A(\n&opi_api."
  "storage.v1/NvmeRemoteNamespace\"h\n\025Create"
  "NvmePathRequest\0224\n\tnvme_path\030\001 \001(\0132\034.opi"
  "_api.storage.v1.NvmePathB\003\340A\002\022\031\n\014nvme_pa"
  "th_id\030\002 \001(\tB\003\340A\001\"f\n\025DeleteNvmePathReques"
  "t\0221\n\004name\030\001 \001(\tB#\340A\002\372A\035\n\033opi_api.storage"
  ".v1/NvmePath\022\032\n\rallow_missing\030\002 \001(\010B\003\340A\001"
  "\"\237\001\n\025UpdateNvmePathRequest\0224\n\tnvme_path\030"
  "\001 \001(\0132\034.opi_api.storage.v1.NvmePathB\003\340A\002"
  "\0224\n\013update_mask\030\002 \001(\0132\032.google.protobuf."
  "FieldMaskB\003\340A\001\022\032\n\rallow_missing\030\003 \001(\010B\003\340"
  "A\001\"|\n\024ListNvmePathsRequest\0223\n\006parent\030\001 \001"
  "(\tB#\340A\002\372A\035\n\033opi_api.storage.v1/NvmePath\022"
  "\026\n\tpage_size\030\002 \001(\005B\003\340A\001\022\027\n\npage_token\030\003 "
  "\001(\tB\003\340A\001\"b\n\025ListNvmePathsResponse\0220\n\nnvm"
  "e_paths\030\001 \003(\0132\034.opi_api.storage.v1.NvmeP"
  "ath\022\027\n\017next_page_token\030\002 \001(\t\"G\n\022GetNvmeP"
  "athRequest\0221\n\004name\030\001 \001(\tB#\340A\002\372A\035\n\033opi_ap"
  "i.storage.v1/NvmePath\"I\n\024StatsNvmePathRe"
  "quest\0221\n\004name\030\001 \001(\tB#\340A\002\372A\035\n\033opi_api.sto"
  "rage.v1/NvmePath\"G\n\025StatsNvmePathRespons"
  "e\022.\n\005stats\030\001 \001(\0132\037.opi_api.storage.v1.Vo"
  "lumeStats*\206\001\n\rNvmeMultipath\022\036\n\032NVME_MULT"
  "IPATH_UNSPECIFIED\020\000\022\032\n\026NVME_MULTIPATH_DI"
  "SABLE\020\001\022\033\n\027NVME_MULTIPATH_FAILOVER\020\002\022\034\n\030"
  "NVME_MULTIPATH_MULTIPATH\020\0032\262\024\n\033NvmeRemot"
  "eControllerService\022\353\001\n\032CreateNvmeRemoteC"
  "ontroller\0225.opi_api.storage.v1.CreateNvm"
  "eRemoteControllerRequest\032(.opi_api.stora"
  "ge.v1.NvmeRemoteController\"l\202\323\344\223\0023\"\031/v1/"
  "nvmeRemoteControllers:\026nvme_remote_contr"
  "oller\332A0nvme_remote_controller,nvme_remo"
  "te_controller_id\022\236\001\n\032DeleteNvmeRemoteCon"
  "troller\0225.opi_api.storage.v1.DeleteNvmeR"
  "emoteControllerRequest\032\026.google.protobuf"
  ".Empty\"1\202\323\344\223\002$*\"/v1/{name=nvmeRemoteCont"
  "rollers/*}\332A\004name\022\375\001\n\032UpdateNvmeRemoteCo"
  "ntroller\0225.opi_api.storage.v1.UpdateNvme"
  "RemoteControllerRequest\032(.opi_api.storag"
  "e.v1.NvmeRemoteController\"~\202\323\344\223\002S29/v1/{"
  "nvme_remote_controller.name=nvmeRemoteCo"
  "ntrollers/*}:\026nvme_remote_controller\332A\"n"
  "vme_remote_controller,update_mask\022\262\001\n\031Li"
  "stNvmeRemoteControllers\0224.opi_api.storag"
  "e.v1.ListNvmeRemoteControllersRequest\0325."
  "opi_api.storage.v1.ListNvmeRemoteControl"
  "lersResponse\"(\202\323\344\223\002\031\022\027/v1/{parent=subsys"
  "tems}\332A\006parent\022\252\001\n\027GetNvmeRemoteControll"
  "er\0222.opi_api.storage.v1.GetNvmeRemoteCon"
  "trollerRequest\032(.opi_api.storage.v1.Nvme"
  "RemoteController\"1\202\323\344\223\002$\022\"/v1/{name=nvme"
  "RemoteControllers/*}\332A\004name\022\245\001\n\031ResetNvm"
  "eRemoteController\0224.opi_api.storage.v1.R"
  "esetNvmeRemoteControllerRequest\032\026.google"
  ".protobuf.Empty\":\202\323\344\223\002-\"(/v1/{name=nvmeR"
  "emoteControllers/*}:reset:\001*\332A\004name\022\301\001\n\031"
  "StatsNvmeRemoteController\0224.opi_api.stor"
  "age.v1.StatsNvmeRemoteControllerRequest\032"
  "5.opi_api.storage.v1.StatsNvmeRemoteCont"
  "rollerResponse\"7\202\323\344\223\002*\022(/v1/{name=nvmeRe"
  "moteControllers/*}:stats\332A\004name\022\257\001\n\030List"
  "NvmeRemoteNamespaces\0223.opi_api.storage.v"
  "1.ListNvmeRemoteNamespacesRequest\0324.opi_"
  "api.storage.v1.ListNvmeRemoteNamespacesR"
  "esponse\"(\202\323\344\223\002\031\022\027/v1/{parent=subsystems}"
  "\332A\006parent\022\246\001\n\026GetNvmeRemoteNamespace\0221.o"
  "pi_api.storage.v1.GetNvmeRemoteNamespace"
  "Request\032\'.opi_api.storage.v1.NvmeRemoteN"
  "amespace\"0\202\323\344\223\002#\022!/v1/{name=nvmeRemoteNa"
  "mespaces/*}\332A\004name\022\224\001\n\016CreateNvmePath\022)."
  "opi_api.storage.v1.CreateNvmePathRequest"
  "\032\034.opi_api.storage.v1.NvmePath\"9\202\323\344\223\002\032\"\r"
  "/v1/nvmePaths:\tnvme_path\332A\026nvme_path,nvm"
  "e_path_id\022z\n\016DeleteNvmePath\022).opi_api.st"
  "orage.v1.DeleteNvmePathRequest\032\026.google."
  "protobuf.Empty\"%\202\323\344\223\002\030*\026/v1/{name=nvmePa"
  "ths/*}\332A\004name\022\246\001\n\016UpdateNvmePath\022).opi_a"
  "pi.storage.v1.UpdateNvmePathRequest\032\034.op"
  "i_api.storage.v1.NvmePath\"K\202\323\344\223\002-2 /v1/{"
  "nvme_path.name=nvmePaths/*}:\tnvme_path\332A"
  "\025nvme_path,update_mask\022\216\001\n\rListNvmePaths"
  "\022(.opi_api.storage.v1.ListNvmePathsReque"
  "st\032).opi_api.storage.v1.ListNvmePathsRes"
  "ponse\"(\202\323\344\223\002\031\022\027/v1/{parent=subsystems}\332A"
  "\006parent\022z\n\013GetNvmePath\022&.opi_api.storage"
  ".v1.GetNvmePathRequest\032\034.opi_api.storage"
  ".v1.NvmePath\"%\202\323\344\223\002\030\022\026/v1/{name=nvmePath"
  "s/*}\332A\004name\022\221\001\n\rStatsNvmePath\022(.opi_api."
  "storage.v1.StatsNvmePathRequest\032).opi_ap"
  "i.storage.v1.StatsNvmePathResponse\"+\202\323\344\223"
  "\002\036\022\034/v1/{name=nvmePaths/*}:stats\332A\004nameB"
  "_\n\022opi_api.storage.v1B\020BackendNvmeProtoP"
  "\001Z5github.com/opiproject/opi-api/storage"
  "/v1alpha1/gen/gob\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_backend_5fnvme_2eproto_deps[8] = {
  &::descriptor_table_google_2fapi_2fannotations_2eproto,
  &::descriptor_table_google_2fapi_2fclient_2eproto,
  &::descriptor_table_google_2fapi_2ffield_5fbehavior_2eproto,
  &::descriptor_table_google_2fapi_2fresource_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
  &::descriptor_table_google_2fprotobuf_2ffield_5fmask_2eproto,
  &::descriptor_table_opicommon_2eproto,
  &::descriptor_table_uuid_2eproto,
};
static ::_pbi::once_flag descriptor_table_backend_5fnvme_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_backend_5fnvme_2eproto = {
    false, false, 6864, descriptor_table_protodef_backend_5fnvme_2eproto,
    "backend_nvme.proto",
    &descriptor_table_backend_5fnvme_2eproto_once, descriptor_table_backend_5fnvme_2eproto_deps, 8, 25,
    schemas, file_default_instances, TableStruct_backend_5fnvme_2eproto::offsets,
    file_level_metadata_backend_5fnvme_2eproto, file_level_enum_descriptors_backend_5fnvme_2eproto,
    file_level_service_descriptors_backend_5fnvme_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_backend_5fnvme_2eproto_getter() {
  return &descriptor_table_backend_5fnvme_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_backend_5fnvme_2eproto(&descriptor_table_backend_5fnvme_2eproto);
namespace opi_api {
namespace storage {
namespace v1 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NvmeMultipath_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_backend_5fnvme_2eproto);
  return file_level_enum_descriptors_backend_5fnvme_2eproto[0];
}
bool NvmeMultipath_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class NvmeRemoteController::_Internal {
 public:
  static const ::opi_api::storage::v1::TcpController& tcp(const NvmeRemoteController* msg);
};

const ::opi_api::storage::v1::TcpController&
NvmeRemoteController::_Internal::tcp(const NvmeRemoteController* msg) {
  return *msg->_impl_.tcp_;
}
NvmeRemoteController::NvmeRemoteController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeRemoteController)
}
NvmeRemoteController::NvmeRemoteController(const NvmeRemoteController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeRemoteController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.io_queues_count_){}
    , decltype(_impl_.queue_size_){}
    , decltype(_impl_.multipath_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tcp()) {
    _this->_impl_.tcp_ = new ::opi_api::storage::v1::TcpController(*from._impl_.tcp_);
  }
  ::memcpy(&_impl_.io_queues_count_, &from._impl_.io_queues_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.multipath_) -
    reinterpret_cast<char*>(&_impl_.io_queues_count_)) + sizeof(_impl_.multipath_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeRemoteController)
}

inline void NvmeRemoteController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.io_queues_count_){int64_t{0}}
    , decltype(_impl_.queue_size_){int64_t{0}}
    , decltype(_impl_.multipath_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeRemoteController::~NvmeRemoteController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeRemoteController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeRemoteController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tcp_;
}

void NvmeRemoteController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeRemoteController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeRemoteController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.tcp_ != nullptr) {
    delete _impl_.tcp_;
  }
  _impl_.tcp_ = nullptr;
  ::memset(&_impl_.io_queues_count_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.multipath_) -
      reinterpret_cast<char*>(&_impl_.io_queues_count_)) + sizeof(_impl_.multipath_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeRemoteController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteController.name"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_multipath(static_cast<::opi_api::storage::v1::NvmeMultipath>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.io_queues_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeRemoteController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeRemoteController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteController.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_multipath() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_multipath(), target);
  }

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_io_queues_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_io_queues_count(), target);
  }

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_queue_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_queue_size(), target);
  }

  // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_tcp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::tcp(this),
        _Internal::tcp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeRemoteController)
  return target;
}

size_t NvmeRemoteController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeRemoteController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .opi_api.storage.v1.TcpController tcp = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_tcp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tcp_);
  }

  // int64 io_queues_count = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_io_queues_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_io_queues_count());
  }

  // int64 queue_size = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_queue_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_queue_size());
  }

  // .opi_api.storage.v1.NvmeMultipath multipath = 2 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_multipath() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_multipath());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeRemoteController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeRemoteController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeRemoteController::GetClassData() const { return &_class_data_; }


void NvmeRemoteController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeRemoteController*>(&to_msg);
  auto& from = static_cast<const NvmeRemoteController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeRemoteController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_tcp()) {
    _this->_internal_mutable_tcp()->::opi_api::storage::v1::TcpController::MergeFrom(
        from._internal_tcp());
  }
  if (from._internal_io_queues_count() != 0) {
    _this->_internal_set_io_queues_count(from._internal_io_queues_count());
  }
  if (from._internal_queue_size() != 0) {
    _this->_internal_set_queue_size(from._internal_queue_size());
  }
  if (from._internal_multipath() != 0) {
    _this->_internal_set_multipath(from._internal_multipath());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeRemoteController::CopyFrom(const NvmeRemoteController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeRemoteController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeRemoteController::IsInitialized() const {
  return true;
}

void NvmeRemoteController::InternalSwap(NvmeRemoteController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeRemoteController, _impl_.multipath_)
      + sizeof(NvmeRemoteController::_impl_.multipath_)
      - PROTOBUF_FIELD_OFFSET(NvmeRemoteController, _impl_.tcp_)>(
          reinterpret_cast<char*>(&_impl_.tcp_),
          reinterpret_cast<char*>(&other->_impl_.tcp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeRemoteController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[0]);
}

// ===================================================================

class TcpController::_Internal {
 public:
};

TcpController::TcpController(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.TcpController)
}
TcpController::TcpController(const TcpController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TcpController* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.psk_){}
    , decltype(_impl_.hdgst_){}
    , decltype(_impl_.ddgst_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.psk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.psk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_psk().empty()) {
    _this->_impl_.psk_.Set(from._internal_psk(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hdgst_, &from._impl_.hdgst_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ddgst_) -
    reinterpret_cast<char*>(&_impl_.hdgst_)) + sizeof(_impl_.ddgst_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.TcpController)
}

inline void TcpController::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.psk_){}
    , decltype(_impl_.hdgst_){false}
    , decltype(_impl_.ddgst_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.psk_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.psk_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TcpController::~TcpController() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.TcpController)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TcpController::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.psk_.Destroy();
}

void TcpController::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TcpController::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.TcpController)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.psk_.ClearToEmpty();
  ::memset(&_impl_.hdgst_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ddgst_) -
      reinterpret_cast<char*>(&_impl_.hdgst_)) + sizeof(_impl_.ddgst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TcpController::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hdgst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ddgst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_psk();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TcpController::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.TcpController)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_hdgst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_hdgst(), target);
  }

  // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_ddgst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_ddgst(), target);
  }

  // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_psk().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_psk(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.TcpController)
  return target;
}

size_t TcpController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.TcpController)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes psk = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_psk().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_psk());
  }

  // bool hdgst = 1 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_hdgst() != 0) {
    total_size += 1 + 1;
  }

  // bool ddgst = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_ddgst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TcpController::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TcpController::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TcpController::GetClassData() const { return &_class_data_; }


void TcpController::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TcpController*>(&to_msg);
  auto& from = static_cast<const TcpController&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.TcpController)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_psk().empty()) {
    _this->_internal_set_psk(from._internal_psk());
  }
  if (from._internal_hdgst() != 0) {
    _this->_internal_set_hdgst(from._internal_hdgst());
  }
  if (from._internal_ddgst() != 0) {
    _this->_internal_set_ddgst(from._internal_ddgst());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TcpController::CopyFrom(const TcpController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.TcpController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpController::IsInitialized() const {
  return true;
}

void TcpController::InternalSwap(TcpController* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.psk_, lhs_arena,
      &other->_impl_.psk_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TcpController, _impl_.ddgst_)
      + sizeof(TcpController::_impl_.ddgst_)
      - PROTOBUF_FIELD_OFFSET(TcpController, _impl_.hdgst_)>(
          reinterpret_cast<char*>(&_impl_.hdgst_),
          reinterpret_cast<char*>(&other->_impl_.hdgst_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TcpController::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[1]);
}

// ===================================================================

class NvmePath::_Internal {
 public:
  static const ::opi_api::storage::v1::FabricsPath& fabrics(const NvmePath* msg);
};

const ::opi_api::storage::v1::FabricsPath&
NvmePath::_Internal::fabrics(const NvmePath* msg) {
  return *msg->_impl_.fabrics_;
}
NvmePath::NvmePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmePath)
}
NvmePath::NvmePath(const NvmePath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmePath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.traddr_){}
    , decltype(_impl_.fabrics_){nullptr}
    , decltype(_impl_.trtype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_controller_name_ref().empty()) {
    _this->_impl_.controller_name_ref_.Set(from._internal_controller_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_traddr().empty()) {
    _this->_impl_.traddr_.Set(from._internal_traddr(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_fabrics()) {
    _this->_impl_.fabrics_ = new ::opi_api::storage::v1::FabricsPath(*from._impl_.fabrics_);
  }
  _this->_impl_.trtype_ = from._impl_.trtype_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmePath)
}

inline void NvmePath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.traddr_){}
    , decltype(_impl_.fabrics_){nullptr}
    , decltype(_impl_.trtype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmePath::~NvmePath() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmePath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmePath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.controller_name_ref_.Destroy();
  _impl_.traddr_.Destroy();
  if (this != internal_default_instance()) delete _impl_.fabrics_;
}

void NvmePath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmePath::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmePath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.controller_name_ref_.ClearToEmpty();
  _impl_.traddr_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.fabrics_ != nullptr) {
    delete _impl_.fabrics_;
  }
  _impl_.fabrics_ = nullptr;
  _impl_.trtype_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmePath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.name"));
        } else
          goto handle_unusual;
        continue;
      // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.controller_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_trtype(static_cast<::opi_api::storage::v1::NvmeTransportType>(val));
        } else
          goto handle_unusual;
        continue;
      // string traddr = 4 [(.google.api.field_behavior) = REQUIRED];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_traddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmePath.traddr"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.FabricsPath fabrics = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_fabrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmePath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmePath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_controller_name_ref().data(), static_cast<int>(this->_internal_controller_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.controller_name_ref");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_name_ref(), target);
  }

  // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_trtype(), target);
  }

  // string traddr = 4 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_traddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_traddr().data(), static_cast<int>(this->_internal_traddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmePath.traddr");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_traddr(), target);
  }

  // .opi_api.storage.v1.FabricsPath fabrics = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_fabrics()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::fabrics(this),
        _Internal::fabrics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmePath)
  return target;
}

size_t NvmePath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmePath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_controller_name_ref());
  }

  // string traddr = 4 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_traddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_traddr());
  }

  // .opi_api.storage.v1.FabricsPath fabrics = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_fabrics()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fabrics_);
  }

  // .opi_api.storage.v1.NvmeTransportType trtype = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trtype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_trtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmePath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmePath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmePath::GetClassData() const { return &_class_data_; }


void NvmePath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmePath*>(&to_msg);
  auto& from = static_cast<const NvmePath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmePath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_controller_name_ref().empty()) {
    _this->_internal_set_controller_name_ref(from._internal_controller_name_ref());
  }
  if (!from._internal_traddr().empty()) {
    _this->_internal_set_traddr(from._internal_traddr());
  }
  if (from._internal_has_fabrics()) {
    _this->_internal_mutable_fabrics()->::opi_api::storage::v1::FabricsPath::MergeFrom(
        from._internal_fabrics());
  }
  if (from._internal_trtype() != 0) {
    _this->_internal_set_trtype(from._internal_trtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmePath::CopyFrom(const NvmePath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmePath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmePath::IsInitialized() const {
  return true;
}

void NvmePath::InternalSwap(NvmePath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.controller_name_ref_, lhs_arena,
      &other->_impl_.controller_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.traddr_, lhs_arena,
      &other->_impl_.traddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmePath, _impl_.trtype_)
      + sizeof(NvmePath::_impl_.trtype_)
      - PROTOBUF_FIELD_OFFSET(NvmePath, _impl_.fabrics_)>(
          reinterpret_cast<char*>(&_impl_.fabrics_),
          reinterpret_cast<char*>(&other->_impl_.fabrics_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmePath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[2]);
}

// ===================================================================

class FabricsPath::_Internal {
 public:
};

FabricsPath::FabricsPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.FabricsPath)
}
FabricsPath::FabricsPath(const FabricsPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FabricsPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subnqn_){}
    , decltype(_impl_.source_traddr_){}
    , decltype(_impl_.hostnqn_){}
    , decltype(_impl_.trsvcid_){}
    , decltype(_impl_.source_trsvcid_){}
    , decltype(_impl_.adrfam_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.subnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_subnqn().empty()) {
    _this->_impl_.subnqn_.Set(from._internal_subnqn(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_traddr().empty()) {
    _this->_impl_.source_traddr_.Set(from._internal_source_traddr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.hostnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hostnqn().empty()) {
    _this->_impl_.hostnqn_.Set(from._internal_hostnqn(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.trsvcid_, &from._impl_.trsvcid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.adrfam_) -
    reinterpret_cast<char*>(&_impl_.trsvcid_)) + sizeof(_impl_.adrfam_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.FabricsPath)
}

inline void FabricsPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.subnqn_){}
    , decltype(_impl_.source_traddr_){}
    , decltype(_impl_.hostnqn_){}
    , decltype(_impl_.trsvcid_){int64_t{0}}
    , decltype(_impl_.source_trsvcid_){int64_t{0}}
    , decltype(_impl_.adrfam_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.subnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_traddr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_traddr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.hostnqn_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostnqn_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FabricsPath::~FabricsPath() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.FabricsPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FabricsPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subnqn_.Destroy();
  _impl_.source_traddr_.Destroy();
  _impl_.hostnqn_.Destroy();
}

void FabricsPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FabricsPath::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.FabricsPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subnqn_.ClearToEmpty();
  _impl_.source_traddr_.ClearToEmpty();
  _impl_.hostnqn_.ClearToEmpty();
  ::memset(&_impl_.trsvcid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.adrfam_) -
      reinterpret_cast<char*>(&_impl_.trsvcid_)) + sizeof(_impl_.adrfam_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FabricsPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.trsvcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_subnqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.FabricsPath.subnqn"));
        } else
          goto handle_unusual;
        continue;
      // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_adrfam(static_cast<::opi_api::storage::v1::NvmeAddressFamily>(val));
        } else
          goto handle_unusual;
        continue;
      // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_source_traddr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.FabricsPath.source_traddr"));
        } else
          goto handle_unusual;
        continue;
      // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.source_trsvcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_hostnqn();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.FabricsPath.hostnqn"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FabricsPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.FabricsPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trsvcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_trsvcid(), target);
  }

  // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_subnqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_subnqn().data(), static_cast<int>(this->_internal_subnqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.FabricsPath.subnqn");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_subnqn(), target);
  }

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_adrfam() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_adrfam(), target);
  }

  // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_source_traddr().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source_traddr().data(), static_cast<int>(this->_internal_source_traddr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.FabricsPath.source_traddr");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_source_traddr(), target);
  }

  // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_source_trsvcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_source_trsvcid(), target);
  }

  // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_hostnqn().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hostnqn().data(), static_cast<int>(this->_internal_hostnqn().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.FabricsPath.hostnqn");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_hostnqn(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.FabricsPath)
  return target;
}

size_t FabricsPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.FabricsPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string subnqn = 2 [(.google.api.field_behavior) = REQUIRED];
  if (!this->_internal_subnqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_subnqn());
  }

  // string source_traddr = 4 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_source_traddr().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source_traddr());
  }

  // string hostnqn = 6 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_hostnqn().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostnqn());
  }

  // int64 trsvcid = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_trsvcid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_trsvcid());
  }

  // int64 source_trsvcid = 5 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_source_trsvcid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_source_trsvcid());
  }

  // .opi_api.storage.v1.NvmeAddressFamily adrfam = 3 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_adrfam() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_adrfam());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FabricsPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FabricsPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FabricsPath::GetClassData() const { return &_class_data_; }


void FabricsPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FabricsPath*>(&to_msg);
  auto& from = static_cast<const FabricsPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.FabricsPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_subnqn().empty()) {
    _this->_internal_set_subnqn(from._internal_subnqn());
  }
  if (!from._internal_source_traddr().empty()) {
    _this->_internal_set_source_traddr(from._internal_source_traddr());
  }
  if (!from._internal_hostnqn().empty()) {
    _this->_internal_set_hostnqn(from._internal_hostnqn());
  }
  if (from._internal_trsvcid() != 0) {
    _this->_internal_set_trsvcid(from._internal_trsvcid());
  }
  if (from._internal_source_trsvcid() != 0) {
    _this->_internal_set_source_trsvcid(from._internal_source_trsvcid());
  }
  if (from._internal_adrfam() != 0) {
    _this->_internal_set_adrfam(from._internal_adrfam());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FabricsPath::CopyFrom(const FabricsPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.FabricsPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FabricsPath::IsInitialized() const {
  return true;
}

void FabricsPath::InternalSwap(FabricsPath* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.subnqn_, lhs_arena,
      &other->_impl_.subnqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_traddr_, lhs_arena,
      &other->_impl_.source_traddr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hostnqn_, lhs_arena,
      &other->_impl_.hostnqn_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FabricsPath, _impl_.adrfam_)
      + sizeof(FabricsPath::_impl_.adrfam_)
      - PROTOBUF_FIELD_OFFSET(FabricsPath, _impl_.trsvcid_)>(
          reinterpret_cast<char*>(&_impl_.trsvcid_),
          reinterpret_cast<char*>(&other->_impl_.trsvcid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FabricsPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[3]);
}

// ===================================================================

class NvmeRemoteNamespace::_Internal {
 public:
  static const ::opi_api::common::v1::Uuid& uuid(const NvmeRemoteNamespace* msg);
};

const ::opi_api::common::v1::Uuid&
NvmeRemoteNamespace::_Internal::uuid(const NvmeRemoteNamespace* msg) {
  return *msg->_impl_.uuid_;
}
void NvmeRemoteNamespace::clear_uuid() {
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
}
NvmeRemoteNamespace::NvmeRemoteNamespace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.NvmeRemoteNamespace)
}
NvmeRemoteNamespace::NvmeRemoteNamespace(const NvmeRemoteNamespace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NvmeRemoteNamespace* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.nguid_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){}
    , decltype(_impl_.nsid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_controller_name_ref().empty()) {
    _this->_impl_.controller_name_ref_.Set(from._internal_controller_name_ref(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nguid().empty()) {
    _this->_impl_.nguid_.Set(from._internal_nguid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_uuid()) {
    _this->_impl_.uuid_ = new ::opi_api::common::v1::Uuid(*from._impl_.uuid_);
  }
  ::memcpy(&_impl_.eui64_, &from._impl_.eui64_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nsid_) -
    reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.nsid_));
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.NvmeRemoteNamespace)
}

inline void NvmeRemoteNamespace::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.controller_name_ref_){}
    , decltype(_impl_.nguid_){}
    , decltype(_impl_.uuid_){nullptr}
    , decltype(_impl_.eui64_){int64_t{0}}
    , decltype(_impl_.nsid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.controller_name_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.controller_name_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nguid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nguid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NvmeRemoteNamespace::~NvmeRemoteNamespace() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.NvmeRemoteNamespace)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NvmeRemoteNamespace::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.controller_name_ref_.Destroy();
  _impl_.nguid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.uuid_;
}

void NvmeRemoteNamespace::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NvmeRemoteNamespace::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.NvmeRemoteNamespace)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.controller_name_ref_.ClearToEmpty();
  _impl_.nguid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.uuid_ != nullptr) {
    delete _impl_.uuid_;
  }
  _impl_.uuid_ = nullptr;
  ::memset(&_impl_.eui64_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.nsid_) -
      reinterpret_cast<char*>(&_impl_.eui64_)) + sizeof(_impl_.nsid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NvmeRemoteNamespace::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.name"));
        } else
          goto handle_unusual;
        continue;
      // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_name_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref"));
        } else
          goto handle_unusual;
        continue;
      // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.nsid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nguid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.NvmeRemoteNamespace.nguid"));
        } else
          goto handle_unusual;
        continue;
      // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.eui64_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_uuid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NvmeRemoteNamespace::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.NvmeRemoteNamespace)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_controller_name_ref().data(), static_cast<int>(this->_internal_controller_name_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.controller_name_ref");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_name_ref(), target);
  }

  // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_nsid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_nsid(), target);
  }

  // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_nguid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nguid().data(), static_cast<int>(this->_internal_nguid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.NvmeRemoteNamespace.nguid");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nguid(), target);
  }

  // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_eui64() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_eui64(), target);
  }

  // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_uuid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::uuid(this),
        _Internal::uuid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.NvmeRemoteNamespace)
  return target;
}

size_t NvmeRemoteNamespace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.NvmeRemoteNamespace)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string controller_name_ref = 2 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.resource_reference) = {
  if (!this->_internal_controller_name_ref().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_controller_name_ref());
  }

  // string nguid = 4 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (!this->_internal_nguid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nguid());
  }

  // .opi_api.common.v1.Uuid uuid = 6 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_has_uuid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uuid_);
  }

  // int64 eui64 = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_eui64() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_eui64());
  }

  // int32 nsid = 3 [(.google.api.field_behavior) = OUTPUT_ONLY];
  if (this->_internal_nsid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nsid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NvmeRemoteNamespace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NvmeRemoteNamespace::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NvmeRemoteNamespace::GetClassData() const { return &_class_data_; }


void NvmeRemoteNamespace::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NvmeRemoteNamespace*>(&to_msg);
  auto& from = static_cast<const NvmeRemoteNamespace&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.NvmeRemoteNamespace)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_controller_name_ref().empty()) {
    _this->_internal_set_controller_name_ref(from._internal_controller_name_ref());
  }
  if (!from._internal_nguid().empty()) {
    _this->_internal_set_nguid(from._internal_nguid());
  }
  if (from._internal_has_uuid()) {
    _this->_internal_mutable_uuid()->::opi_api::common::v1::Uuid::MergeFrom(
        from._internal_uuid());
  }
  if (from._internal_eui64() != 0) {
    _this->_internal_set_eui64(from._internal_eui64());
  }
  if (from._internal_nsid() != 0) {
    _this->_internal_set_nsid(from._internal_nsid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NvmeRemoteNamespace::CopyFrom(const NvmeRemoteNamespace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.NvmeRemoteNamespace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NvmeRemoteNamespace::IsInitialized() const {
  return true;
}

void NvmeRemoteNamespace::InternalSwap(NvmeRemoteNamespace* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.controller_name_ref_, lhs_arena,
      &other->_impl_.controller_name_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nguid_, lhs_arena,
      &other->_impl_.nguid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NvmeRemoteNamespace, _impl_.nsid_)
      + sizeof(NvmeRemoteNamespace::_impl_.nsid_)
      - PROTOBUF_FIELD_OFFSET(NvmeRemoteNamespace, _impl_.uuid_)>(
          reinterpret_cast<char*>(&_impl_.uuid_),
          reinterpret_cast<char*>(&other->_impl_.uuid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NvmeRemoteNamespace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[4]);
}

// ===================================================================

class CreateNvmeRemoteControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller(const CreateNvmeRemoteControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeRemoteController&
CreateNvmeRemoteControllerRequest::_Internal::nvme_remote_controller(const CreateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.nvme_remote_controller_;
}
CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
}
CreateNvmeRemoteControllerRequest::CreateNvmeRemoteControllerRequest(const CreateNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_id_){}
    , decltype(_impl_.nvme_remote_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nvme_remote_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_remote_controller_id().empty()) {
    _this->_impl_.nvme_remote_controller_id_.Set(from._internal_nvme_remote_controller_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_remote_controller()) {
    _this->_impl_.nvme_remote_controller_ = new ::opi_api::storage::v1::NvmeRemoteController(*from._impl_.nvme_remote_controller_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
}

inline void CreateNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_id_){}
    , decltype(_impl_.nvme_remote_controller_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nvme_remote_controller_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_remote_controller_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmeRemoteControllerRequest::~CreateNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_controller_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_remote_controller_;
}

void CreateNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_controller_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_remote_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_remote_controller_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_remote_controller(this),
        _Internal::nvme_remote_controller(this).GetCachedSize(), target, stream);
  }

  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_remote_controller_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_remote_controller_id().data(), static_cast<int>(this->_internal_nvme_remote_controller_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmeRemoteControllerRequest.nvme_remote_controller_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_remote_controller_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  return target;
}

size_t CreateNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_remote_controller_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_remote_controller_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_remote_controller_id());
  }

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_remote_controller_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void CreateNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_remote_controller_id().empty()) {
    _this->_internal_set_nvme_remote_controller_id(from._internal_nvme_remote_controller_id());
  }
  if (from._internal_has_nvme_remote_controller()) {
    _this->_internal_mutable_nvme_remote_controller()->::opi_api::storage::v1::NvmeRemoteController::MergeFrom(
        from._internal_nvme_remote_controller());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmeRemoteControllerRequest::CopyFrom(const CreateNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void CreateNvmeRemoteControllerRequest::InternalSwap(CreateNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_remote_controller_id_, lhs_arena,
      &other->_impl_.nvme_remote_controller_id_, rhs_arena
  );
  swap(_impl_.nvme_remote_controller_, other->_impl_.nvme_remote_controller_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[5]);
}

// ===================================================================

class DeleteNvmeRemoteControllerRequest::_Internal {
 public:
};

DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
}
DeleteNvmeRemoteControllerRequest::DeleteNvmeRemoteControllerRequest(const DeleteNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
}

inline void DeleteNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmeRemoteControllerRequest::~DeleteNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  return target;
}

size_t DeleteNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmeRemoteControllerRequest::CopyFrom(const DeleteNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void DeleteNvmeRemoteControllerRequest::InternalSwap(DeleteNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[6]);
}

// ===================================================================

class UpdateNvmeRemoteControllerRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmeRemoteController& nvme_remote_controller(const UpdateNvmeRemoteControllerRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmeRemoteControllerRequest* msg);
};

const ::opi_api::storage::v1::NvmeRemoteController&
UpdateNvmeRemoteControllerRequest::_Internal::nvme_remote_controller(const UpdateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.nvme_remote_controller_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmeRemoteControllerRequest::_Internal::update_mask(const UpdateNvmeRemoteControllerRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmeRemoteControllerRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
}
UpdateNvmeRemoteControllerRequest::UpdateNvmeRemoteControllerRequest(const UpdateNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_remote_controller()) {
    _this->_impl_.nvme_remote_controller_ = new ::opi_api::storage::v1::NvmeRemoteController(*from._impl_.nvme_remote_controller_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
}

inline void UpdateNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controller_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmeRemoteControllerRequest::~UpdateNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_remote_controller_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_remote_controller_ != nullptr) {
    delete _impl_.nvme_remote_controller_;
  }
  _impl_.nvme_remote_controller_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_remote_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_remote_controller(this),
        _Internal::nvme_remote_controller(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  return target;
}

size_t UpdateNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmeRemoteController nvme_remote_controller = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_remote_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_remote_controller_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_remote_controller()) {
    _this->_internal_mutable_nvme_remote_controller()->::opi_api::storage::v1::NvmeRemoteController::MergeFrom(
        from._internal_nvme_remote_controller());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmeRemoteControllerRequest::CopyFrom(const UpdateNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void UpdateNvmeRemoteControllerRequest::InternalSwap(UpdateNvmeRemoteControllerRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmeRemoteControllerRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmeRemoteControllerRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmeRemoteControllerRequest, _impl_.nvme_remote_controller_)>(
          reinterpret_cast<char*>(&_impl_.nvme_remote_controller_),
          reinterpret_cast<char*>(&other->_impl_.nvme_remote_controller_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[7]);
}

// ===================================================================

class ListNvmeRemoteControllersRequest::_Internal {
 public:
};

ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
}
ListNvmeRemoteControllersRequest::ListNvmeRemoteControllersRequest(const ListNvmeRemoteControllersRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteControllersRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
}

inline void ListNvmeRemoteControllersRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteControllersRequest::~ListNvmeRemoteControllersRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteControllersRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeRemoteControllersRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteControllersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteControllersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteControllersRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  return target;
}

size_t ListNvmeRemoteControllersRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteControllersRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteControllersRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteControllersRequest::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteControllersRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteControllersRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteControllersRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteControllersRequest::CopyFrom(const ListNvmeRemoteControllersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteControllersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteControllersRequest::IsInitialized() const {
  return true;
}

void ListNvmeRemoteControllersRequest::InternalSwap(ListNvmeRemoteControllersRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteControllersRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[8]);
}

// ===================================================================

class ListNvmeRemoteControllersResponse::_Internal {
 public:
};

ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
}
ListNvmeRemoteControllersResponse::ListNvmeRemoteControllersResponse(const ListNvmeRemoteControllersResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteControllersResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controllers_){from._impl_.nvme_remote_controllers_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
}

inline void ListNvmeRemoteControllersResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_controllers_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteControllersResponse::~ListNvmeRemoteControllersResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteControllersResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_controllers_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeRemoteControllersResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteControllersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_controllers_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteControllersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_remote_controllers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteControllersResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_remote_controllers_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_remote_controllers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteControllersResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  return target;
}

size_t ListNvmeRemoteControllersResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteController nvme_remote_controllers = 1;
  total_size += 1UL * this->_internal_nvme_remote_controllers_size();
  for (const auto& msg : this->_impl_.nvme_remote_controllers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteControllersResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteControllersResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteControllersResponse::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteControllersResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteControllersResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteControllersResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_remote_controllers_.MergeFrom(from._impl_.nvme_remote_controllers_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteControllersResponse::CopyFrom(const ListNvmeRemoteControllersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteControllersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteControllersResponse::IsInitialized() const {
  return true;
}

void ListNvmeRemoteControllersResponse::InternalSwap(ListNvmeRemoteControllersResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_remote_controllers_.InternalSwap(&other->_impl_.nvme_remote_controllers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteControllersResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[9]);
}

// ===================================================================

class GetNvmeRemoteControllerRequest::_Internal {
 public:
};

GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
}
GetNvmeRemoteControllerRequest::GetNvmeRemoteControllerRequest(const GetNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
}

inline void GetNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeRemoteControllerRequest::~GetNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  return target;
}

size_t GetNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void GetNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeRemoteControllerRequest::CopyFrom(const GetNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void GetNvmeRemoteControllerRequest::InternalSwap(GetNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[10]);
}

// ===================================================================

class ResetNvmeRemoteControllerRequest::_Internal {
 public:
};

ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
}
ResetNvmeRemoteControllerRequest::ResetNvmeRemoteControllerRequest(const ResetNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ResetNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
}

inline void ResetNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResetNvmeRemoteControllerRequest::~ResetNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void ResetNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ResetNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ResetNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ResetNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  return target;
}

size_t ResetNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ResetNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ResetNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ResetNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void ResetNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ResetNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const ResetNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ResetNvmeRemoteControllerRequest::CopyFrom(const ResetNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ResetNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void ResetNvmeRemoteControllerRequest::InternalSwap(ResetNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ResetNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[11]);
}

// ===================================================================

class StatsNvmeRemoteControllerRequest::_Internal {
 public:
};

StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
}
StatsNvmeRemoteControllerRequest::StatsNvmeRemoteControllerRequest(const StatsNvmeRemoteControllerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeRemoteControllerRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
}

inline void StatsNvmeRemoteControllerRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmeRemoteControllerRequest::~StatsNvmeRemoteControllerRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeRemoteControllerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmeRemoteControllerRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeRemoteControllerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeRemoteControllerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeRemoteControllerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmeRemoteControllerRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  return target;
}

size_t StatsNvmeRemoteControllerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeRemoteControllerRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeRemoteControllerRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeRemoteControllerRequest::GetClassData() const { return &_class_data_; }


void StatsNvmeRemoteControllerRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeRemoteControllerRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmeRemoteControllerRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeRemoteControllerRequest::CopyFrom(const StatsNvmeRemoteControllerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeRemoteControllerRequest::IsInitialized() const {
  return true;
}

void StatsNvmeRemoteControllerRequest::InternalSwap(StatsNvmeRemoteControllerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeRemoteControllerRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[12]);
}

// ===================================================================

class StatsNvmeRemoteControllerResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmeRemoteControllerResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmeRemoteControllerResponse::_Internal::stats(const StatsNvmeRemoteControllerResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmeRemoteControllerResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
}
StatsNvmeRemoteControllerResponse::StatsNvmeRemoteControllerResponse(const StatsNvmeRemoteControllerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmeRemoteControllerResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
}

inline void StatsNvmeRemoteControllerResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmeRemoteControllerResponse::~StatsNvmeRemoteControllerResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmeRemoteControllerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmeRemoteControllerResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmeRemoteControllerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmeRemoteControllerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmeRemoteControllerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  return target;
}

size_t StatsNvmeRemoteControllerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmeRemoteControllerResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmeRemoteControllerResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmeRemoteControllerResponse::GetClassData() const { return &_class_data_; }


void StatsNvmeRemoteControllerResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmeRemoteControllerResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmeRemoteControllerResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmeRemoteControllerResponse::CopyFrom(const StatsNvmeRemoteControllerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmeRemoteControllerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmeRemoteControllerResponse::IsInitialized() const {
  return true;
}

void StatsNvmeRemoteControllerResponse::InternalSwap(StatsNvmeRemoteControllerResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmeRemoteControllerResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[13]);
}

// ===================================================================

class ListNvmeRemoteNamespacesRequest::_Internal {
 public:
};

ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
}
ListNvmeRemoteNamespacesRequest::ListNvmeRemoteNamespacesRequest(const ListNvmeRemoteNamespacesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteNamespacesRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
}

inline void ListNvmeRemoteNamespacesRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteNamespacesRequest::~ListNvmeRemoteNamespacesRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteNamespacesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmeRemoteNamespacesRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteNamespacesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteNamespacesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteNamespacesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  return target;
}

size_t ListNvmeRemoteNamespacesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteNamespacesRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteNamespacesRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteNamespacesRequest::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteNamespacesRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteNamespacesRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteNamespacesRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteNamespacesRequest::CopyFrom(const ListNvmeRemoteNamespacesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteNamespacesRequest::IsInitialized() const {
  return true;
}

void ListNvmeRemoteNamespacesRequest::InternalSwap(ListNvmeRemoteNamespacesRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteNamespacesRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[14]);
}

// ===================================================================

class ListNvmeRemoteNamespacesResponse::_Internal {
 public:
};

ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
}
ListNvmeRemoteNamespacesResponse::ListNvmeRemoteNamespacesResponse(const ListNvmeRemoteNamespacesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmeRemoteNamespacesResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_namespaces_){from._impl_.nvme_remote_namespaces_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
}

inline void ListNvmeRemoteNamespacesResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_remote_namespaces_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmeRemoteNamespacesResponse::~ListNvmeRemoteNamespacesResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmeRemoteNamespacesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_remote_namespaces_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmeRemoteNamespacesResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmeRemoteNamespacesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_remote_namespaces_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmeRemoteNamespacesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_remote_namespaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmeRemoteNamespacesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_remote_namespaces_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_remote_namespaces(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmeRemoteNamespacesResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  return target;
}

size_t ListNvmeRemoteNamespacesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmeRemoteNamespace nvme_remote_namespaces = 1;
  total_size += 1UL * this->_internal_nvme_remote_namespaces_size();
  for (const auto& msg : this->_impl_.nvme_remote_namespaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmeRemoteNamespacesResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmeRemoteNamespacesResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmeRemoteNamespacesResponse::GetClassData() const { return &_class_data_; }


void ListNvmeRemoteNamespacesResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmeRemoteNamespacesResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmeRemoteNamespacesResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_remote_namespaces_.MergeFrom(from._impl_.nvme_remote_namespaces_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmeRemoteNamespacesResponse::CopyFrom(const ListNvmeRemoteNamespacesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmeRemoteNamespacesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmeRemoteNamespacesResponse::IsInitialized() const {
  return true;
}

void ListNvmeRemoteNamespacesResponse::InternalSwap(ListNvmeRemoteNamespacesResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_remote_namespaces_.InternalSwap(&other->_impl_.nvme_remote_namespaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmeRemoteNamespacesResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[15]);
}

// ===================================================================

class GetNvmeRemoteNamespaceRequest::_Internal {
 public:
};

GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
}
GetNvmeRemoteNamespaceRequest::GetNvmeRemoteNamespaceRequest(const GetNvmeRemoteNamespaceRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmeRemoteNamespaceRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
}

inline void GetNvmeRemoteNamespaceRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmeRemoteNamespaceRequest::~GetNvmeRemoteNamespaceRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmeRemoteNamespaceRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmeRemoteNamespaceRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmeRemoteNamespaceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmeRemoteNamespaceRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmeRemoteNamespaceRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmeRemoteNamespaceRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  return target;
}

size_t GetNvmeRemoteNamespaceRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmeRemoteNamespaceRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmeRemoteNamespaceRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmeRemoteNamespaceRequest::GetClassData() const { return &_class_data_; }


void GetNvmeRemoteNamespaceRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmeRemoteNamespaceRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmeRemoteNamespaceRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmeRemoteNamespaceRequest::CopyFrom(const GetNvmeRemoteNamespaceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmeRemoteNamespaceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmeRemoteNamespaceRequest::IsInitialized() const {
  return true;
}

void GetNvmeRemoteNamespaceRequest::InternalSwap(GetNvmeRemoteNamespaceRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmeRemoteNamespaceRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[16]);
}

// ===================================================================

class CreateNvmePathRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmePath& nvme_path(const CreateNvmePathRequest* msg);
};

const ::opi_api::storage::v1::NvmePath&
CreateNvmePathRequest::_Internal::nvme_path(const CreateNvmePathRequest* msg) {
  return *msg->_impl_.nvme_path_;
}
CreateNvmePathRequest::CreateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.CreateNvmePathRequest)
}
CreateNvmePathRequest::CreateNvmePathRequest(const CreateNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_id_){}
    , decltype(_impl_.nvme_path_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nvme_path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nvme_path_id().empty()) {
    _this->_impl_.nvme_path_id_.Set(from._internal_nvme_path_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_nvme_path()) {
    _this->_impl_.nvme_path_ = new ::opi_api::storage::v1::NvmePath(*from._impl_.nvme_path_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.CreateNvmePathRequest)
}

inline void CreateNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_id_){}
    , decltype(_impl_.nvme_path_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nvme_path_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nvme_path_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateNvmePathRequest::~CreateNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.CreateNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_path_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.nvme_path_;
}

void CreateNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.CreateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_path_id_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nvme_path_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.CreateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_path(this),
        _Internal::nvme_path(this).GetCachedSize(), target, stream);
  }

  // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_path_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nvme_path_id().data(), static_cast<int>(this->_internal_nvme_path_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.CreateNvmePathRequest.nvme_path_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nvme_path_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.CreateNvmePathRequest)
  return target;
}

size_t CreateNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.CreateNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nvme_path_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_nvme_path_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nvme_path_id());
  }

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_path_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateNvmePathRequest::GetClassData() const { return &_class_data_; }


void CreateNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const CreateNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.CreateNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nvme_path_id().empty()) {
    _this->_internal_set_nvme_path_id(from._internal_nvme_path_id());
  }
  if (from._internal_has_nvme_path()) {
    _this->_internal_mutable_nvme_path()->::opi_api::storage::v1::NvmePath::MergeFrom(
        from._internal_nvme_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateNvmePathRequest::CopyFrom(const CreateNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.CreateNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNvmePathRequest::IsInitialized() const {
  return true;
}

void CreateNvmePathRequest::InternalSwap(CreateNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nvme_path_id_, lhs_arena,
      &other->_impl_.nvme_path_id_, rhs_arena
  );
  swap(_impl_.nvme_path_, other->_impl_.nvme_path_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[17]);
}

// ===================================================================

class DeleteNvmePathRequest::_Internal {
 public:
};

DeleteNvmePathRequest::DeleteNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.DeleteNvmePathRequest)
}
DeleteNvmePathRequest::DeleteNvmePathRequest(const DeleteNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.DeleteNvmePathRequest)
}

inline void DeleteNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteNvmePathRequest::~DeleteNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.DeleteNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void DeleteNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.DeleteNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.DeleteNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.DeleteNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.DeleteNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.DeleteNvmePathRequest)
  return target;
}

size_t DeleteNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.DeleteNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNvmePathRequest::GetClassData() const { return &_class_data_; }


void DeleteNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const DeleteNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.DeleteNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNvmePathRequest::CopyFrom(const DeleteNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.DeleteNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNvmePathRequest::IsInitialized() const {
  return true;
}

void DeleteNvmePathRequest::InternalSwap(DeleteNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.allow_missing_, other->_impl_.allow_missing_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[18]);
}

// ===================================================================

class UpdateNvmePathRequest::_Internal {
 public:
  static const ::opi_api::storage::v1::NvmePath& nvme_path(const UpdateNvmePathRequest* msg);
  static const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask(const UpdateNvmePathRequest* msg);
};

const ::opi_api::storage::v1::NvmePath&
UpdateNvmePathRequest::_Internal::nvme_path(const UpdateNvmePathRequest* msg) {
  return *msg->_impl_.nvme_path_;
}
const ::PROTOBUF_NAMESPACE_ID::FieldMask&
UpdateNvmePathRequest::_Internal::update_mask(const UpdateNvmePathRequest* msg) {
  return *msg->_impl_.update_mask_;
}
void UpdateNvmePathRequest::clear_update_mask() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
}
UpdateNvmePathRequest::UpdateNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.UpdateNvmePathRequest)
}
UpdateNvmePathRequest::UpdateNvmePathRequest(const UpdateNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_nvme_path()) {
    _this->_impl_.nvme_path_ = new ::opi_api::storage::v1::NvmePath(*from._impl_.nvme_path_);
  }
  if (from._internal_has_update_mask()) {
    _this->_impl_.update_mask_ = new ::PROTOBUF_NAMESPACE_ID::FieldMask(*from._impl_.update_mask_);
  }
  _this->_impl_.allow_missing_ = from._impl_.allow_missing_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.UpdateNvmePathRequest)
}

inline void UpdateNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_path_){nullptr}
    , decltype(_impl_.update_mask_){nullptr}
    , decltype(_impl_.allow_missing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateNvmePathRequest::~UpdateNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.UpdateNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.nvme_path_;
  if (this != internal_default_instance()) delete _impl_.update_mask_;
}

void UpdateNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.UpdateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.nvme_path_ != nullptr) {
    delete _impl_.nvme_path_;
  }
  _impl_.nvme_path_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.update_mask_ != nullptr) {
    delete _impl_.update_mask_;
  }
  _impl_.update_mask_ = nullptr;
  _impl_.allow_missing_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_nvme_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.allow_missing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.UpdateNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::nvme_path(this),
        _Internal::nvme_path(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::update_mask(this),
        _Internal::update_mask(this).GetCachedSize(), target, stream);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_missing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.UpdateNvmePathRequest)
  return target;
}

size_t UpdateNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.UpdateNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.NvmePath nvme_path = 1 [(.google.api.field_behavior) = REQUIRED];
  if (this->_internal_has_nvme_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nvme_path_);
  }

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_has_update_mask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.update_mask_);
  }

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_allow_missing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNvmePathRequest::GetClassData() const { return &_class_data_; }


void UpdateNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const UpdateNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.UpdateNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nvme_path()) {
    _this->_internal_mutable_nvme_path()->::opi_api::storage::v1::NvmePath::MergeFrom(
        from._internal_nvme_path());
  }
  if (from._internal_has_update_mask()) {
    _this->_internal_mutable_update_mask()->::PROTOBUF_NAMESPACE_ID::FieldMask::MergeFrom(
        from._internal_update_mask());
  }
  if (from._internal_allow_missing() != 0) {
    _this->_internal_set_allow_missing(from._internal_allow_missing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNvmePathRequest::CopyFrom(const UpdateNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.UpdateNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNvmePathRequest::IsInitialized() const {
  return true;
}

void UpdateNvmePathRequest::InternalSwap(UpdateNvmePathRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNvmePathRequest, _impl_.allow_missing_)
      + sizeof(UpdateNvmePathRequest::_impl_.allow_missing_)
      - PROTOBUF_FIELD_OFFSET(UpdateNvmePathRequest, _impl_.nvme_path_)>(
          reinterpret_cast<char*>(&_impl_.nvme_path_),
          reinterpret_cast<char*>(&other->_impl_.nvme_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[19]);
}

// ===================================================================

class ListNvmePathsRequest::_Internal {
 public:
};

ListNvmePathsRequest::ListNvmePathsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmePathsRequest)
}
ListNvmePathsRequest::ListNvmePathsRequest(const ListNvmePathsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmePathsRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_parent().empty()) {
    _this->_impl_.parent_.Set(from._internal_parent(), 
      _this->GetArenaForAllocation());
  }
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_page_token().empty()) {
    _this->_impl_.page_token_.Set(from._internal_page_token(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.page_size_ = from._impl_.page_size_;
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmePathsRequest)
}

inline void ListNvmePathsRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.parent_){}
    , decltype(_impl_.page_token_){}
    , decltype(_impl_.page_size_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.parent_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmePathsRequest::~ListNvmePathsRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmePathsRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmePathsRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.parent_.Destroy();
  _impl_.page_token_.Destroy();
}

void ListNvmePathsRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmePathsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmePathsRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parent_.ClearToEmpty();
  _impl_.page_token_.ClearToEmpty();
  _impl_.page_size_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmePathsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_parent();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsRequest.parent"));
        } else
          goto handle_unusual;
        continue;
      // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.page_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsRequest.page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmePathsRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmePathsRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_parent().data(), static_cast<int>(this->_internal_parent().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsRequest.parent");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_parent(), target);
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_page_size(), target);
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_page_token().data(), static_cast<int>(this->_internal_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsRequest.page_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmePathsRequest)
  return target;
}

size_t ListNvmePathsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmePathsRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_parent().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_parent());
  }

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  if (!this->_internal_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_page_token());
  }

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  if (this->_internal_page_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_page_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmePathsRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmePathsRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmePathsRequest::GetClassData() const { return &_class_data_; }


void ListNvmePathsRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmePathsRequest*>(&to_msg);
  auto& from = static_cast<const ListNvmePathsRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmePathsRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_parent().empty()) {
    _this->_internal_set_parent(from._internal_parent());
  }
  if (!from._internal_page_token().empty()) {
    _this->_internal_set_page_token(from._internal_page_token());
  }
  if (from._internal_page_size() != 0) {
    _this->_internal_set_page_size(from._internal_page_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmePathsRequest::CopyFrom(const ListNvmePathsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmePathsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmePathsRequest::IsInitialized() const {
  return true;
}

void ListNvmePathsRequest::InternalSwap(ListNvmePathsRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.parent_, lhs_arena,
      &other->_impl_.parent_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.page_token_, lhs_arena,
      &other->_impl_.page_token_, rhs_arena
  );
  swap(_impl_.page_size_, other->_impl_.page_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmePathsRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[20]);
}

// ===================================================================

class ListNvmePathsResponse::_Internal {
 public:
};

ListNvmePathsResponse::ListNvmePathsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.ListNvmePathsResponse)
}
ListNvmePathsResponse::ListNvmePathsResponse(const ListNvmePathsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNvmePathsResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_paths_){from._impl_.nvme_paths_}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_next_page_token().empty()) {
    _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.ListNvmePathsResponse)
}

inline void ListNvmePathsResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nvme_paths_){arena}
    , decltype(_impl_.next_page_token_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.next_page_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListNvmePathsResponse::~ListNvmePathsResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.ListNvmePathsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNvmePathsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nvme_paths_.~RepeatedPtrField();
  _impl_.next_page_token_.Destroy();
}

void ListNvmePathsResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNvmePathsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.ListNvmePathsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nvme_paths_.Clear();
  _impl_.next_page_token_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNvmePathsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nvme_paths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string next_page_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_next_page_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.ListNvmePathsResponse.next_page_token"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNvmePathsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.ListNvmePathsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nvme_paths_size()); i < n; i++) {
    const auto& repfield = this->_internal_nvme_paths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_next_page_token().data(), static_cast<int>(this->_internal_next_page_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.ListNvmePathsResponse.next_page_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_next_page_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.ListNvmePathsResponse)
  return target;
}

size_t ListNvmePathsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.ListNvmePathsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .opi_api.storage.v1.NvmePath nvme_paths = 1;
  total_size += 1UL * this->_internal_nvme_paths_size();
  for (const auto& msg : this->_impl_.nvme_paths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string next_page_token = 2;
  if (!this->_internal_next_page_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_next_page_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNvmePathsResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNvmePathsResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNvmePathsResponse::GetClassData() const { return &_class_data_; }


void ListNvmePathsResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNvmePathsResponse*>(&to_msg);
  auto& from = static_cast<const ListNvmePathsResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.ListNvmePathsResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nvme_paths_.MergeFrom(from._impl_.nvme_paths_);
  if (!from._internal_next_page_token().empty()) {
    _this->_internal_set_next_page_token(from._internal_next_page_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNvmePathsResponse::CopyFrom(const ListNvmePathsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.ListNvmePathsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNvmePathsResponse::IsInitialized() const {
  return true;
}

void ListNvmePathsResponse::InternalSwap(ListNvmePathsResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nvme_paths_.InternalSwap(&other->_impl_.nvme_paths_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.next_page_token_, lhs_arena,
      &other->_impl_.next_page_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNvmePathsResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[21]);
}

// ===================================================================

class GetNvmePathRequest::_Internal {
 public:
};

GetNvmePathRequest::GetNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.GetNvmePathRequest)
}
GetNvmePathRequest::GetNvmePathRequest(const GetNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.GetNvmePathRequest)
}

inline void GetNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetNvmePathRequest::~GetNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.GetNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void GetNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.GetNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.GetNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.GetNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.GetNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.GetNvmePathRequest)
  return target;
}

size_t GetNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.GetNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetNvmePathRequest::GetClassData() const { return &_class_data_; }


void GetNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const GetNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.GetNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetNvmePathRequest::CopyFrom(const GetNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.GetNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNvmePathRequest::IsInitialized() const {
  return true;
}

void GetNvmePathRequest::InternalSwap(GetNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[22]);
}

// ===================================================================

class StatsNvmePathRequest::_Internal {
 public:
};

StatsNvmePathRequest::StatsNvmePathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmePathRequest)
}
StatsNvmePathRequest::StatsNvmePathRequest(const StatsNvmePathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmePathRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmePathRequest)
}

inline void StatsNvmePathRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StatsNvmePathRequest::~StatsNvmePathRequest() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmePathRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmePathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void StatsNvmePathRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmePathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmePathRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmePathRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "opi_api.storage.v1.StatsNvmePathRequest.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmePathRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmePathRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "opi_api.storage.v1.StatsNvmePathRequest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmePathRequest)
  return target;
}

size_t StatsNvmePathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmePathRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmePathRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmePathRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmePathRequest::GetClassData() const { return &_class_data_; }


void StatsNvmePathRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmePathRequest*>(&to_msg);
  auto& from = static_cast<const StatsNvmePathRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmePathRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmePathRequest::CopyFrom(const StatsNvmePathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmePathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmePathRequest::IsInitialized() const {
  return true;
}

void StatsNvmePathRequest::InternalSwap(StatsNvmePathRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmePathRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[23]);
}

// ===================================================================

class StatsNvmePathResponse::_Internal {
 public:
  static const ::opi_api::storage::v1::VolumeStats& stats(const StatsNvmePathResponse* msg);
};

const ::opi_api::storage::v1::VolumeStats&
StatsNvmePathResponse::_Internal::stats(const StatsNvmePathResponse* msg) {
  return *msg->_impl_.stats_;
}
void StatsNvmePathResponse::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
StatsNvmePathResponse::StatsNvmePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:opi_api.storage.v1.StatsNvmePathResponse)
}
StatsNvmePathResponse::StatsNvmePathResponse(const StatsNvmePathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatsNvmePathResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stats()) {
    _this->_impl_.stats_ = new ::opi_api::storage::v1::VolumeStats(*from._impl_.stats_);
  }
  // @@protoc_insertion_point(copy_constructor:opi_api.storage.v1.StatsNvmePathResponse)
}

inline void StatsNvmePathResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stats_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatsNvmePathResponse::~StatsNvmePathResponse() {
  // @@protoc_insertion_point(destructor:opi_api.storage.v1.StatsNvmePathResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatsNvmePathResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stats_;
}

void StatsNvmePathResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatsNvmePathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:opi_api.storage.v1.StatsNvmePathResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatsNvmePathResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .opi_api.storage.v1.VolumeStats stats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatsNvmePathResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:opi_api.storage.v1.StatsNvmePathResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:opi_api.storage.v1.StatsNvmePathResponse)
  return target;
}

size_t StatsNvmePathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:opi_api.storage.v1.StatsNvmePathResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .opi_api.storage.v1.VolumeStats stats = 1;
  if (this->_internal_has_stats()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stats_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatsNvmePathResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatsNvmePathResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatsNvmePathResponse::GetClassData() const { return &_class_data_; }


void StatsNvmePathResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatsNvmePathResponse*>(&to_msg);
  auto& from = static_cast<const StatsNvmePathResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:opi_api.storage.v1.StatsNvmePathResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stats()) {
    _this->_internal_mutable_stats()->::opi_api::storage::v1::VolumeStats::MergeFrom(
        from._internal_stats());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatsNvmePathResponse::CopyFrom(const StatsNvmePathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:opi_api.storage.v1.StatsNvmePathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatsNvmePathResponse::IsInitialized() const {
  return true;
}

void StatsNvmePathResponse::InternalSwap(StatsNvmePathResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.stats_, other->_impl_.stats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatsNvmePathResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_backend_5fnvme_2eproto_getter, &descriptor_table_backend_5fnvme_2eproto_once,
      file_level_metadata_backend_5fnvme_2eproto[24]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeRemoteController*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeRemoteController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeRemoteController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::TcpController*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::TcpController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::TcpController >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmePath*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmePath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmePath >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::FabricsPath*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::FabricsPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::FabricsPath >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::NvmeRemoteNamespace*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::NvmeRemoteNamespace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::NvmeRemoteNamespace >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteControllersRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteControllersRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteControllersRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteControllersResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteControllersResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteControllersResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ResetNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeRemoteControllerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmeRemoteControllerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteNamespacesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmeRemoteNamespacesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmeRemoteNamespaceRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::CreateNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::CreateNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::CreateNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::DeleteNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::DeleteNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::DeleteNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::UpdateNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::UpdateNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::UpdateNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmePathsRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmePathsRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmePathsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::ListNvmePathsResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::ListNvmePathsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::ListNvmePathsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::GetNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::GetNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::GetNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmePathRequest*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmePathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmePathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::opi_api::storage::v1::StatsNvmePathResponse*
Arena::CreateMaybeMessage< ::opi_api::storage::v1::StatsNvmePathResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::opi_api::storage::v1::StatsNvmePathResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
